<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <ul class="nav">
        
        <li><a href="/">首页</a></li>
        
        <li><a href="/archives">归档</a></li>
        
        <li><a href="/about">关于</a></li>
        
    </ul>
</div>
                
                <div class="post-list">
    
    <div class="post">
        <a class="post-title" href="/2022/05/21/edsac/">在1951年如何编程--以 EDSAC 为例</a>
        <div class="post-except">
             EDSAC
EDSAC 是剑桥大学数学实验室设计并建造的计算机。1949年，项目组成功地用 EDSAC 生成并打印了平方数表[1]，象征着 EDSAC 正式投入使用。

EDSAC的基本计算模型与现代计算机已经非常相似，可以概括为：

具有 32 个箱（Tank），每个箱存储 32 个字（Word），注意这里的字是 18 个比特，而非 x86 平台上的 16 个比特。这 32 个箱类似于现代计算机的内存（下文用“内存”来称呼这32个箱）。
具有 5 个寄存器，其中两个寄存器
            <a class="read-more" href="/2022/05/21/edsac/"> ... </a>
        </div>
        <div class="post-date">2022.05.21</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/11/25/hindley-milner/">十分钟搞懂 Hindley-Milner 类型系统</a>
        <div class="post-except">
             类型推理
 什么是类型推理
程序员是懒惰的生物。很多时候，我们并不想啰嗦地给出类型：
let t = 1 + 1let f x = x + 1
这里的t、f、x三个变量，每个的类型都是很明确的。当然，更多的时候，显示地给出类型是更好的。
还有一些时候，给出类型并不是很容易的事情，例如：
let s f g x = f x (g x)let k x y = xlet i = s k klet ϕ = s (k (s i)) k
请问，ϕ的类型是什么？
ϕ的类型是可以计算出来的
            <a class="read-more" href="/2021/11/25/hindley-milner/"> ... </a>
        </div>
        <div class="post-date">2021.11.25</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/09/20/uni-intro-elim/">高中数学题与全称量词的引入/消除规则</a>
        <div class="post-except">
             一道高中数学题
有这样一道高中数学题：
问题1. 考虑一个定义域为实数的函数f(x)f(x)f(x)，如果对于任意的x∈Rx ∈ \mathbb{R}x∈R，有f(x+1)=−f(x)f(x + 1)=-f(x)f(x+1)=−f(x)，f(1)=2f(1) = 2f(1)=2，问：f(2021)f(2021)f(2021)等于多少？
首先可以看到，这个问题是不宜问“周期是多少”的，因为怎么问都不严谨。如果问最小正周期的话，立刻可以给出这样的例子：
f(x)=0f(x) =
            <a class="read-more" href="/2021/09/20/uni-intro-elim/"> ... </a>
        </div>
        <div class="post-date">2021.09.20</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/09/14/parametric-poly/">c++模板与参数多态的根本区别</a>
        <div class="post-except">
             c++模板与参数多态
模板(template)是一种c++语言特性，类似于：
template &lt;class T&gt;T id(T x) &#123;    return x;&#125;
这里的T可以是任意类型。很多人都注意到了这与参数多态(parametric polymorphism)的相似性，更有甚者直接把模板机制看作是一种参数多态。比如这份ppt和这个网页。
然而这篇博客中，我将会说明，无论c++模板到底是不是一个好的语言特性，它都和参数多态有根本性的区别
            <a class="read-more" href="/2021/09/14/parametric-poly/"> ... </a>
        </div>
        <div class="post-date">2021.09.14</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/08/29/combinator/">Frege/Hilbert系统与组合子逻辑</a>
        <div class="post-except">
             Frege/Hilbert系统
Frege/Hilbert系统是一个证明系统，是最古老、最简单的证明系统之一。简单来说，这个系统中的证明都是一个命题序列，命题序列中的每个命题PiP_iPi​都是

一个公理
由命题序列 Pk1P_{k_1}Pk1​​和Pk2P_{k_2}Pk2​​(其中k1,k2∈[1,i)k_1, k_2 \in [1, i)k1​,k2​∈[1,i)) 通过modus ponens得到的命题

这所谓的modus ponens是指，如果Pk1P_{k_
            <a class="read-more" href="/2021/08/29/combinator/"> ... </a>
        </div>
        <div class="post-date">2021.08.29</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/02/26/monad/">从实用的角度看Monad（一）</a>
        <div class="post-except">
             从错误处理说起
错误处理是编程语言中的古老话题，从CPU的某些信号，到C++、托管平台里的exception，都是某种形态的错误处理。
在函数式语言中，我们一般采用Result或者说Maybe一类的东西做错误处理，例如说，在Haskell中定义自然数除法，可以这样定义：
data Nat = Zero | S Nat   deriving Show  sub n Zero = nsub Zero n = Zerosub (S n) (S n&#x27;) = sub n n
            <a class="read-more" href="/2021/02/26/monad/"> ... </a>
        </div>
        <div class="post-date">2021.02.26</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/01/22/ext-gcd/">谈谈扩展欧几里得算法</a>
        <div class="post-except">
             扩展欧几里得算法
“欧几里得算法”是数论中用于求得两个整数aaa和bbb的最大公约数c=(a,b)c=(a,b)c=(a,b)的算法。我之前的文章中已经介绍了这个算法的正确性来源于(a,b)=(a−kb),k∈Z(a,b)=(a-k b), k\in \Z(a,b)=(a−kb),k∈Z。而“扩展欧几里得算法”是一个可以得到
sa+tb=(a,b)sa+t b=(a,b)
sa+tb=(a,b)
中的系数sss和ttt的算法。
我第一次看到的这个算法实现，来自于一位精通算法
            <a class="read-more" href="/2021/01/22/ext-gcd/"> ... </a>
        </div>
        <div class="post-date">2021.01.22</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2021/01/03/little/">费马小定理的（部分）直观解释</a>
        <div class="post-except">
             费马小定理
费马小定理是初等数论里面一个很重要的结论。它声称：
∀p,a,Prime(p)→ap=a\forall p, a,Prime(p) \rightarrow a^{p}=a
∀p,a,Prime(p)→ap=a
我仍然记得大一下学期的时候，初遇这个定理，顿觉手足无措、无所适从。我想要『理解』这个定理，换句话说，我想知道这些东西：

这个定理是如何被发现的？
有没有一个直观的理解可以让人『接受』这个事实？
能不能从自然数的其他地方找到对这个事实的解释？

一般来说，
            <a class="read-more" href="/2021/01/03/little/"> ... </a>
        </div>
        <div class="post-date">2021.01.03</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2020/12/26/pascal/">帕斯卡的恩惠</a>
        <div class="post-except">
             从二项式定理说起
下列等式是显然成立的：
(a+b)(a+b)=a2+2ab+b2(a+b)(a+b)(a+b)=a2+3a2b+3ab2+b2(a+b)(a+b) = a^2+2 ab +b^2 \\
(a+b)(a+b)(a+b) = a^2 + 3a^2b+3ab^2+b^2
(a+b)(a+b)=a2+2ab+b2(a+b)(a+b)(a+b)=a2+3a2b+3ab2+b2
看到这如此规整的式子，自然会问，
(a+b)n(a+b)^n 
(a+b)n
它的每一项有
            <a class="read-more" href="/2020/12/26/pascal/"> ... </a>
        </div>
        <div class="post-date">2020.12.26</div>
    </div>
    
    <div class="post">
        <a class="post-title" href="/2020/12/21/gmp/">栈式RAII不能取代GC：谈GMP的C++绑定</a>
        <div class="post-except">
             GNU MP库的C++绑定
GNU MP库是一个大整数和多精度浮点数的运算库。它本身是用C语言写成的，但也提供了C++绑定。当用C++写程序时，如果你不是自虐狂或者狂热的手动编译器变换爱好者，那么用C++绑定毫无疑问是更好的选择。
这是因为，C语言版本的绑定把所有操作都封装成了类似于汇编语言中的指令。比如说，如果要算一个大整数版本的1+2，那么应该这么写：
mpz_t a, b, c;mpz_init_set_ui(a, 1);mpz_init_set_ui(b, 2);m
            <a class="read-more" href="/2020/12/21/gmp/"> ... </a>
        </div>
        <div class="post-date">2020.12.21</div>
    </div>
    
</div>

<div class="paginator">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
</div>

                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">

            </div>
        </div>
    </body>
</html>