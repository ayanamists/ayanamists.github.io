---
title: 编程语言中的“引用”（二）引用类型
author: ayanamists
date: 2020-05-24
---

- [一个类型的“值”](#%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%80%bc)
- [IR类型](#ir%e7%b1%bb%e5%9e%8b)
  - [引用系](#%e5%bc%95%e7%94%a8%e7%b3%bb)
- [显式引用 -- ER类型值](#%e6%98%be%e5%bc%8f%e5%bc%95%e7%94%a8----er%e7%b1%bb%e5%9e%8b%e5%80%bc)
  - [ER类型值的引用系](#er%e7%b1%bb%e5%9e%8b%e5%80%bc%e7%9a%84%e5%bc%95%e7%94%a8%e7%b3%bb)
  - [ER类型值的其他构造方法](#er%e7%b1%bb%e5%9e%8b%e5%80%bc%e7%9a%84%e5%85%b6%e4%bb%96%e6%9e%84%e9%80%a0%e6%96%b9%e6%b3%95)
  - [垃圾回收器支持下的ER类型](#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e5%99%a8%e6%94%af%e6%8c%81%e4%b8%8b%e7%9a%84er%e7%b1%bb%e5%9e%8b)
- [IR类型值作为解释值](#ir%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%bd%9c%e4%b8%ba%e8%a7%a3%e9%87%8a%e5%80%bc)
- [引入IR类型值、ER类型值、非引用类型值对类型系统的影响](#%e5%bc%95%e5%85%a5ir%e7%b1%bb%e5%9e%8b%e5%80%bcer%e7%b1%bb%e5%9e%8b%e5%80%bc%e9%9d%9e%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%80%bc%e5%af%b9%e7%b1%bb%e5%9e%8b%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%bd%b1%e5%93%8d)
  - [非引用类型必须存在，但不一定要开放给用户](#%e9%9d%9e%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%bf%85%e9%a1%bb%e5%ad%98%e5%9c%a8%e4%bd%86%e4%b8%8d%e4%b8%80%e5%ae%9a%e8%a6%81%e5%bc%80%e6%94%be%e7%bb%99%e7%94%a8%e6%88%b7)
  - [把值类型开放给用户，一般来说是引入了IR类型的绑定](#%e6%8a%8a%e5%80%bc%e7%b1%bb%e5%9e%8b%e5%bc%80%e6%94%be%e7%bb%99%e7%94%a8%e6%88%b7%e4%b8%80%e8%88%ac%e6%9d%a5%e8%af%b4%e6%98%af%e5%bc%95%e5%85%a5%e4%ba%86ir%e7%b1%bb%e5%9e%8b%e7%9a%84%e7%bb%91%e5%ae%9a)
  - [引入IR类型值会改变赋值的语义](#%e5%bc%95%e5%85%a5ir%e7%b1%bb%e5%9e%8b%e5%80%bc%e4%bc%9a%e6%94%b9%e5%8f%98%e8%b5%8b%e5%80%bc%e7%9a%84%e8%af%ad%e4%b9%89)
  - [如果同时引入某个对象的引用类型值和非引用类型值，必须分别创造对应的类型](#%e5%a6%82%e6%9e%9c%e5%90%8c%e6%97%b6%e5%bc%95%e5%85%a5%e6%9f%90%e4%b8%aa%e5%af%b9%e8%b1%a1%e7%9a%84%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%80%bc%e5%92%8c%e9%9d%9e%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e5%80%bc%e5%bf%85%e9%a1%bb%e5%88%86%e5%88%ab%e5%88%9b%e9%80%a0%e5%af%b9%e5%ba%94%e7%9a%84%e7%b1%bb%e5%9e%8b)
  - [一个常见的误区](#%e4%b8%80%e4%b8%aa%e5%b8%b8%e8%a7%81%e7%9a%84%e8%af%af%e5%8c%ba)
- [楔子](#%e6%a5%94%e5%ad%90)

什么叫做“引用类型值”呢？在上一篇文章中我们已经对“引用”是什么有了一个感性的认识。

引用类型的值本身，包含一个索引。通过这个索引，我们可以得到被引用的对象。

引用类型有这样几个要素：

+ 引用系 -- 引用类型值所包含的索引，需要在一个哈希表中得到映射。把这个哈希表中键的全体所构成的集合叫做“引用系”。
+ 引用类型的值 -- 引用类型究竟被表示为什么

不过，在讨论“引用类型值”之前，我们必须先讨论一下“值”到底是什么意思。

## 一个类型的“值”

这个问题是比较麻烦的。我们举个例子：自然数类型。

有人可能会轻蔑地说，这有什么好讨论的？自然数类型不就是0、1、2、3等等吗？在计算机里难道不是二进制的电信号吗？

我这里偏不用C语言里的32位整数来实现，而是用函数来实现：

先来定义0：

```scheme

(define zero
  (lambda() #t))

```

再来定义“一个数的后继数”

```scheme

(define next
  (lambda (former)
    (lambda() former)))

```

这样其实就定义了所有的自然数，比如说：

```scheme

;0
(lambda () #t)

;1
(lambda() (lambda() #t))

;2
(lambda() (lambda() (lambda() #t)))

```

你问我，第二个自然数的值是什么？我会回答：是(lambda() (lambda() #t)).

所以，这里讨论的“值”，实际上是数据类型的具体实现。而“引用类型值”，就是“引用类型”的“具体实现”。

当然，这个“具体实现”，也是有一定意义的。比如说(lambda() (lambda() #t))的意义就是自然数的1.

## IR类型

在上一篇文章中，我们提到，把符号绑定到IR类型上，就可以实现C语言风格的变量。

现在考察IR类型的要素。

### 引用系

IR类型的引用系，可以是一个程序的内存空间。在C语言中，就是这样规定的。

但是，这并不是唯一的。

我们也可以创造出这样的引用系：标识符的全体。

什么意思呢？我们之前提到过，（如果不考虑作用域的问题）动态绑定和引用绑定本质上是等价的，我们可以**将符号本身看作一种数据**，而每个符号都绑定到自己的符号数据上。

类似于说：

```c

int a = 0;

// a 绑定到 'a --> 0

printf("%d", a);

// 被翻译为 printf("%d", get('a));

```

## 显式引用 -- ER类型值

在C语言中，IR类型值中的索引可以被显式捕获，得到的新类型，我称之为ER类型：

这定义了一个新的操作和一个新的类型：

+ 对“IR类型”，可以用 get-ref(a)，得到一个“ER类型”值
+ ER类型值有这几个操作：
  + de-ref(er)，er为ER类型值且er = get-ref(ir). 这个操作会返回get(ir)
  + set-ref(er, b)，er为ER类型值且er = get-ref(ir). 这个操作和 set(ir, b) 等价

把ER类型简写为：

```r

er : location -> value

```

这么说，可能还不是特别清楚，我们来举个例子：

```c

int a; // 相当于构造了一个IR类型值，并绑定到a这个符号上，可以记作 a : loc_0 --> undefined
a = 10; // 相当于set(a, 10)，a：loc_0 --> 10
a; // 相当于get(a)

int * p = &a;
// 注意，这里是构造了一个IR类型值，并绑定到p这个符号上，该IR的值为一个ER类型值，应该记作：
// p : loc_1 --> loc_0 -> 10
*p = 1000;
// 相当于 set-ref(p, 1000)， p: loc_1 --> loc_0 -> 1000
```

也就是说，& 这个运算符，将IR类型值中的索引显式捕获，得到一个显式引用值。

### ER类型值的引用系

ER类型值的引用系，和它捕获的IR类型值相同

### ER类型值的其他构造方法

只要一个对象具有索引，或者说，在一定范围内，这个对象可以通过一个不变的值来访问，那么，这个对象就是可以被捕获的。

从这个意义上来说，ER类型值可以捕获任何具有索引的对象。

C语言里，提供了malloc函数来分配内存。用这个函数，我们可以直接构造ER类型值所引用的对象，并得到对该对象的引用：

```c

int * a = (int*)malloc(sizeof(int));
// a: loc_a -> undefined

*a = 0;
// a: loc_1 -> 0

```

### 垃圾回收器支持下的ER类型

ER类型值捕获的是一个“具有索引的对象”。上一个例子中用malloc()构造的对象，需要用free()销毁。

如果这个对象的构造、销毁过程都由语言本身的设施来完成，程序员无需关心，那么这会大大提高程序员的效率。而垃圾回收器，正是实现了这个目的。

例如在C#中，

```c#

List<int> a = new List<int>() { 1,2,3};

```

这里的a，应该被记作 a: loc_a --> loc_l -> list

当然，你可能想问一个问题：

+ 为什么这里不需要特别标识a是List<int>的ER类型？

这个问题请先留在心里，我们之后会做出回答。

## IR类型值作为解释值

我们之前提到过，IR类型值是“绑定值”，它是解释器内部对这个符号的绑定，而这个符号的值，则是它引用的对象。

这也就是说，在真正的解释过程中，IR类型值只是作为一个中间量，而不作为表达式的值。

如果将IR类型值拿到台面上来，让它也作为表达式的值，那么事情会是什么样的呢？

这就是C++中的“引用”。

```c++

int a = 0;
int &b = a;
b = 10;
a;

```

在

```c++

int &b = a;

```

这条语句中，a赋值给b的不是它的解释值0，而是它绑定上的东西

```c++

loc_a --> 0

```

所以，b实际上是：

```c++

loc_b --> loc_a --> 0

```

下一行的

```c++

b = 10;

```

实际上是

```c++

set(get(b), 10);

```

在这样的设计下，b的解释值仍然是

```c++

get(b)

```

**这会得到一个IR类型值，而不是它指向的值**。在C++里，我们通过“类型转换”，可以把它变成指向的值：

```c++

(int)b //这是10

```

## 引入IR类型值、ER类型值、非引用类型值对类型系统的影响

在C++中，符号是引用绑定的。引用绑定所引用的“值”分为三种：

```c++

int a = 0; // a : loc_a --> 0，0是非引用类型值
int * b = &a // b : loc_b --> loc_a -> 0，(loc_a -> 0)是ER类型值
int& c = a; // c : loc_c --> loc_a --> 0， (loc_a --> 0)是IR类型值

```

在C#中，符号也是引用绑定的。但它所引用的值只分为两种：

```c#

int a = 0; // a: loc_a --> 0，0是非引用类型值
List<int> b = new List<int>(); // b: loc_b --> loc_l -> list， (loc_l -> list)是ER类型值

```

而且有趣的是，C#并没有使用*一类的运算符来区分ER类型值和非引用类型值。

下面，我们就来讨论一下，究竟什么时候才可以引入这些类型，以及引入这些类型对类型系统的影响。

### 非引用类型必须存在，但不一定要开放给用户

存在是一个很显然的事实。我们知道，引用类型的值是一个索引，它只能索引到真正的值上，而不能再附加其他信息。所以，为了表示某种数据，非引用类型一定是存在的。

但非引用类型不一定要开放给用户，比如C#中的某个类，它具体的值是不开放给用户的。开放给用户的是一个ER类型值。

### 把值类型开放给用户，一般来说是引入了IR类型的绑定

如果你认真阅读过上一篇文章，那么这个问题是很清晰的。在静态语言中，一般都采用引用绑定。如果把值类型开放给用户，那么一个变量符号绑定上的东西，是IR类型值。

### 引入IR类型值会改变赋值的语义

在引用绑定下，赋值的语义是：

```c++

int b = 10;
// set(b, 10)

int * c = &b;
// set(c, &b)

int d = b;
// set(d, get(b))
```

对于任何类型的符号，赋值都可以这样解释。但如果IR类型作为一种表达式类型被拿到台前，赋值号就要有新的行为：

```c++

int& a = b;
// set(a, b)

a = 10;
// set(get(a), 10)

```

### 如果同时引入某个对象的引用类型值和非引用类型值，必须分别创造对应的类型

这话有些拗口，但所表达的内容是很简单的。

考虑c++里的vector类：

```c++

vector<int> a;
vector<int>* b = new vector<int>();
vector<int>& c = a;

```

如果这个语言中同时存在vector这个类的值、IR类型值和ER类型值，那么它们必须是三个不同的类型。

这似乎很理所应当，但这个认识的言下之意是，如果这个语言中只存在对某种对象的{值类型、IR类型值、ER类型值}的一种，那么只需要存在这个对象的一个类型。

最关键的是，**这个类型长什么样是无所谓的**。

这也就造成了C#中的值类型和引用类型，其形式上是一样的：

```c#

int a = 1;
Test t = new Test();

```

Test这个类型的值，是一个ER类型值，它指向一个Test类的实例。而int类型的值，是值类型，它就是Int本身。

### 一个常见的误区

我在[一份PPT](http://user.ceng.metu.edu.tr/~mutlu/teaching/pl/02-valuesandtypes.pdf)里看到了这样的表述：

> pointers are not references! You can use pointers as references with special operators.

这一条没有问题，你可以认为ER类型不是引用，只有IR类型是引用，在这个语境下，“引用”，就是指的通过访问这个符号来改变它所引用的符号：

```c++

int& a = b;

a = 10;
// 通过访问a来改变b，a和b在某种意义上是一样的。

```

但他紧接着是这一条：

> Some languages regard references like first order values (Java, C++ partially)

这就错了，java的所谓“引用类型”和C#的“引用类型”一样，是ER类型。只不过由于不存在值类型，ER类型可以和值类型长得一样罢了。最直接的证据如下：

```c#

List<int> a = new List<int>(){1, 2, 3};
List<int> b = a;
b = new List<int>(){1, 2, 4};

```

在运行这段代码以后，b是\{1,2,4\}，a是\{1,2,3\}.对b的赋值和对a的赋值是无关的，**中间那一行传递的是a的值，而不是a绑定到的IR值**。

## 楔子

在这篇文章中，我们探讨了三种类型的值--IR类型值、ER类型值、非引用类型值。读者虽然应该已经对这三种类型的值有了比较深刻的认识，但是仅凭这个认识，还不足以解释很多问题，特别是这样的问题：

在C语言中，int*类型的指针和int[]类型的数组有某种等价性。

在我们的体系中，int*类型的指针，毫无疑问是ER类型。但int[]类型的数组，是IR类型、ER类型，还是非引用类型呢？请看下回分晓。