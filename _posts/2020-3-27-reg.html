<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>什么是正则文法</title>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.2/dist/katex.min.css" integrity="sha384-yFRtMMDnQtDRO8rLpMIKrtPCD5jdktao2TV19YiZYWMDkUR5GQZR/NOVTdquEx1j" crossorigin="anonymous">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
        <link href="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.css" rel="stylesheet" type="text/css">
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        <style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        
        <script src="https://cdn.jsdelivr.net/npm/katex-copytex@latest/dist/katex-copytex.min.js"></script>
    </head>
    <body class="vscode-light">
        <hr>
<h2 id="title-%e8%ae%a9%e6%88%91%e4%bb%ac%e5%ae%9e%e7%8e%b0%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e5%90%a7%e4%b8%89%e6%ad%a3%e5%88%99%e6%96%87%e6%b3%95%e4%b8%8e%e5%ae%9e%e7%8e%b0%e6%ad%a3%e5%88%99%e8%a1%a8%e8%be%be%e5%bc%8f%e8%a7%a3%e6%9e%90%e5%bc%95%e6%93%8eauthor-ayanamistsdate-2020-3-27">title: 让我们实现编程语言吧（三）正则文法与实现正则表达式解析引擎
author: ayanamists
date: 2020-3-27</h2>
<h2 id="%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%a3%e5%88%99%e6%96%87%e6%b3%95">什么是正则文法</h2>
<p>正则文法是比较靠谱的文法。它在CFG的基础上继续进行限制：</p>
<p>每一个正则文法的规则只能是以下两个规则之一：</p>
<ul>
<li>形如$$A \rightarrow a$$的规则。</li>
<li>形如$$A \rightarrow aB$$的规则。</li>
</ul>
<p>可以看到这文法是很简单的，过于简单会引起不好用，所以我们也有“增强版”的正则文法，它多了一条规则：</p>
<ul>
<li>如果$$A, B, C...$$是正则文法左端的符号，那么$$X = ABC...$$也是正则文法。</li>
</ul>
<p>这个“增强”实际上是允许正则文法进行连接，我们在后面会看到，它和原来的正则文法是完全等价的。</p>
<h2 id="%e6%ad%a3%e5%88%99%e6%96%87%e6%b3%95%e5%af%b9%e5%ba%94%e7%9a%84%e8%87%aa%e5%8a%a8%e6%9c%ba">正则文法对应的自动机</h2>
<p>自动机的使用是比较广泛的，我们在数字电路和网络协议中都看到过它的身影。在这里，我们使用的是“有限状态自动机”，它简单地说就是一张表或者一幅有向图，这张表或者这幅图记录着状态如何变化（以及什么是起始状态，什么是终止状态等等）。那么，它和正则文法是怎么联系起来的呢？</p>
<p>先不讨论“增强”型的正则文法，只讨论一般的正则文法。一个非常关键的想法是：<strong>把非终结符当作一种“状态”</strong></p>
<p>这样抽象地说可能有点难以理解，我们来说一个具体的文法：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>a</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">S \rightarrow aA 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>b</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A \rightarrow bB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>c</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">B \rightarrow cC 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>→</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">C \rightarrow d 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span></span></span></span></span></p>
<p>很容易可以看出来，这定义的是$$abcd$$这个字符串。</p>
<p>我们可以构想，有这样的一台机器，它输入一个字符串，输出一个布尔值，也就是说，如果这个字符串是“abcd”，那就输出真，否则输出假。</p>
<p>使用“把非终结符当作一种状态”的思想，可以让我们制造出来这种机器。</p>
<p>这机器的开始状态是$$S$$，然后读入一个字符，如果为&quot;a&quot;，就进入$$A$$状态，在$$A$$状态，也读入一个字符，如果为&quot;b&quot;，就进入$$B$$状态，直至在$$C$$状态读入&quot;d&quot;后进入成功状态。</p>
<p>用图片来表示，就是这样：</p>
<p><img src="https://pic.downk.cc/item/5e7e12a4504f4bcb0492dd16.png" alt="1"></p>
<p>（由于是自动生成的，符号可能不太一样）</p>
<p>如果没能执行刚才的操作，这机器就进入“失败”状态。这就解决了我们的判断问题。</p>
<p>你可能会问，这究竟有什么用呢？不就是匹配个字符串吗，需要这么麻烦？</p>
<p>我们经常研究一个问题“如何组合简单的东西来完成复杂的任务”。一个经久不衰的答案是“封闭性”。而正则文法和自动机恰恰是封闭的。</p>
<p>什么意思呢？如果你把一个非终结符和其对应的自动机看作一种“运算单元”，你就会发现，一个或多个“运算单元”可以通过以下的运算生成另一个更复杂的运算单元：</p>
<ol>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>a</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">A = aB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
将一个终结符和一个非终结符连接，会生成一个可以匹配更长语言的非终结符</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A = BC 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
把两个终结符连接起来，会生成一个匹配更长语言的非终结符</li>
<li>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>=</mo><mi>B</mi><mi mathvariant="normal">∣</mi><mi>C</mi></mrow><annotation encoding="application/x-tex">A = B | C 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">∣</span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span></span></span></span></span></p>
将一个终结符和一个终结符用 “|” 连接， 可以生成一个匹配它们两个所对应的语言的终结符</li>
</ol>
<p>另外的几个操作暂时不引入了，我们需要思考的是，刚才我们说<strong>把非终结符当作一种“状态</strong>，而这里，我们实际上做的是<strong>把非终结符当作一个状态机</strong>。这两种思想本质上是完全等价的，但</p>

    </body>
    </html>