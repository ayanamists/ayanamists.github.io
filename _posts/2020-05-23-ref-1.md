---
title: 编程语言中的“引用”（一）绑定层面上的引用
author: ayanamists
date: 2020-05-23
---

很多人都听说过一些说法：

+ C语言里有值类型
+ C++有值类型和引用类型
+ Ruby里面都是“引用”类型
+ scheme里面都是“引用”类型
+ C#有值类型和“引用”类型
+ 引用是“左值”，值是“右值”

我想，大部分合格的程序员，都知道这些说法到底是在说什么东西。但是，这些说法本身远远比它所描述的行为更让人迷惑，其中的“引用”一词多次出现，在不同的上下文中代表了不一样的意思。在这个系列的文章中，我会总结编程语言中的各种“引用”，把这些说法严格化，消除其中的歧义。相信读者在看了我的文章之后，会对这些说法有一个自己的认识。

- [绑定](#%e7%bb%91%e5%ae%9a)
- [值绑定](#%e5%80%bc%e7%bb%91%e5%ae%9a)
- [动态绑定/引用绑定](#%e5%8a%a8%e6%80%81%e7%bb%91%e5%ae%9a%e5%bc%95%e7%94%a8%e7%bb%91%e5%ae%9a)
- [总结](#%e6%80%bb%e7%bb%93)

## 绑定

首先要说一说绑定(binding)。绑定是编程语言里对一个符号的解释。比如说下面的代码：

```c

int a = 0;
printf("%d", a);

```

在下面的printf语句中，a可以被替换为0：

```c

printf("%d", 0);

```

很自然地，我们会说：

> a这个符号，绑定(bound)到0这个值上。

在下面的文章中，我们用如下的记法表示绑定：

```r

a : 0

```

用以下的记法表示求值：

```scheme

(value-of a (a:0)) = 0

```

（由于不是本文重点，这里就不介绍环境、作用域之类的东西了）。

## 值绑定

在haskell\F#等等函数式语言中，绑定可以完全像上面那样解释，也就是说：

```f#

let a = 0

let func = fun x -> x + 1

func a

```

可以这样解释：

```f#

let func = fun x -> x + 1

func 0 //运用(a:0)，代换a

```

```f#

(fun x -> x + 1) 0 //运用(func:(fun x -> x + 1))，代换func

```

```f#

0 + 1 //调用函数时，形参被替换为实参

```

```f#

1 //计算值

```

这就是我所说的“值绑定”。在typescript、rust等等非函数式语言中，let关键字也是做值绑定的。

如果你不熟悉函数式语言，也不熟悉ts\rust，那这里还可以用C语言中的“宏”来理解值绑定：

```c

#define x 1

printf("%d", x + 1);

```

会被预处理器变成：

```c

printf("%d", 1 + 1);

```

这也是一种值绑定，不过它带来了很多问题，我们一般不会在现代语言中使用这种替换字符的宏。

## 动态绑定/引用绑定

在C语言中，我们是不能像上面那样解释符号的。因为这会导致一些错误的行为：

```c

int a = 0;

printf("%d", a);

a = 1;

printf("%d", a);

```

它不能被解释为：

```c

printf("%d", 0);

0 = 1; // 运用(a:0)

printf("%d", 0);

```

为什么不能这样变换了呢？有两个问题：

+ 当符号在赋值号左边的时候，符号的值不能被解释为它绑定的值，这个赋值号的行为也应该是改变符号的绑定值
+ 符号的绑定值是必须实时计算的，而不能把第一个遇到的绑定值直接替换上去

产生问题的根本原因是：

+ 值绑定是不可变的。

那么，应该如何修改这个上面的模型呢？我们只要在解释模型中加入一个哈希表就可以了：

```c

{a:0, b:1 ... }

```

每次对a求值时，我们在这个哈希表里寻找a这个符号的绑定值；每次对a赋值时，我们修改这个哈希表中a对应的值。

```c

int a = 0; //{} 变成 {a:0}
printf("%d", a); //在{a:0}中寻找a，得到0

a = 1; // {a:0} 变成 {a:1}
printf("%d", a); // 在{a:1}中寻找a，得到1

```

仔细思考这个结构的本质，我们会发现，在这个模型中，**符号本身是哈希表的索引**。

引入这样的“动态绑定”，会带来很多麻烦。能不能继续静态地绑定这个符号呢？当然可以。

引入一个新的类型：IR类型

IR类型”的构造方式为：

+ 声明一个局部变量，该局部变量的类型即为IR类型。

“IR类型”应该支持这两种操作：

+ 改变其值，记作 set(a, b)，其中a为此类型的值，b为要set的值。
+ 得到其值，记作 get(a), 其中a为此类型的值，这个操作会返回最近一次set(a, b)中的b，如果没有被set过，则为未定义行为

我们用这种记法来写这个模型：

```r

a : IR(location, value)

```

其中a的绑定值为location，解释值为value。

简写为：

```r

a : location --> value

```

把符号绑定到IR类型上，就可以实现C语言变量的特性：

```c

int a = 0;
// a: loc_a --> 0

printf("%d", a);
// 被解释为 printf("%d", get(loc_a))

a = 1;
// 被解释为 set(loc_a, 1)

```

我将这种符号绑定到IR类型上的行为，叫做“引用绑定”

引用绑定的引入，带来了一个新的问题：**解释值不再与绑定值相同**

在上面的例子里，

```c

a

```

这个符号的绑定值是：

```c

loc_a --> 0

```

解释值为：

```c

0

```

而绑定值到解释值的途径是：

```c

get(loc_a)

```

可以看到，（在不考虑作用域的情况下）动态绑定和引用绑定在本质上是等价的。在动态语言中，多采用“动态绑定”；在静态语言中，多采用“引用绑定”。

## 总结

符号绑定有三种类型。

+ 值绑定
+ 动态绑定
+ 引用绑定

其中后两者是等价的。所以，从大的方向上说，只有两种：

+ 可变绑定 -- 动态绑定/引用绑定
+ 不可变绑定 -- 值绑定

在ts、rust、f#等等语言中，有好几种风格来声明这两种不同的绑定：

```f#

let a = 1
let mutable b = 1

```

```rust

let thing1: i32 = 100;
let mut thing2: i32 = 100;

```

```typescript

let a = 100;
var a = 100;

```

而在C语言中，无论是局部变量，还是静态/全局变量，符号都是引用绑定的，这也是现代计算机系统架构决定的。
