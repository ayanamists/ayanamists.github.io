I"}<section class="hero is-primary is-small">
    <div class="hero-body">
        <div class="container has-text-centered">
            <p class="title is-1">
                BlogFolio
            </p>
            <p class="subtitle is-4">
                <em>Boolean is a Utopia</em>
            </p>
        </div>
    </div>
</section>
<section class="section">
    <div class="container">
        <div class="columns">
            <div class="column is-half is-offset-one-quarter">

                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/06/23/tramp/">
                                    <p class="title is-2">谈谈【蹦床】技术 <span class="tag is-white is-pulled-right"><small>June 23, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="过程式语言中的尾调用">过程式语言中的尾调用</h2>

在scheme中，尾调用完全是循环的：

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">define</span> <span class="nv">factor</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">n</span> <span class="nv">result</span><span class="p">)</span>
    <span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="nb">&lt;</span> <span class="nv">n</span> <span class="mi">2</span><span class="p">)</span>
      <span class="nv">result</span>
      <span class="p">(</span><span class="nf">factor</span> <span class="p">(</span><span class="nb">-</span> <span class="nv">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb">*</span> <span class="nv">result</span> <span class="nv">n</span><span class="p">)))))</span>
</code></pre></div></div>

这段代码和

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">factor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">while</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">n</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

具有完全相同的时间和空间复杂度。这是由于scheme中使用的不是【栈】，而是【继续】(continuation)。如果读者不知道什么是【继续】，可以继续关注我的博客，我会写另外一篇文章来专门解释这个问题。

但在c语言那样的语言中，类似于上面的scheme的代码会产生多余的栈增长：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">rec_factor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">rec_factor</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ret</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

这是因为，在调用rec_factor(n - 1, ret * n)时，这个rec_factor(n, ret)的局部变量、参数等等，都是没有用的。换言之，它应该【退出】之后再调用rec_factor()

<h2 id="蹦床技术">【蹦床】技术</h2>

为了解决这个问题，编程语言专家们引入了【蹦床】技术。这个技术的核心是【先退出，再调用】，如果你把【退出函数】想象成落下，【调用函数】想象成弹起，那么C语言的尾调用就是【跳跳跳跳跳。。。落落落落落】，而再使用了蹦床技术之后，尾调用就像是【跳落跳落跳落。。。】，自然就像一个【蹦床】一样了。

怎么实现呢？我们再考察一下刚才的函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">rec_factor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">rec_factor</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ret</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

如果return的不是一个【函数调用】，而是一个【值】，那么，它就会在这里直接返回。而我们可以在外部用这个【值】来继续计算rec_factor(n - 1, ret * n)，或者说，调用rec_factor(n - 1, ret * n)。

我们先改写一下：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bounce</span> <span class="nf">rec_factor</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">Bounce</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">Bounce</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

可见，这个Bounce需要既能包住一个【值】（也就是C中的值），又能包住一个【调用】。怎么设计呢？如果使用C++的话，我们有lambda()[]{}，std::function之类的匿名函数可以做到【包住调用】这点，但我们这里不用这些东西，而是使用自己定义的数据结构：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Bounce</span> <span class="p">{</span>
	<span class="k">typedef</span> <span class="n">Bounce</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span><span class="p">,</span> <span class="kt">void</span><span class="o">*</span><span class="p">);</span>
	<span class="n">func</span> <span class="n">f</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">;</span>
	<span class="kt">void</span><span class="o">*</span> <span class="n">return_value</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

这里的func类型是为了方便而定义的，第一个参数是【参数的指针】，第二个参数是【返回值的指针】，而它在语法意义上的返回值则是一个Bounce。end用来区分它是一个【函数调用】还是一个【值】。

由于bounce包含了【要调用的函数指针、参数】，它自然可以用来保存调用。我们来看一下改写后的factor函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Bounce</span> <span class="nf">factor</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span> <span class="n">n</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">Bounce</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">);</span>
		<span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">n</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">Bounce</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Bounce</span><span class="o">::</span><span class="n">func</span><span class="p">)</span><span class="n">factor</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">b</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

自然，这样的【函数】是不能直接调用的，因为它返回一个Bounce，我们需要另一个函数来**不断地处理bounce，直至得到一个【被包住的值】，而不是【被包住的调用】为止：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">Tramp</span><span class="p">(</span><span class="n">Bounce</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">end</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">return_value</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">hot</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hot</span><span class="p">.</span><span class="n">end</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">hot</span> <span class="o">=</span> <span class="n">hot</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="n">hot</span><span class="p">.</span><span class="n">args</span><span class="p">,</span> <span class="n">hot</span><span class="p">.</span><span class="n">return_value</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">return_value</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

在外部，我们会这样来调用它：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Bounce</span> <span class="n">b</span><span class="p">;</span>
	<span class="n">b</span><span class="p">.</span><span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">Bounce</span><span class="o">::</span><span class="n">func</span><span class="p">)</span><span class="n">factor</span><span class="p">;</span>
	<span class="n">b</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">.</span><span class="n">args</span> <span class="o">=</span> <span class="mi">100000</span><span class="p">;</span>
	<span class="n">b</span><span class="p">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">b</span><span class="p">.</span><span class="n">return_value</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">b</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">Tramp</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="c1">// 	rec_factor(100000, 1);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">.</span><span class="n">return_value</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

下面那行被注释掉的代码，会爆栈；而我们用【蹦床】技术写的等效代码，则不会爆栈。这样一来，对于所有的尾调用，只要调用的函数满足func类型的函数声明，都可以这样调用而不会消耗额外的栈空间。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/05/23/ref/">
                                    <p class="title is-2">“引用类型”、“指针类型”与“值类型” <span class="tag is-white is-pulled-right"><small>May 23, 2020</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e5%b0%86%e7%ac%a6%e5%8f%b7%e8%a7%a3%e9%87%8a%e4%b8%ba%e5%80%bc">将符号解释为值</a></li>
  <li><a href="#%e5%b0%86%e7%ac%a6%e5%8f%b7%e7%bb%91%e5%ae%9a%e4%b8%bair%e7%b1%bb%e5%9e%8b%e4%bb%8d%e7%84%b6%e8%a7%a3%e9%87%8a%e4%b8%ba%e5%80%bc%e7%b1%bb%e5%9e%8b">将符号绑定为IR类型，仍然解释为值类型</a>
    <ul>
      <li><a href="#%e7%bb%91%e5%ae%9a%e4%b8%8a%e5%92%8c%e8%a7%a3%e9%87%8a%e4%b8%ba%e7%9a%84%e5%8c%ba%e5%88%ab">“绑定上”和“解释为”的区别</a></li>
      <li><a href="#ir%e7%b1%bb%e5%9e%8b%e5%92%8cer%e7%b1%bb%e5%9e%8b">IR类型和ER类型</a></li>
      <li><a href="#%e4%bb%8e%e7%bb%91%e5%ae%9a%e5%80%bc%e5%88%b0%e8%a7%a3%e9%87%8a%e5%80%bc">从绑定值到解释值</a></li>
    </ul>
  </li>
  <li><a href="#%e5%b0%86%e7%ac%a6%e5%8f%b7%e8%a7%a3%e9%87%8a%e4%b8%ba%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">将符号解释为引用类型</a></li>
  <li><a href="#%e4%bc%a0%e5%80%bccall-by-value%e5%92%8c%e4%bc%a0%e5%bc%95%e7%94%a8call-by-reference">传值（call-by-value）和传引用（call-by-reference）</a>
    <ul>
      <li><a href="#%e4%bc%a0%e5%80%bc">传值</a></li>
      <li><a href="#%e4%bc%a0%e5%bc%95%e7%94%a8">传引用</a></li>
    </ul>
  </li>
  <li><a href="#%e6%9f%90%e4%ba%9b%e5%85%b7%e6%9c%89gc%e7%9a%84%e8%af%ad%e8%a8%80%e5%b0%86%e7%ac%a6%e5%8f%b7%e7%bb%91%e5%ae%9a%e5%88%b0%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b%e8%a7%a3%e9%87%8a%e4%b8%ba%e5%80%bc%e6%88%96%e5%bc%95%e7%94%a8%e7%b1%bb%e5%9e%8b">某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型</a>
    <ul>
      <li><a href="#ier%e7%b1%bb%e5%9e%8b">IER类型</a></li>
      <li><a href="#ier%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a5%bd%e5%a4%84">IER类型的好处</a></li>
      <li><a href="#c%e4%b8%ad%e7%9a%84%e4%bc%a0%e5%bc%95%e7%94%a8">C#中的传引用</a></li>
    </ul>
  </li>
  <li><a href="#%e7%9c%9f%e6%ad%a3%e7%9a%84%e5%80%bc%e7%b1%bb%e5%9e%8b">真正的值类型</a></li>
</ul>

在众多编程语言复杂而不统一的设计的影响下，“引用类型”和“值类型”的问题，已经是一个相当混乱的问题了。在这里简单讲一下我的理解。

首先，我们必须知道这两个概念是什么意思。

<ul>
  <li>绑定(binding)。绑定是编程语言里一个符号的解释。</li>
  <li>环境(environment)。环境是所有绑定的形成的复合数据结构。</li>
</ul>

简单地说，在scheme里，我们使用

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">(</span><span class="k">define</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>

<span class="p">(</span><span class="nb">+</span> <span class="nv">x</span> <span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

就是把1这个值绑定到x这个符号上，下面(+ x 1)中的x就可以被解释为1.

<strong>然而，事情其实没有这么简单。</strong>下面，我们以C/C++为例，谈谈一个符号绑定上的，究竟是什么东西。

<h2 id="将符号解释为值">将符号解释为值</h2>

考虑下面的代码：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

</code></pre></div></div>

我们注意到，a这个变量，是可以被替换为0的，上面的代码和下面的代码等价：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

</code></pre></div></div>

这个特性叫做引用透明性(Referential transparency)。其本质就是，一个符号对应一个<strong>不变的值</strong>，就像上面的代码里，我们有：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="m">0</span><span class="w">

</span></code></pre></div></div>

a这个符号，在这个词法作用域里，处处被解释为0，只有声明一个新的a覆盖掉这个符号（C里面不允许这样），a才能不被解释为0.

这才应该是所谓“a这个符号是值类型”的意义。但在C语言里，或者说在大多数命令式编程语言里，<strong>情况与此有些不同</strong>。

<h2 id="将符号绑定为ir类型仍然解释为值类型">将符号绑定为IR类型，仍然解释为值类型</h2>

<h3 id="绑定上和解释为的区别">“绑定上”和“解释为”的区别</h3>

简单来说，“绑定为”是实现上的概念，“解释为”是在外部观察到的现象。比如说，如果找一个C语言的REPL（类似于irb\fsi\scheme一样的东西），你输入

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="n">a</span><span class="p">;</span>

</code></pre></div></div>

它必定告诉你：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span><span class="o">:</span><span class="mi">0</span>

</code></pre></div></div>

但a这个符号到底在解释器里真正对应什么东西，仅凭这个是不能确认的。它在解释器里真正对应的东西，就是“绑定为”的东西。

<h3 id="ir类型和er类型">IR类型和ER类型</h3>

在C语言里，一个变量是可以被赋值的：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

</code></pre></div></div>

如果你还是让a绑定上一个值，那么必须要求绑定本身是可变的，而“可变”还不能是这样的可变：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>

也就是说，不能是开一个新的作用域来“覆盖”，而必须是精准地改变（在这个例子里的）顶层作用域的a符号。我们先禁止这种操作，因为继续看下去，你会发现<strong>这本质上也是引用</strong>。

如果a不能被直接绑定上一个值，它应该被绑定上什么东西呢？<strong>我们创造一个新的类型，叫做“IR类型”</strong>，这个符号绑定上“IR类型”.

IR类型”的构造方式为：

<ul>
  <li>声明一个局部变量，该局部变量的类型即为IR类型。</li>
</ul>

“IR类型”应该支持这两种操作：

<ul>
  <li>改变其值，记作 set(a, b)，其中a为此类型的值，b为要set的值。</li>
  <li>得到其值，记作 get(a), 其中a为此类型的值，这个操作会返回最近一次set(a, b)中的b，如果没有被set过，则为未定义行为</li>
</ul>

如何去实现这个类型呢？实现这个类型的关键在于“记忆最近的b”，而在数字电路中，“记忆”的实现方式是触发器，在现代计算机中就是内存。一个比较自然的想法是，每一个IR类型值都占有一块内存。而这个想法的实现方式，就是在IR类型的实现中，记录这块内存的索引（即地址）。

我们用这种记法来写这个模型：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IR</span><span class="p">(</span><span class="n">location</span><span class="p">,</span><span class="w"> </span><span class="n">value</span><span class="p">)</span><span class="w">

</span></code></pre></div></div>

简写为：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">a</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">value</span><span class="w">

</span></code></pre></div></div>

注意到，在静态语言里，set(a, b)中的B必须是某个类型的值，记此类型为B，我们这样表示这个特定的IR类型：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">IR</span><span class="p">[</span><span class="n">B</span><span class="p">]</span><span class="w">

</span></code></pre></div></div>

你可能会说，<strong>这样不是把“变量”和“指针”混为一谈了吗？这和“指针”有什么区别呢？</strong>不要着急，我们来向这个模型中加入“指针”。

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

</code></pre></div></div>

这定义了一个新的操作和一个新的类型：

<ul>
  <li>对“IR类型”，可以用 get-ref(a)，得到一个“ER类型”值</li>
  <li>ER类型值有这几个操作：
    <ul>
      <li>de-ref(er)，er为ER类型值且er = get-ref(ir). 这个操作会返回get(ir)</li>
      <li>set-ref(er, b)，er为ER类型值且er = get-ref(ir). 这个操作和 set(ir, b) 等价</li>
    </ul>
  </li>
</ul>

把ER类型简写为：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">er</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">value</span><span class="w">

</span></code></pre></div></div>

这么说，可能还不是特别清楚，我们来举个例子：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 相当于构造了一个IR类型值，并绑定到a这个符号上，可以记作 a : loc_0 --&gt; undefined</span>
<span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// 相当于set(a, 10)，a：loc_0 --&gt; 10</span>
<span class="n">a</span><span class="p">;</span> <span class="c1">// 相当于get(a)</span>

<span class="kt">int</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
<span class="c1">// 注意，这里是构造了一个IR类型值，并绑定到p这个符号上，该IR的值为一个ER类型值，应该记作：</span>
<span class="c1">// p : loc_1 --&gt; loc_0 -&gt; 10</span>
<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>
<span class="c1">// 相当于 set-ref(p, 1000)， p: loc_1 --&gt; loc_0 -&gt; 1000</span>
</code></pre></div></div>

讲到这里，我实际上说明了一个问题：<strong>C语言的变量符号，实际上绑定到IR类型值, C语言的指针值，实际上是ER类型值，C语言的指针变量符号，实际上绑定到IR[ER]类型的值</strong>。

<h3 id="从绑定值到解释值">从绑定值到解释值</h3>

从上面的例子中，我们看到，

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

</code></pre></div></div>

这个符号a，绑定为IR类型的值，在我们引用它时，通过

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span><span class="p">;</span>
<span class="o">&lt;=&gt;</span>
<span class="n">get</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

</code></pre></div></div>

这个变换，实现了绑定值到解释值的转换。实际上，我们可以给出这时的绑定值和解释值的完整定义：

<pre><code class="language-BNF">ExpVal = All C Value
BindVal = IR(ExpVal)
</code></pre>

<h2 id="将符号解释为引用类型">将符号解释为引用类型</h2>

我们知道C++中，有引用类型。就像下面这样：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">a</span><span class="p">;</span>

</code></pre></div></div>

如果有C++的REPL，将这份代码打进去，它会告诉你：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span><span class="o">:</span><span class="mi">10</span>

</code></pre></div></div>

这又是怎么一回事呢？实际上，它不过是将我们之前说的IR类型，同时也作为了一种解释值而已。

换句话说，

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">// a: loc_1 --&gt; value</span>
</code></pre></div></div>

这段代码中的b，接受的是a<strong>这个IR值本身</strong>，而不是它的解释值。b可以被记作：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">
</span><span class="n">b</span><span class="o">:</span><span class="w"> </span><span class="n">loc_0</span><span class="o">--&gt;</span><span class="n">loc_1</span><span class="o">--&gt;</span><span class="n">value</span><span class="w">

</span></code></pre></div></div>

这样一来，b的解释值就是

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">loc_1</span><span class="o">--&gt;</span><span class="n">value</span>

</code></pre></div></div>

不过要注意的是，下面的代码：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
<span class="c1">// 如果没有右值引用，c应该是loc_2 --&gt; loc_1 --&gt; loc_0 --&gt; value</span>
</code></pre></div></div>

会报错，这是因为c++用&amp;&amp;当作所谓的“右值引用”，导致引用值不能嵌套了。

<h2 id="传值call-by-value和传引用call-by-reference">传值（call-by-value）和传引用（call-by-reference）</h2>

在大多数语言中，函数调用都可以这样建模：

<pre><code class="language-BNF">
FUNCTION = BODY + ARG (+ ENV)?

</code></pre>

BODY就是函数体，ARG就是形式参数，ENV是这个函数定义时的环境，如果有ENV，它就是一个闭包。C语言中的函数就不是闭包，所以它只有BODY和ARG。

在调用函数时，我们必须将ARG绑定上实际参数，怎么绑定就成了一个问题。

<h3 id="传值">传值</h3>

传值是最自然、最合理的方法。

在传值的情况下，调用函数可以写成：

<ol>
  <li>求每个参数的<strong>解释值</strong></li>
  <li>将对应的值绑定到形式参数上</li>
  <li>求函数体的值（面向表达式）/运行函数体（面向陈述）</li>
</ol>

<h3 id="传引用">传引用</h3>

传引用需要满足两个前置条件：

<ol>
  <li>这个语言的符号（可以）绑定到引用类型</li>
  <li>对应的参数绑定到引用类型</li>
</ol>

也就是说，不绑定到引用类型的符号，或者不是符号的东西（例如字面值、调用函数的结果等等），一般来说是不能传引用的。

用一句话来解释传引用，可以这样说：<strong>传引用时，传递一个绑定到IR值的符号的绑定值，而非解释值。</strong>

这个规则，应该说，叫做”General call by reference”，具体到C++，应该这么说：

<strong>如果符号的解释值是一个值，那么传递这个符号绑定的IR值；如果符号的解释值是一个IR值，那么传递这个解释值。</strong>

我们以一段代码为例，解释上面的话：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kt">void</span> <span class="nf">func2</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">){</span>
  <span class="n">a</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="c1">// a会绑定到 loc_a --&gt; loc_0 --&gt; 0</span>
  <span class="c1">// 所以运行后，a会绑定到 loc_a --&gt; loc_0 --&gt; 2</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// a: loc_0 --&gt; 0</span>
  <span class="n">func2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="c1">// 传入的是 loc_0 --&gt; 0 这个IR值</span>
  <span class="c1">// 汇编形式为</span>
  <span class="cm">/*
   * 00B48E02 8D 45 B8             lea         eax,[a]  
   * 00B48E05 50                   push        eax  
   * 00B48E06 E8 AE 87 FF FF       call        func2
   */</span>
  <span class="kt">int</span> <span class="o">&amp;</span><span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">// b: loc_1 --&gt; loc_0 --&gt; 2</span>
  <span class="n">func2</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  <span class="c1">// 传入的是 b 的解释值 loc_0 --&gt; 2</span>
  <span class="c1">// 汇编形式为</span>
  <span class="cm">/*
   * 007B8E02 8B 45 AC             mov         eax,dword ptr [b]  
   * 007B8E05 50                   push        eax
   * 007B8E06 E8 AE 87 FF FF       call        func2
   */</span>
<span class="p">}</span>

</code></pre></div></div>

为啥C++的传引用和别的语言不太一样呢？这就要从那些带GC的语言说起了。

<h2 id="某些具有gc的语言将符号绑定到引用类型解释为值或引用类型">某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型</h2>

<h3 id="ier类型">IER类型</h3>

预测一下下面的三个带GC的语言，运行差不多代码的结果：

C#:

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">a</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>
<span class="nf">func</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

</code></pre></div></div>

ruby:

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="k">def</span> <span class="nf">func</span> <span class="n">a</span>
  <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">end</span>
<span class="n">func</span> <span class="n">a</span>

</code></pre></div></div>

scheme:

<div class="language-scheme highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="p">(</span><span class="k">define</span> <span class="nv">func</span>
  <span class="p">(</span><span class="k">lambda</span> <span class="p">(</span><span class="nf">x</span><span class="p">)</span>
    <span class="p">(</span><span class="nb">vector-set!</span> <span class="nv">x</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">)))</span>
<span class="p">(</span><span class="k">define</span> <span class="nv">a</span> <span class="p">(</span><span class="nb">vector</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span><span class="p">))</span>
<span class="p">(</span><span class="nf">func</span> <span class="nv">a</span><span class="p">)</span>

</code></pre></div></div>

先要提醒一句，<strong>这三个语言全部是传值的</strong>（C#可以传引用，默认传值）

这三段差不多的代码都会得到一个结果–a变成了 {0, 2, 3}.

为什么呢？因为在这三个语言中，数组这个结构，都是一个类似于ER类型、有IR类型的某些特征的值。

这个“类似于ER类型、有IR类型的某些特征的值”，我把它叫做“IER”类型值。

ER类型值的构造方法为：

<ul>
  <li>每当构造一个新的“引用类型值”（比如一个新的对象）时。</li>
</ul>

例如，.Net IL的newobj指令会构造一个IER类型值，并把它放在求值栈(evalution stack)的栈顶。

IER类型的行为为：

<ul>
  <li>IER类型值的解释值为IER类型值本身</li>
  <li>通过IER类型的值a，可以获得a指向的值（<strong>但在绝大多数有GC的语言中，用户不能这样做</strong>）</li>
  <li>通过IER类型的值a，可以获得a指向的值的一部分（例如，a指向的值是一个对象，那么可以通过a来获得某个成员的值、调用成员方法）</li>
  <li>通过IER类型的值a，可以改变a指向的值（“改变”的意义是模糊的，可以改变整个值，也可以改变这个值的一部分）</li>
  <li>IER类型指向的值，由垃圾回收器负责回收。</li>
</ul>

我们记IRE类型的值为：

<div class="language-r highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ier</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">loc</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="n">value</span><span class="w">
</span></code></pre></div></div>

你也许会问，IER类型的值是IER类型本身，这个特征说明它更像ER类型。它具有IR类型的哪些特质呢？

观察这样的C#代码：

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">a</span> <span class="p">=</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;()</span> <span class="p">{</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">};</span>

</code></pre></div></div>

a这个符号的绑定值的类型为：

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">IR</span><span class="p">[</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;]</span>
<span class="c1">// 看起来像 loc_0 --&gt; value</span>
<span class="c1">// 实际上是 loc_0 --&gt; loc_1 ---&gt; value</span>

</code></pre></div></div>

习惯上，这个类型标志的应该是List&lt;int&gt;本身，而不是对List&lt;int&gt;的引用。所以它形式上更像IR一些。

这样一来，整个类型体系可以被写成：

<pre><code class="language-BNF">
ExpVal = IER + Value
DenVal = IR[ExpVal]
IER = Ref(C# Reference Type)
Value = C# Value Type

</code></pre>

从这里我们可以看到，此处的“引用类型”和C++中的“引用类型”完全是两个东西。C++中的引用类型，是IR，这里的引用类型，是IER。

<h3 id="ier类型的好处">IER类型的好处</h3>

<ul>
  <li>
    IER类型使得程序员不需要考虑大规模对象的复制开销，因为IER类型的值是IER类型本身，赋值过程本质上是共享的。

    <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;(){</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">};</span>
  <span class="c1">// a: loc_a --&gt; loc_1 ---&gt; list0</span>
  <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
  <span class="c1">// b: loc_b --&gt; loc_1 ---&gt; list0</span>
</code></pre></div>    </div>
  </li>
  <li>
    同时，GC的存在使得有一种可靠的方式释放该共享对象。
  </li>
</ul>

<h3 id="c中的传引用">C#中的传引用</h3>

C#中的变量，也都是可变的，所以势必要有和IR类似的结构。（实际上就是IR）。它传引用的方式和我们前面说的一样：传引用时，传递一个绑定到IR值的符号的绑定值，而非解释值。

举个例子：

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">void</span> <span class="nf">func</span><span class="p">(</span><span class="k">ref</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">x</span><span class="p">){</span>
  <span class="c1">// x被绑定到 loc_x --&gt; loc_0 --&gt; loc_1 ---&gt; (list0)</span>
  <span class="n">x</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
  <span class="c1">// x变为 loc_x --&gt; loc_0 --&gt; null</span>
<span class="p">}</span>

<span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
<span class="c1">// a: loc_0 --&gt; loc_1 ---&gt; (list0)</span>
<span class="nf">func</span><span class="p">(</span><span class="k">ref</span> <span class="n">a</span><span class="p">);</span>
<span class="c1">// 传入a的绑定值loc_0 --&gt; loc_1 ---&gt; (list0)</span>

</code></pre></div></div>

<h2 id="真正的值类型">真正的值类型</h2>

在F#、Haskell等等函数式语言里，有真正的、不可变的“值类型”。

<pre><code class="language-f#">
let a = 1

</code></pre>

上面的a，永远会被解释为1。这才是真正的“值类型”。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/04/27/%E7%AB%B9%E7%AC%8B/">
                                    <p class="title is-2">如何正确地烹制春笋 <span class="tag is-white is-pulled-right"><small>April 27, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="我的竹笋记忆">我的竹笋记忆</h2>

笋是我最喜欢的食物之一。记得小时侯在聊城，不时去“永宁酒家”饭店吃饭。酒席上最抓住我味蕾的一道菜是“杂烩”，其中的竹笋片味道鲜香、口感嫩滑，在我的饮食记忆里留下了浓墨重彩的一笔。

高中的时候学化学竞赛，17年5月赴杭州参加“培尖教育”组织的化学竞赛培训。当时的三餐是培训所在酒店提供的。令我印象深刻的是几乎每餐都会有的炒竹笋片，或者应该是叫“油焖竹笋”。它的口感和“杂烩”里的又不同。首先，“杂烩”中的竹笋片，是用很多相交于底面圆心的直径切割圆锥形的竹笋所得的，而杭州的竹笋片，则似乎是用平行于直径的线切割竹笋所得的。其次，杭州的竹笋有浓厚的油香，所谓“素食火腿”大概就是那种感觉。

这两道竹笋菜，使我喜欢上了竹笋这种食材。

<h2 id="一般方法的溃败">一般方法的溃败</h2>

疫情以来，我常常在家中掌勺。自然地，烹制竹笋也被我列上了计划日程。春天到来之后，在市场上就时常看到鲜嫩春笋的身影。我的第一次尝试，就在这时开始了。

买到春笋以后，首先是要扒开它，这并不难。但葛朗台看到此情此景，怕不是要从书里跳出来指责我浪费了。把春笋毛茸茸的棕黑外壳完全剥离之后，你会惊讶地发现，垃圾桶满了，而剩下可食用部分不到一半。

此后我不假思索地切开，用“杂烩”里面的切法切片，把每一片切丝。倒油煸肉炒竹笋丝加调料一气呵成。

但炒出来的菜却绝不能称得上好吃，和饭店里的竹笋有很大差别。总结了一下，主要存在两个不好吃的问题：

<ul>
  <li>味道上，竹笋有苦涩味，而且味道相当重。</li>
  <li>口感上，竹笋硬而干，不讨嘴巴喜欢。</li>
</ul>

<h2 id="改进1-切掉剩余外皮与用水焯制">改进1 切掉剩余外皮与用水焯制</h2>

上次失败之后没几天，我就又买了一颗竹笋，再次进行挑战。

维基百科上对竹笋有这样的描述：

<blockquote>
  竹笋受到阳光照射，会产生“紫杉氰糖苷”(氰甙，Taxiphyllin)，吃起来易有苦味，当储存一定时间后紫杉氰糖苷经水解酶作用后产生氰酸（ＨＣＮ）、醛或酮类，应尽快煮沸杀青处理。
</blockquote>

这“紫杉氰糖苷”的结构式如下：

<img src="https://pic.downk.cc/item/5ea6deacc2a9a83be5bf582e.png" alt="0" />

从分子结构上来看应该还是比较亲水的，我认为焯一下竹笋可能会在很大程度上解决味道苦涩的问题。

而对于口感的问题，我认为应该

<ol>
  <li>在扒开后沿切面方向整个把竹笋的外表刮干净，即使浪费一些也不要紧。</li>
  <li>削出一个新的横截面，因为旧的横截面已经风干很长时间了，很可能是干硬口感的元凶之一。</li>
</ol>

果不其然，这次的口感有很大改进，而味道上虽然有改进，但不算很大。

<h2 id="改进2-用盐水焯">改进2 用盐水焯</h2>

为什么上次的苦涩味没有消除多少呢？细细想来，还是因为那种物质没有溶解多少。如何让那种物质溶解得更多呢？

有这么多羟基，这个化合物应该是相对亲水的。苯酚都有相当的溶解度，这个东西没有道理比苯酚还难溶。

所以这个问题的关键<strong>不在于热力学，而在于动力学</strong>。加盐来破坏细胞结构是一个不错的想法。

这次的尝试就相当成功，剩下的一点苦涩味完全可以看作对肉的油腻的调和。

<h2 id="总结">总结</h2>

我又用改进后的方法做了三次竹笋，味道是比较稳定的。用代码来描述一下这个核心过程–焯水的话，就是这样：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">module</span> <span class="err">烹饪方式</span>

  <span class="k">def</span> <span class="nf">self</span><span class="o">.</span><span class="err">焯水</span><span class="p">(</span><span class="err">食材，时间，环境</span><span class="p">)</span>
    <span class="o">...</span>
  <span class="k">end</span>

<span class="k">end</span>

<span class="err">烹饪方式</span><span class="o">::</span><span class="err">焯水</span><span class="p">(</span><span class="err">竹笋丝，</span><span class="mi">10</span><span class="err">分钟，盐水</span><span class="p">)</span>

</code></pre></div></div>

不过，要想完全达到酒店的口感，这样还不行。这似乎是因为酒店用的笋，很可能是类似于笋干的一类东西。总之，用这个方法，在家里也可以吃到还不错的竹笋了。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/04/27/what-to-watch-2/">
                                    <p class="title is-2">看点什么（二）那些让我不那么满意的作品 <span class="tag is-white is-pulled-right"><small>April 27, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="前言">前言</h2>

这次谈的是“那些让我不那么满意的作品”，注意，这些作品我仍然是喜欢的，只是他们多多少少有些地方让我不那么满意。至于那些我不喜欢的作品，我可能甚至不会去讨论它们。

<h2 id="第一型深刻的题材浅薄的描写">第一型：深刻的题材，浅薄的描写</h2>

想到一个深刻的问题，比解决它可能更有价值。我欣赏能提出严肃问题的作者，更欣赏其作品。

但是，很多作品的状态是提出了一个严肃的问题，却给出轻佻的解答。我一直都会觉得这种作品很可惜，也为作者感到遗憾。不过有些时候，不是作者不想给出认真的解答，而是他没有给出解答的能力，或者说，现在还没到能够解答这个问题的时候。

<h3 id="逃避可耻但有用">《逃避可耻但有用》</h3>

<img src="https://pic.downk.cc/item/5ea6fc8ec2a9a83be5e1a14a.png" alt="0" />

这部剧很出名，主要是火力全开的Gakki的着实光彩四射，一颦一笑，摄人心魄。但是，我真的并不很满意这部剧。

请诸位看过这部剧的同志想想它的第一二集在讲什么呢？程序员加班问题（<strong>这个问题提的很好嘛</strong>）、如何实现人的幸福感和获得感的问题，还有一个经典的女权问题–男性对家务劳动价值的无偿占有。

但是这部剧的后续发展让我实在是不忍直视，这几个问题都没有怎么解决。我原本任务男女主可以真正地建立一种新的家庭关系，虽然在这个关系体系下女主就是一个全职保姆，但就算这样也算是有点突破，也算是探讨了新的家庭形态。

可是，也许是制作组似乎只想让Gakki的笑治愈大家吧，最后男女主来了一出假戏真做白头偕老，又回到了传统的家庭形态。唉，可能是我抱的期待过高了吧。

<h3 id="要听爸爸的话">《要听爸爸的话》</h3>

<img src="https://pic.downk.cc/item/5ea6fc42c2a9a83be5e148cc.jpg" alt="1" />

<strong>原作轻小说的作者已经去世，在此表示对他创作的敬意</strong>。

我只看过动画，所以这里只对动画作评论。读者可能不是很熟悉这部作品，这里引用萌娘百科简单介绍一下：

<blockquote>
  樱花飞舞的季节，青年濑川祐太成为了新鲜的大学生。开学不久，他就很快交到了几位朋友——心地善良，却爱好花天酒地的帅哥仁村浩一；行动诡异，并领导着奇异社团“路上观察研究会”的留级肥宅佐古俊太郎；以及举止优雅，让祐太一见钟情的美人织田莱香……宽松自由的日子，让祐太对接下来的大学生活十分期待。某一天，祐太相依为命的血亲，已结婚三年多的姐姐小鸟游祐理来探望祐太。在姐姐的邀请（命令）下，祐太第一次拜访了小鸟游家。这次邀请其实是小鸟游祐理拜托他看家的委托。祐太接受了请求，并与三年未见的外甥女们——小鸟游空、小鸟游美羽、小鸟游雏重逢。然而令所有人没有想到的是，小鸟游夫妇出行当日遭遇空难，下落不明。祐太失去了至亲的姐姐，而13岁的小空、10岁的美羽、3岁的小雏，则一下子变成了孤儿。面对着夕阳下死寂寒冷的小鸟游家、即将天各一方的三姐妹，以及独立抚养自己长大的姐姐的相片，下定决心的祐太在无力同时抚养三姐妹的亲戚们面前，面对着小鸟游姐妹们说：“要来我家么？”由此，以一名大学生家长和三个美少女的成长为主线，一部讲述了三个可爱“女儿”与她们的“爸爸”朝夕相处、相扶相持的五年时光的，描绘着亲情、责任、恋爱、成长的温馨喜剧，就此展开……
</blockquote>

看完这段描述，我觉得作者如果好好发挥的话，是能获得相当高的人气的。

因为，它触及了一个核心问题：<strong>人如何在现代社会生存下去</strong>。特别地，它触及的问题更加极端：<strong>一个举目无亲大学生和三个小女孩如何在现代社会生存下去</strong>

看这篇文章的读者，无论你是高中生、大学生，还是已经走上社会的人，<strong>请扪心自问：你有能力独立养活三个小女孩吗？</strong>

如果作者给出了一个不借助外部力量的答案，那这部作品就会成为一部励志片。因为，<strong>一个不是那么好的大学的大学生都可以养活三个小女孩，你当然也可以养活自己！</strong>

我们都知道给出这样的答案是不现实的，至少是没有普遍意义的。虽然如此，我们仍然可以给出一个<strong>合理</strong>的答案。

因为这部作品的前一段剧情是合理的，所以到了空难的时候，我们就获得了这样的局面：

<ul>
  <li>小鸟游夫妇住的房子不小，家里资产应该也比较可观</li>
  <li>显然的，三个女儿是第一顺位继承人</li>
</ul>

有这个作铺垫，“一个举目无亲的大学生养活三个小女孩”这件事就不离谱了。这部作品本可以描写祐太如何进行规划、进行投资理财，而且这也不需要花费太多笔墨，下面的重点就转移到<strong>一个大学生如何和三个小女孩一起生活</strong>上，来描写那些温情的东西。如果这么写，那这部作品就成为一部现实主义作品，它可以涉及到社会的方方面面，给作品打上时代的烙印。

可实际上，这部作品没有给出一个合理的答案，它甚至在逃避这个问题。

这种状况，首先因为是作者在空难以后争夺抚养权那一部分写的很不好，他是这样写的：

<blockquote>
  下定决心的祐太在无力同时抚养三姐妹的亲戚们面前，面对着小鸟游姐妹们说：“要来我家么？
</blockquote>

<strong>你确定这真的争夺的到抚养权？？？？？？</strong>

如果我来写这个故事，那些亲戚要么不会有出场的机会，要么会被祐太反杀。我有几种设定方法：

<ul>
  <li>小鸟游家是独子，三个小女孩的爷爷去世，然后在第一阶段把奶奶写死。</li>
  <li>祐太争夺抚养权失败。但亲戚对小女孩很不好，只盯上她们父母的遗产，用一个家暴然后小女孩报警之类的导火索强迫剥夺亲戚抚养权。</li>
</ul>

我不知道日本有没有独身男性不能收养小女孩这个设定，如果有的话，那正好，我们让学姐和祐太假结婚，来明正言顺地收养她们。学姐有两个特质，一是喜欢祐太，二是不是正常人，思维比较开发发散（和我一样），她大概也不会拒绝这样的请求。<strong>这样一来小空和学姐的党争剧情不也就更有看头了吗？</strong>

如果说争夺抚养权是不现实的话，那么，后面的剧情可以说就有点魔幻了。首先，<strong>那么大的房子，不要了？遗产也不要了？</strong>。其次，<strong>作者根本没有正面描写祐太是如何获得足够的钱的，他没有一个严谨的计算。一直都是祐太在打工，可是打工能挣多少钱？能养活三个女儿吗？</strong>

打到这里，我实在是为这部作品感到惋惜。我当然不能说这是因为作者水平多么差，毕竟他可能只是想写一部温情脉脉的萌系作品。唉，怎么说呢？业界药丸？
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/04/25/parser2/">
                                    <p class="title is-2">让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树 <span class="tag is-white is-pulled-right"><small>April 25, 2020</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">词法分析器</a>
    <ul>
      <li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">为什么要有词法分析器</a></li>
      <li><a href="#%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">如何构建一个词法分析器</a></li>
    </ul>
  </li>
  <li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">语法分析器</a>
    <ul>
      <li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98">语法分析器的基本问题</a></li>
      <li><a href="#%e5%b8%82%e9%9d%a2%e4%b8%8a%e7%9a%84%e5%b8%b8%e8%a7%81parser">市面上的常见Parser</a></li>
      <li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8">递归向下解析器</a></li>
      <li><a href="#parser-combinator">Parser Combinator</a></li>
      <li><a href="#parser-generator">Parser Generator</a></li>
      <li><a href="#%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7%e8%a7%a3%e6%9e%90%e5%99%a8">算符优先级解析器</a></li>
    </ul>
  </li>
  <li><a href="#%e4%bb%8e%e8%a7%a3%e6%9e%90%e6%a0%91%e5%88%b0%e8%af%ad%e6%b3%95%e6%a0%91">从解析树到语法树</a>
    <ul>
      <li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8%e7%9a%84%e6%83%85%e5%86%b5">递归向下解析器的情况</a></li>
      <li><a href="#yacc%e7%9a%84%e6%83%85%e5%86%b5">Yacc的情况</a></li>
    </ul>
  </li>
  <li><a href="#%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98">需要注意的几个问题</a>
    <ul>
      <li><a href="#%e4%b8%8d%e8%a6%81%e7%bb%99parser%e5%a2%9e%e5%8a%a0%e5%a4%aa%e5%a4%9a%e8%b4%9f%e6%8b%85">不要给Parser增加太多负担</a></li>
      <li><a href="#%e6%9c%80%e5%a5%bd%e4%b8%8d%e8%a6%81%e5%ae%9e%e7%8e%b0parser">最好不要实现Parser</a></li>
    </ul>
  </li>
</ul>

<h2 id="词法分析器">词法分析器</h2>

词法分析器，是将输入的字符串解析为符号串的工具；语法分析器，即parser，是将符号串解析为解析树（并将解析树映射为语法树）的工具。

<h3 id="为什么要有词法分析器">为什么要有词法分析器</h3>

一般的编译器教科书，常常是先讲词法分析器，再讲语法分析器，顺带着讲讲生成文法。个人认为这是<strong>完全错误</strong>的。

我们必须要知道，我们这里提到的Parser解析的全部都是<strong>上下文无关文法</strong>（CFG），而词法分析器解析的是<strong>正则文法</strong>，我们还知道，<strong>所有的正则文法都是上下文无关文法</strong>，那么这就得出一个结论，因为Parser也可以解析正则文法，所以词法分析起是完全不需要的。

为了解释为什么需要词法分析器，我们必须考察一下市面上常见的各种Parser。

Parser从大的方面上分，有三个属性：

<ul>
  <li>定向/非定向</li>
  <li>确定型/非确定型</li>
  <li>自底向上/自顶向下</li>
</ul>

其中非定向方法构建的Parser在程序语言中用的不多，这里不表。

如果你认真阅读过关于上一篇正则文法的文章，你会知道“确定型”和“非确定型”的区别在于“确定型”不需要搜索，时间复杂度是线性的；“非确定型”需要搜索，时间复杂度按你搜索的方法不同，从\(O(n^2)\)到\((O(e^n))\)都有可能。如果从这个角度出发，那么这个解析器最好是确定型的。

但凡事有得必有失，确定型的解析器有一个天然劣势–<strong>不存在可以解析任何CFG的确定型解析器</strong>。这就要求我们必须对文法进行限制，以满足特定的解析器。

这种限制有时候是很不舒服的。而正则文法则不同，<strong>只要你的文法是正则文法，不需任何限制即可获得一个确定型解析器</strong>。

所以我们需要正则文法，来将字符串变为符号串，提前解决一些Parser解析起来很麻烦的东西。

<h3 id="如何构建一个词法分析器">如何构建一个词法分析器</h3>

如果你使用的语言有正则表达式支持，那就直接使用正则表达式构建即可；如果没有（常用的语言也就C没有了吧），建议使用flex之类的工具。

这里我们需要注意几个问题：

<ul>
  <li>正则表达式最好写在一起，否则和搜索没有区别。</li>
  <li>如果你的正则表达式不支持捕获，那么是无法实现的。</li>
  <li>注意错误处理，生成好看的错误。</li>
</ul>

<h2 id="语法分析器">语法分析器</h2>

<h3 id="语法分析器的基本问题">语法分析器的基本问题</h3>

我个人分为三个问题：

<ul>
  <li>如何正确、快速地识别输入符号串</li>
  <li>如何构建的解析树</li>
  <li>如何把解析树映射成语法树</li>
</ul>

接下来的讨论，只讨论第一个问题。后面两个问题见下一节。

<h3 id="市面上的常见parser">市面上的常见Parser</h3>

现在市面上有很多Parser，大概分为五类：

<ul>
  <li>手写的递归向下解析器</li>
  <li>函数式编程语言里的Parser Combinator</li>
  <li>Parser Generator</li>
  <li>手写的算符优先级解析器</li>
  <li>一些使用特定算法的其他解析器</li>
</ul>

<h3 id="递归向下解析器">递归向下解析器</h3>

递归向下指的是一种编程方法。比如说你有这样的文法：

\[A \rightarrow aBc\]

\[B \rightarrow dB\]

那么，你写出这种函数：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VALUE</span> <span class="nf">handle_A</span><span class="p">(</span><span class="n">SYMBOL</span> <span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">a</span><span class="p">){</span>
    <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">SUCCESS</span><span class="p">(</span><span class="n">handle_B</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">pos</span><span class="p">))){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">){</span>
        <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
        <span class="c1">// 变成语法树返回回去</span>
      <span class="p">}</span>
      <span class="k">else</span><span class="p">{</span>
        <span class="c1">// error_handle</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="c1">// error_handle</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="c1">// error_handle</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">VALUE</span> <span class="nf">handle_B</span><span class="p">(</span><span class="n">SYMBOL</span> <span class="o">*</span> <span class="n">stream</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pos</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="n">stream</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="n">d</span><span class="p">){</span>
    <span class="n">pos</span><span class="o">++</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">SUCCESS</span><span class="p">(</span><span class="n">handle_B</span><span class="p">(</span><span class="n">stream</span><span class="p">,</span> <span class="n">pos</span><span class="p">))){</span>
      <span class="c1">// 变成语法树返回回去</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
      <span class="c1">// error_handle</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">else</span><span class="p">{</span>
    <span class="c1">// error_handle</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

从外形上说，这就是把每一个非终结符写成一个函数，然后在这个函数里处理这个非终结符的内容，并返回成功或失败。

从本质上说，这是一个自顶向下解析器。它是一个下推自动机，具有一个栈，以如下方式运行：

<ul>
  <li>初始化：将初始符号压入栈中（调用handle_S）</li>
  <li>从栈顶弹出一个符号
    <ul>
      <li>如果是终结符就与当前字符串的第一个符号进行比较，如果成功则继续，失败返回错误</li>
      <li>如果是非终结符就将这个非终结符的右手侧压入栈中（调用handle_X）</li>
    </ul>
  </li>
</ul>

这个时候，读者应该隐隐约约地感到到了一些问题。

第一个问题是，一个非终结符可以生成不同的符号串，比如说：

\[A \rightarrow aBc \tag{0}\]

\[A \rightarrow cDf \tag{1}\]

如果现在的栈顶符号是\(A\)，你如何判断压入哪个符号串呢？

这就有了递归向下Parser内部的两个实质Parser：

<ul>
  <li>回退解析器。如果遇到这种问题，我们使用搜索广度优先或深度优先搜索算法，将两种路径都尝试一下，如果失败就回退。（非确定型）</li>
  <li>LL(k)解析器。我们保证文法是LL(k)的，这样一来就可以根据当前输入符号串的前\(k\)个符号判断采取哪条路径。（确定型）</li>
</ul>

第二个问题是，如果我们遇到的是左递归文法：

\[A \Rightarrow Aa\]

这个规则会使得自动机不停地弹出A和压入A，是一个死循环。所以从本质上来说，执行最左推导的下推自动机极其实现，永远不可能处理原始的左递归文法。

而有时候我们又必须要求左递归，比如四则运算的减号。

有人可能会说，有一个算法可以把左递归强行化成右递归。确实是有，但是如果你把该算法作用于减号上，你会发现，强行化成右递归会导致语义不正确。这个问题是每一个使用递归向下的人不得不解决的。

<h3 id="parser-combinator">Parser Combinator</h3>

我们知道，所有的生成文法其实都可以写成连接的形式（当然，必须允许重复定义，或者允许选择符号）。而上面的递归向下解析器其实是在用代码定义这些东西：

<ul>
  <li>终结符–是否匹配的if判断语句</li>
  <li>非终结符–是否匹配的if判断函数</li>
  <li>连接–顺序执行</li>
  <li>选择–判断进入哪条路径的if判断语句</li>
</ul>

很多人会敏锐的认识到，这些东西都可以进行抽象。把代码的运行逻辑留下，作为一个高阶函数；把具体的代码封装成函数作为其参数。而这恰恰就是函数式编程的思想。

如此一来，我们就获得了一个新的工具–Parser Combinator.

我这里举<a href="https://www.quanttec.com/fparsec/">FParsec</a>作为例子，看看它是如何构建解析器的：

FParsec把输入流进行封装。其中最重要的概念就是“position”，即当前要处理的符号串位置。<strong>这里需要特别注意，FParsec只支持将字符串作为输入，无法使用词法分析器，这是其美中不足之处。</strong>

FParsec将解析器定义为一个函数，原型如下：

<pre><code class="language-f#">  type Parser&lt;'Result, 'UserState&gt; = CharStream&lt;'UserState&gt; -&gt; Reply&lt;'Result&gt;
</code></pre>

这里的UserState是我们自己定义的State，一般设为unit（即空类型，没有内容）即可，暂时不去管他；这里的’Result是一个泛型类型，用户可以自己定义结果。

这个函数的意义是，一个输入为CharStream型，输出为Reply的函数。

FParsec提供了一些用来从字符构建非终结符的函数，比如说:

<pre><code class="language-f#">  let internal charReturnE (c: char) result error : Parser&lt;'a,'u&gt; =
    fun stream -&gt;
        if stream.Skip(c) then Reply(result)
        else Reply(Error, error)
</code></pre>

我们使用

<pre><code class="language-f#">  let a =  charReturnE "a" "a"
</code></pre>

即是定义了非终结符a，对应的字符也是”a”。

FParsec提供了一系列用于连接符号的函数。

<pre><code class="language-f#">  let (.&gt;&gt;) (p: Parser&lt;'a,'u&gt;) (q: Parser&lt;'b,'u&gt;) =
    fun stream -&gt;
        let mutable reply1 = p stream
        if reply1.Status = Ok then
            let stateTag1 = stream.StateTag
            let reply2 = q stream
            let error = if isNull reply1.Error then reply2.Error
                        elif stateTag1 &lt;&gt; stream.StateTag then reply2.Error
                        else mergeErrors reply2.Error reply1.Error
            reply1.Error  &lt;- error
            reply1.Status &lt;- reply2.Status
        reply1
</code></pre>

这个符号是将两个非终结符连接起来，形成一个新的非终结符的函数。
  比如说：

<pre><code class="language-f#">  let A = charReturnE "a" "a"
  let B = charReturnE "a" "a"
  let C = A .&gt;&gt; B
</code></pre>

实际上就是：

\[A \rightarrow a\]

\[B \rightarrow b\]

\[C \rightarrow AB\]

的实现。

FParsec本质上是一个回退解析器，但它的性能却相当不错。这是因为它对选择符号(&lt;|&gt;)的实现：

<pre><code class="language-f#">  let (&lt;|&gt;) (p1: Parser&lt;'a,'u&gt;) (p2: Parser&lt;'a,'u&gt;) : Parser&lt;'a,'u&gt; =
    fun stream -&gt;
        let mutable stateTag = stream.StateTag
        let mutable reply = p1 stream
        if reply.Status = Error &amp;&amp; stateTag = stream.StateTag then
            let error = reply.Error
            reply &lt;- p2 stream
            if stateTag = stream.StateTag then
                reply.Error &lt;- mergeErrors reply.Error error
        reply
</code></pre>

我们看到，如果第一个Parser失败，<strong>当且仅当在stateTag没有改变时</strong>，才会进行用第二个Parser进行解析。

这个stateTag，实际上就是position，也就是是当前解析到的位置。如此设计，保证了这个Parser<strong>仅仅会回退一个字符</strong>，因为如果第一个字符是匹配的，position就发生了变化。如此设计，使得它在某种意义上具有了\(LL(1)\)的特性。

当然，我们也可以使用attempt强行使它回退。

针对下推自动机无法识别左递归的问题，FParsec引入了一个算符优先级解析器，帮助我们识别(1 + 1 - 2)一类的式子。

个人认为FParsec是一个不错的东西。但是F#和Haskell一样，本身语言设计有诸多麻烦之处，实际开发体验并没有特别舒服。

<h3 id="parser-generator">Parser Generator</h3>

这个东西应该是最为正统的方式了。Parser Generator可以做到由文法直接生成代码，我们不太需要关系内部是如何实现的。这个东西的集大成者是yacc，我们没什么好说的。

<h3 id="算符优先级解析器">算符优先级解析器</h3>

我们并不陌生，大名鼎鼎的调度场算法即是这类解析器的一种，这里也不耗费笔墨了。

<h2 id="从解析树到语法树">从解析树到语法树</h2>

解析树，顾名思义，就是解析器生成的树。这里有两个问题：

<ul>
  <li>逻辑上的解析树是唯一的，也就是生成文法生成句子的那棵生成树。</li>
  <li>一个可以正确识别出输出符号串的解析器，一定是正确地构建出解析树了的，但是这颗解析树是逻辑上的，而非实现上的。实现上的解析树是什么样的，需要一一讨论。</li>
</ul>

语法树则不同，语法树和解析树的关系是若即若离的：

<ul>
  <li>语法树的节点并不是解析器自动生成的，而是人为设计的。</li>
  <li>即使没有Parser，我们也可以直接根据想法（<strong>而不是根据生成文法</strong>），构建出语法树。</li>
  <li>一般来说，我们的Parser会在解析的同时，将解析时映射为语法树。</li>
</ul>

我们考察两个有代表性的解析器–递归向下解析器与Yacc生成的解析器–是如何构建出解析树，并将其映射为语法树的。

<h3 id="递归向下解析器的情况">递归向下解析器的情况</h3>

以如下文法为例：

\[S \rightarrow A\]

\[A \rightarrow M\]

\[A \rightarrow M + A\]

\[M \rightarrow D * M\]

\[M \rightarrow D\]

\[D \rightarrow int | (A)\]

这文法定义了一个支持加乘两种运算的式子。

我们用C#实现一下；

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">namespace</span> <span class="nn">RecursiveDesentParser</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">Parser</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">Target</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">pointer</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">private</span> <span class="n">Node</span> <span class="n">head</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">(</span><span class="s">"S"</span><span class="p">);</span>
        <span class="k">public</span> <span class="nf">Parser</span><span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Target</span> <span class="p">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">Parse</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">success</span> <span class="p">=</span> <span class="p">(</span><span class="n">head</span> <span class="p">=</span> <span class="nf">ParseA</span><span class="p">())</span> <span class="p">!=</span> <span class="k">null</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">ParseEpsilon</span><span class="p">()</span> <span class="p">&amp;&amp;</span> <span class="n">success</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">private</span> <span class="n">Node</span> <span class="nf">ParseA</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Node</span> <span class="n">now</span> <span class="p">=</span> <span class="nf">ParseM</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nf">ParseChar</span><span class="p">(</span><span class="sc">'+'</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;</span> <span class="n">nodes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;();</span>
                    <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
                    <span class="kt">var</span> <span class="n">tail</span> <span class="p">=</span> <span class="nf">ParseA</span><span class="p">();</span>
                    <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">(</span><span class="s">"+"</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="n">now</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">private</span> <span class="n">Node</span> <span class="nf">ParseM</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Node</span> <span class="n">now</span> <span class="p">=</span> <span class="nf">ParseD</span><span class="p">();</span>
            <span class="k">if</span><span class="p">(</span><span class="n">now</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nf">ParseChar</span><span class="p">(</span><span class="sc">'*'</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;</span> <span class="n">nodes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;();</span>
                    <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
                    <span class="kt">var</span> <span class="n">tail</span> <span class="p">=</span> <span class="nf">ParseM</span><span class="p">();</span>
                    <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">(</span><span class="s">"*"</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="n">now</span><span class="p">;</span> <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// 以下代码略</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

现在来解析这样的式子:

\[1 + 2 * 3\]

为了更好地展示解析的过程，我们需要把整个解析的所有调用都画出来：

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ParseA
  ParseM
    ParseD : 1
  ParseChar : +
  ParseA
    ParseM
      ParseD : 2
      ParseChar : <span class="k">*</span>
      ParseM
        ParseD : 3
</code></pre></div></div>

我们发现：<strong>调用函数的过程，自然地形成了一颗解析树！</strong>，这也正是递归向下解析器的一大特性。

调用函数的过程本身就是解析树，将解析树映射为语法树的做法就呼之欲出了：将返回值作为语法树的节点，在每个函数内部实现解析树到语法树的节点的映射：

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">Node</span> <span class="nf">ParseA</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Node</span> <span class="n">now</span> <span class="p">=</span> <span class="nf">ParseM</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">now</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nf">ParseChar</span><span class="p">(</span><span class="sc">'+'</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;</span> <span class="n">nodes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">Node</span><span class="p">&gt;();</span>
            <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">tail</span> <span class="p">=</span> <span class="nf">ParseA</span><span class="p">();</span>
            <span class="n">nodes</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">tail</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="nf">Node</span><span class="p">(</span><span class="s">"+"</span><span class="p">,</span> <span class="n">nodes</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="n">now</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span> <span class="k">return</span> <span class="k">null</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

在这个函数里，我们把自然形成的这个解析树：

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A
  M
  +
  A
</code></pre></div></div>

映射成了这样的语法树：

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+
  M
  A
</code></pre></div></div>

<h3 id="yacc的情况">Yacc的情况</h3>

yacc是一个LALR(1)文法的Parser Generator. 它产生的分析器是一个自底向上的确定型分析器。

自底向上的意思是，它对应一个这样的自动机：

（在下面的示意中, .表示在.之前的位置已经被分析完了）

这个自动机的输入是一个字符串，它开始的状态是当然是:

\[.a_{0}a_{1}a_{2}a_{3}\]

这个自动机还具有一个栈，在开始状态，栈中没有元素。

\[S\]

这个自动机有两种操作：

<ul>
  <li>读入一个字符，把字符放到栈里。</li>
  <li>把栈里的字符进行规约，化成别的符号。</li>
</ul>

它不断地进行这两个操作，直至栈中得到开始符号为止。

以下面的语法和输入字符为例：

\[S \Rightarrow A\]

\[A \rightarrow Aa | a\]

\[aaaa\]

首先，开始的状态是：

\[栈：\]

\[.aaaa\]

移进一个a：

\[栈：a\]

\[a.aaa\]

进行规约：

\[栈：A\]

\[a.aaa\]

再移入一个a：

\[栈：Aa\]

\[aa.aa\]

下面的操作就无需多言了。

这里我们会发现，自底向上的解析器的解析树，实际上体现在“规约”中，<strong>每一次的规约，实际上是以解析树的叶子节点替换解析树的根节点</strong>。

但这样一来，真正的解析树其实没有被留下，也就无法把解析树映射为语法树了。

为了解决这个问题，yacc引入了一个“内容栈”和“符号栈”的概念。

<ul>
  <li>内容栈：栈里是类型为YYSTYPE的值，它是保存结果用的栈。</li>
  <li>符号栈：我们刚才说得用来分析的栈。</li>
</ul>

这两个栈到底是怎么一回事呢？我们来看一个例子：

<pre><code class="language-yacc">
%{
#include &lt;stdio.h&gt;
 typedef struct node
 {
 struct node *left;
 struct node *right;
 char *token;
 } node;
 node *mknode(node *left, node *right, char *token);
 void printtree(node *tree);
#define YYSTYPE struct node *
%} 

exp : term {$$ = $1;}
 | exp PLUS term {$$ = mknode($1, $3, "+");}
 | exp MINUS term {$$ = mknode($1, $3, "-");} 
</code></pre>

不难看出，node是语法树的节点类型，而那句

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="cp">#define YYSTYPE struct node *
</span>
</code></pre></div></div>

就是将内容栈的元素类型定义为node*指针类型。

下面的那句

<pre><code class="language-yacc">
exp : term {$$ = $1;}
 | exp PLUS term {$$ = mknode($1, $3, "+");}
 | exp MINUS term {$$ = mknode($1, $3, "-");} 

</code></pre>

如果除去大括号，就是生成文法；而大括号里面的内容，则是对每条文法在<strong>内容栈</strong>上的操作，这个写法表示，在运用这条文法进行规约时，将内容栈上的对应元素拿出，并压入新构造的node*指针。

这样一来，我们又实现了从解析树映射到语法树的操作。

<h2 id="需要注意的几个问题">需要注意的几个问题</h2>

<h3 id="不要给parser增加太多负担">不要给Parser增加太多负担</h3>

有些人想要在解析阶段就识别出来这种语法错误：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">a</span><span class="p">();</span>
</code></pre></div></div>

如果真的想做，这需要CSG解析。而CSG解析并没有一个很好的算法，所以，应该放弃这种不切实际的想法，在后面的阶段再检查这种错误。

<h3 id="最好不要实现parser">最好不要实现Parser</h3>

通过上面的描述，可以看到Parser是一个苦大仇深的行业。如果你实现一个复杂的语法，它的Parser会非常复杂，这会耗尽你对程序语言的热情。所以，让我们一起来实现Lisp吧！
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/04/21/CLanguage/">
                                    <p class="title is-2">谈谈C语言的两个问题 <span class="tag is-white is-pulled-right"><small>April 21, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="正确理解函数名">正确理解函数名</h2>

只有正确理解函数名，才能正确使用函数指针。

函数指针是C语言里一个比较重要的特性。它实现了某种意义上的高阶函数，使得我们可以把函数作为参数和返回值。

我们知道，函数指针也就是一个变量，里面存储着指向的函数的地址。一个比较奇怪的问题是，以下两种写法在绝大多数编译器的眼里都是正确的：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)();</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(){}</span>

<span class="n">p</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span> <span class="c1">//写法1</span>
<span class="n">p</span> <span class="n">pointer</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">func</span><span class="p">;</span> <span class="c1">//写法2</span>
</code></pre></div></div>

有些人会这样解释：对一个函数取地址仍然得到函数本身。

用这个解释，我们可以解决&amp;&amp;func、&amp;&amp;&amp;func的问题，它们仍然会得到func本身。但我们很快就会觉得前一种写法本身与其他指针不太相容，比如说，你永远无法写出这样的代码：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
</code></pre></div></div>

这么想来，我们不得不怀疑<em>对一个函数取地址仍然得到函数本身</em>这个说法的合理性。其实，问题的关键在于函数名究竟被处理为了什么。

答案很简单，<strong>函数名被处理为一个地址字面量值</strong>。

无论你对此有何评价，Clang、MSVC、GCC都是这样实现的。基于此，我们应该理解

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">func</span><span class="p">;</span>
</code></pre></div></div>

的真正意思是，把func的地址赋给pointer。

所以，我们不能这样去写程序：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">//main.c</span>
<span class="k">typedef</span> <span class="nf">void</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)();</span>

<span class="k">extern</span> <span class="n">p</span> <span class="n">func</span><span class="p">;</span>

<span class="n">func2</span><span class="p">(</span><span class="n">p</span> <span class="n">func</span><span class="p">){</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">func2</span><span class="p">(</span><span class="n">func</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//func.c</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(){</span>
  <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

如果这么写，你会惊喜地发现func2函数传入的是func函数编译后的二进制代码的前四位。这是因为编译器认为main.c中的func是一个变量，而对其取地址。但实际上func是一个字面量，本身就是要取的地址中的值了。

你可能会问了，这种不正确的写法为什么还可以正常编译链接呢？

这就要问问链接器了。

<h2 id="正确理解链接过程">正确理解链接过程</h2>

链接器是石器时代的产物。由于C实际上是被编译为汇编后，再生成目标文件，最后被链接，实际上链接器是给汇编语言用的。

而这就带来了一大问题：链接的接口，即符号表（记录所有符号）与重定向表（记录要被重定向的符号），是没有C语言的类型信息的。

也就是说，每当你使用extern关键字声明外部引用时，<strong>你实际上是放弃了对该引用的静态类型检查</strong>。

而C++则不会有这个问题。你可以将上面的代码改成C++文件名或用C++编译器编译，会发现链接器错误。因为C++有名称修饰，它会将符号做处理，实际上附加了类型信息。但是，<strong>名称修饰不蕴含在C++的标准中，各家编译器厂商有自己的实现</strong>，所谓的<em>C++ ABI不兼容</em>，这个问题也占了一席之地。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/04/03/net_class/">
                                    <p class="title is-2">也谈我校在疫情期间不开设网课的诸问题 <span class="tag is-white is-pulled-right"><small>April 03, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="从一篇文章谈起">从一篇文章谈起</h2>

我校，即中山大学，在2020年2月8日–应该开学而没有开学的日子–起，至今没有组织<strong>全校性的</strong>、<strong>算学分的</strong>网课。几乎两个月过去了，我过着田园牧歌式的生活。每天读读书、看看动画、搞搞逆向，尽力做好吃的饭，写优雅的代码，颇有几分“采菊东篱下，悠然见南山”的乐趣。

不过，我们必须承认，这种景象是暗流涌动、危机四伏的。有一位同学就看到了这种危机，奋笔疾书、笔力千钧地写出了一篇文章，痛斥我校教务部不作为，<strong>不过不知道为什么，他已经自己删除了这篇文章</strong>。

<img src="https://pic.downk.cc/item/5e86e16a504f4bcb04a6f014.jpg" alt="0" />

我对这个文章所反映的问题的评价，正如截图上说的那样：

<img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa5991.jpg" alt="1" />

<img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa5998.jpg" alt="2" />

<img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa599d.jpg" alt="3" />

如果具体一点的话，我们引用一下中央巡视组对<strong>山东大学</strong>的反馈意见就好，出处见<a href="http://news.cctv.com/2017/06/17/ARTIFy0sSrjM7cQrHCDGUAP5170617.shtml">此处</a>

<blockquote>
  学习贯彻中央决策部署在一些方面存在表面化、形式化、走过场问题；发展理念和办学方针存在一些偏差，偏于注重外延扩张，内涵提升不够；<strong>以学生为本、为学生服务意识不够到位</strong>。
</blockquote>

<h2 id="随便谈谈">随便谈谈</h2>

那篇文章，用四个字概括，就是<strong>吊民伐罪</strong>。但，谈吊民，在大多数时候是没有意义的；谈伐罪，我觉得如果学生们可以决定中大的人事任免的话，恐怕很多干部要被免职，而现实中他们还都在悠游地履职，所以也是没有意义的。

吊民伐罪，最多是情绪的宣泄，而不能解决问题。

我认为，中大在两个月的表现，是部分失职的。

为什么说部分失职呢？

搞健康情况申报、湖北同学补助，虽然有点流于形式，但总地来看，中大在学生疫情防控上，是合格的。<strong>在健康申报这件事上，某些同学反而是不合格的。</strong>

我们也知道，用这两个月混乱的网课情况当答卷，是难以及格的。

不过，如果把这次事件比作一场游戏的话，游戏最多只进行到了中间的阶段，此时就妄下断语，也是不科学的。

我把所有情绪化的东西剔除掉，得到中大需要给这两个月的不作为擦屁股的内容如下：

<ul>
  <li>如何解决暑假已然耗尽的窘迫局面？</li>
  <li>如何和其他开设网课的高校接轨？包括但不限于保研考研、暑期夏令营之类的问题。</li>
  <li>现在的情况是，某些学院开设了网课，那么这些学院的网课是否算学分？</li>
  <li>如何在有些学院开设了网课，有些学院没有开设网课的情况下，编排出一个统一的校历？</li>
  <li>……</li>
</ul>

我觉得，如果中大能够交出一份令人满意的答卷，总体上来看教务人员还是尽职的。

不要忘了《三国演义》里庞统的故事：

<blockquote>
  张飞领了言语，与孙乾同至耒阳县。军民官吏，皆出郭迎接，独不见县令。飞问曰：“县令何在？”同僚覆曰：“庞县令自到任及今，将百馀日，县中之事，并不理问，每日饮酒，自旦及夜，只在醉乡。今日宿酒未醒，犹卧不起。”
</blockquote>

<blockquote>
  张飞大怒，欲擒之。孙乾曰：“庞士元乃高明之人，未可轻忽。且到县问之。如果于理不当，治罪未晚。”飞乃入县，正厅上坐定，教县令来见。统衣冠不整，扶醉而出。飞怒曰：“吾兄以汝为人，令作县宰，汝焉敢尽废县事？”统笑曰：“将军以吾废了县中何事？”飞曰：“汝到任百馀日，终日在醉乡，安得不废政事？”统曰：“量百里小县，些许公事，何难决断？将军少坐，待我发落。”随即唤公吏，将百馀日所积公务，都取来剖断，吏皆纷然赍抱案卷，上厅诉词。被告人等，环跪阶下。统手中批判，口中发落，耳内听词，曲直分明，并无分毫差错，民皆叩首拜伏。不到半日，将百馀日之事，尽断毕了，投笔于地，而对张飞曰：“所废之事何在？曹操，孙权，吾视之若掌上观文，量此小县，何足介意！”
</blockquote>

在发表意见之前，我要提醒一下，这件事在《三国志》里的版本，是这样的：

<blockquote>
  先主领荆州，统以从事守耒阳令，在县不治，免官。
</blockquote>

庞统那样的凤凰，“在县不治”尚且要免官，如果某些人“在校不治”，那么应该做些什么呢？

<a href="http://www.xinhuanet.com/politics/2020-01/31/c_1125515085.htm">新华社有篇社论</a>，我引用一些在这里：

<blockquote>
  各级党委要在这场严峻斗争的实践中考察识别干部，激励引导广大党员、干部在危难时刻挺身而出、英勇奋斗、扎实工作，经受住考验。
</blockquote>

<blockquote>
  考察识别干部，功夫要下在平时，并注意重大关头、关键时刻。
</blockquote>

<blockquote>
  对表现突出的，要表扬表彰、大胆使用；对不敢担当、作风飘浮、落实不力的，甚至弄虚作假、失职渎职的，要严肃问责。
</blockquote>

如果中大教务人员真的不能交出一份让教职工和学生都满意的答卷，最好的方法也不是在公众号里宣泄情绪，而是要反馈一下某些人在疫情期间，履职不力的事实：

<img src="https://pic.downk.cc/item/5e86edab504f4bcb04b15e5a.jpg" alt="4" />
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/03/27/what-to-watch-1/">
                                    <p class="title is-2">看点什么（一） <span class="tag is-white is-pulled-right"><small>March 27, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="看点什么是什么">看点什么是什么</h2>

这个博客的专业气息太浓厚了，看到这个博客的人，可能以为我生活中全都是计算机，实际上的图景和此大相径庭。王垠的博客有他喷《星际穿越》的一篇博文和不少人 生 感 悟（到 处 乱 喷），我的博客里也应该有一些富有生活情趣的东西。这栏目就用来安利（和批评）各种文艺作品吧。

<h2 id="看点什么呢">看点什么呢？</h2>

有个成语叫“虎头蛇尾”。这当然不是什么褒义词，但是，如果头都不是“虎”的话，那么尾恐怕也只能是“蛇”了。在第一期里，我当然要把我最喜欢的作品拿出来展示。这一期，应该叫“看点我最喜欢看的”

<h3 id="小说篇">小说篇</h3>

熟悉我的人，可能在看到标题之后就知道要我在这个版块说什么（可惜这两年这种人已经几近绝迹）。没错，就是那本书，那本我很喜欢的书，那本在我瞟了一眼第二章的第一句话以后就一下子击穿了我的书–《玩笑》。但这本书不宜多说，多说几句话就是严重的恶劣的剧透行为。个人认为这是米兰昆德拉最好的作品。之后的作品也不能说不好，但个人色彩特别浓厚。有些人喜欢他的那种风格，有些人不喜欢，我可能是后者吧。

<h3 id="动画篇">动画篇</h3>

自从高三考完化学竞赛的那几天开始看动画以来，看过的作品也有一定数目了。这一期我写的是“我最喜欢看的”，而不是我认为最优秀的。所以《星际牛仔》这一类的动画就不写了。当然，如果你没有看过《星际牛仔》，那最好还是看看，这动画的优秀程度，是超过我将要谈到的这几部动画的。

<h4 id="机动警察系列">《机动警察》系列</h4>

<img src="https://akcp.kanfanba.com/wp-content/uploads/2019/11/%E6%9C%BA%E5%8A%A8%E8%AD%A6%E5%AF%9F-%E4%B8%9C%E4%BA%AC%E6%AF%81%E7%81%AD%E6%88%98.jpg" alt="patlabor" />

一个让人喜欢看的动画，其先决条件是“有趣”。《机动警察》在这方面做得很出彩。它首先是很有趣的，大多数人看到所谓的“真实系机战番”，往往下意识地联系到《机动战士高达》、《宇宙战舰大和号》一类的太空歌剧。“史诗感”、“沉重”、“黑深残”之类的词是它们的注脚。《机动警察》告诉了我们，机战可以是另一种机战，真实可以是另一种真实。它就像一碗精心烹制的清汤面，少盐少油，味道是平淡甚至平庸的。但，它筋道爽快的口感和星星点点整整齐齐的葱花都在提醒着你，这碗面，没这么简单。

另外，不要看了两集就说是子供向就弃了好不？这应该是“合家欢向”，剧场版2以及OVA完全是成人向，也就第一集和第二集稍显幼稚一些。

<h4 id="物语系列">《物语系列》</h4>

<img src="https://pic.downk.cc/item/5e7f4ec8504f4bcb04885881.jpg" alt="monogatari" />

如果说《机动警察》是清汤面的话，这个系列动画，绝对是麻辣小龙虾和四川火锅一类的东西。这十部动画的魅力不需要我说什么，任何一个第一次看《化物语》的人都会见识到她独一无二的风格和感觉。唯一需要提醒的是，这部动画有一定的卖肉倾向，其血腥程度也是不遑多让。如果不太能接受这些元素，那就最好不要看了，因为这两种颜色的东西贯穿整个系列始终，有些时候还对剧情发展起着关键性的作用。

<h4 id="新世纪福音战士">《新世纪福音战士》</h4>

<img src="https://cdn.vox-cdn.com/thumbor/SYiIF-623aJEsMLH5ceEnGWWQXw=/0x0:1280x1205/1200x800/filters:focal(514x213:718x417)/cdn.vox-cdn.com/uploads/chorus_image/image/64060202/tumblr_nzss2qZIyT1suxi1yo1_1280.0.jpg" alt="eva" />

我的头像和网名的出处（ayanami是绫波嘛），必须推荐一下。看这部动画没必要带着什么观看神作的心情，放松地、享受地去看就好，前13集是很好看的，在各种意义上都是。当然，如果你也想对剧中的各种意象进行解释，成为EVA学家的话，也没有什么不好。

<h4 id="全部成为f">《全部成为F》</h4>

<img src="https://pic.downk.cc/item/5e7f507e504f4bcb0489ef81.jpg" alt="ffff" />

这部动画，我推荐程序员去看。非程序员当然也可以看，但可能没法经历那种特别的感受。另外，看完之后不要忘了看看我的复现：<a href="https://ayanamists.github.io/index.php/2019/07/25/ffff/">编写程序验证《全部成为F》中的的巧妙trick</a>

<h3 id="漫画篇">漫画篇</h3>

这个模块我们略去热度特别高和名气特别大的漫画，比如《进击的巨人》、《约定的梦幻岛》等等，也略去年代特别久远的漫画，比如《火之鸟》等等。

<h4 id="魔偶马戏团">《魔偶马戏团》</h4>

<img src="https://pic.downk.cc/item/5e7f5042504f4bcb0489be61.jpg" alt="魔偶" />

这部作品，我在一篇博客中提到过：<a href="https://ayanamists.github.io/index.php/2019/07/17/maxituan/">魔偶马戏团：不幸的动画与伟大的原作</a>。此处，我想把藤田和日郎老师在《潮与虎》封面上写的一句话复读过来，可能会对理解他的作品起很大帮助：

<blockquote>
  我从小就不喜欢我老爸老妈总是在我睡前念的《卖火柴的小女孩》这个故事。我不知道为什么那么可怜的女孩要有那么可怜的遭遇，但我也只能空虚地挥拳捶打书里面的插画。于是我就想出可以代替我的拳头的家伙。而潮与虎–它们正是这样的家伙。
</blockquote>

《魔偶马戏团》虽然在日本可能是热点相当高的漫画，但在中国的热度不算很高，有必要在此处拿出来介绍一下。

<h4 id="赌博默示录系列">《赌博默示录》系列</h4>

<img src="https://pic.downk.cc/item/5e7f50c3504f4bcb048a28bb.jpg" alt="赌博" />

如果人的心理有形状的话，那么，绝望长什么样？希望长什么样？贪欲长什么样？虐待欲长什么样？死而复生生而复死之后的绝望，又长什么样呢？这部漫画用它极为粗犷（烂 得 要 命）的画工给这个问题交了一张非常优秀的答卷。

<h4 id="化物语">《化物语》</h4>

为什么上面已经提到了《物语系列》的动画，还要再说一下《化物语》漫画呢？答案是，这部漫画的画面相当不错。

<img src="https://pic.downk.cc/item/5e7f45ee504f4bcb047fc2ba.jpg" alt="化物语" />

自行感受吧。

<h4 id="青色火焰">《青色火焰》</h4>

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn%3AANd9GcTUPc8YqcQv3kWSkQU9bNhoSu7q-DeHNyY08aYoa06PggTvyFEM" alt="青色火焰" />

从小到大，我们常常会被问到这样一个问题“你的梦想是什么？”。“我的梦想，是……”

咳咳，太羞耻了说不出来。

这个的主人公（即作者小号），在上世纪80年代的第一年就笃定了自己对于这个问题的回答：“我要成为漫画家！”

这部漫画，就是他追梦之路的全景式记录。

我用一句话来概括一下漫画所展示的这条道路吧：

<strong>追求梦想的道路，是一条布满荆棘的道路。为了达到光辉的顶点，你必须舍弃一些东西……一些很重要的东西。</strong>

<h3 id="电影篇">电影篇</h3>

<h4 id="美国丽人">《美国丽人》</h4>

<img src="https://pic.downk.cc/item/5e7f5203504f4bcb048b3dba.jpg" alt="美国丽人" />

说起“一个中年大叔和女高中生的故事”，我们总会想到《恋如雨止》，最近还有《女儿的朋友》。但这两部漫画的高度，恐怕是难以企及《美国丽人》的。

第一次看这部电影的时候，我尚处对某些东西很好奇的年龄，当时观看这部影片，我完全是出于猎奇和看女主福利镜头的动机。

现在想来，那时候的我还真是好笑呢。这部影片真正的东西，根本不在“性”上，而在（此处不剧透）上。

由于这部影片的表达手法并不晦涩，我不能对其主旨说得太多，但这部影片真的不是靠着“中年大叔和JK的不伦之恋”的噱头卖肉的，<strong>如果你要观看这部影片，请认真观看</strong>

<h4 id="罪人">《罪人》</h4>

就一句话吧：小成本的大制作。

<h4 id="楚门的世界">《楚门的世界》</h4>

无需多言的神作。不过私以为这部作品，并不只是反乌托邦这个主题而已。

“反乌托邦”是被动的，我们要反对一个监狱式的、高度集权的、被人深度控制的社会。

但如何反对呢？用什么去反对呢？或者说，我们应该用什么样的态度（这种态度能够最大程度地使社会不变成那样的社会）去生活呢？这主人公就很好地回答了这个问题嘛。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/03/27/reg/">
                                    <p class="title is-2">让我们实现编程语言吧（三）正则文法与实现正则表达式解析引擎 <span class="tag is-white is-pulled-right"><small>March 27, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="什么是正则文法">什么是正则文法</h2>

正则文法是比较靠谱的文法。它在CFG的基础上继续进行限制：

每一个正则文法的规则只能是以下两个规则之一：

<ul>
  <li>形如\(A \rightarrow a\)的规则。</li>
  <li>形如\(A \rightarrow aB\)的规则。</li>
</ul>

可以看到这文法是很简单的，过于简单会引起不好用，所以我们也有“增强版”的正则文法，它多了一条规则：

<ul>
  <li>如果\(A, B, C...\)是正则文法左端的符号，那么\(X = ABC...\)也是正则文法。</li>
</ul>

这个“增强”实际上是允许正则文法进行连接，我们在后面会看到，它和原来的正则文法是完全等价的。

<h2 id="正则文法对应的自动机">正则文法对应的自动机</h2>

自动机的使用是比较广泛的，我们在数字电路和网络协议中都看到过它的身影。在这里，我们使用的是“有限状态自动机”，它简单地说就是一张表或者一幅有向图，这张表或者这幅图记录着状态如何变化（以及什么是起始状态，什么是终止状态等等）。那么，它和正则文法是怎么联系起来的呢？

先不讨论“增强”型的正则文法，只讨论一般的正则文法。一个非常关键的想法是：<strong>把非终结符当作一种“状态”</strong>

这样抽象地说可能有点难以理解，我们来说一个具体的文法：

\[S \rightarrow aA\]

\[A \rightarrow bB\]

\[B \rightarrow cC\]

\[C \rightarrow d\]

很容易可以看出来，这定义的是\(abcd\)这个字符串。

我们可以构想，有这样的一台机器，它输入一个字符串，输出一个布尔值，也就是说，如果这个字符串是“abcd”，那就输出真，否则输出假。

使用“把非终结符当作一种状态”的思想，可以让我们制造出来这种机器。

这机器的开始状态是\(S\)，然后读入一个字符，如果为”a”，就进入\(A\)状态，在\(A\)状态，也读入一个字符，如果为”b”，就进入\(B\)状态，直至在\(C\)状态读入”d”后进入成功状态。

用图片来表示，就是这样：

<img src="https://pic.downk.cc/item/5e7e12a4504f4bcb0492dd16.png" alt="1" />

（由于是自动生成的，符号可能不太一样）

如果没能执行刚才的操作，这机器就进入“失败”状态。这就解决了我们的判断问题。

你可能会问，这究竟有什么用呢？不就是匹配个字符串吗，需要这么麻烦？

我们经常研究一个问题“如何组合简单的东西来完成复杂的任务”。一个经久不衰的答案是“封闭性”。而正则文法和自动机恰恰是封闭的。

什么意思呢？如果你把一个非终结符和其对应的自动机看作一种“运算单元”，你就会发现，一个或多个“运算单元”可以通过以下的运算生成另一个更复杂的运算单元：

<ol>
  <li>\(A = aB\) 将一个终结符和一个非终结符连接，会生成一个可以匹配更长语言的非终结符</li>
  <li>\(A = BC\) 把两个终结符连接起来，会生成一个匹配更长语言的非终结符</li>
  <li>\(A = B \| C\) 将一个终结符和一个终结符用 “|” 连接， 可以生成一个匹配它们两个所对应的语言的终结符</li>
</ol>

另外的几个操作暂时不引入了，我们需要思考的是，刚才我们说<strong>把非终结符当作一种“状态</strong>，而这里，我们实际上做的是<strong>把非终结符当作一个状态机</strong>。

通过非终结符之间的运算，状态机可以进行组合，以形成更复杂的状态机。这样一来，我们就可以用这种结构构造相当复杂的匹配方法。

<h2 id="把正则文法改写为非确定型自动机">把正则文法改写为非确定型自动机</h2>

我们前面已经说了，我们实际上是<strong>把非终结符当作一个状态机</strong>，所以，我们只要研究各种文法组合如何改写成状态机的组合就好。

首先来看最简单的

\[A = aB\]

\(B\) 是一个状态机，那么\(A\)就应该是一个新的状态机，它的开始状态由a变成B的开始状态，类似于这样：

由

<img src="https://pic.downk.cc/item/5e7e9fc0504f4bcb04f889d0.png" alt="2" />

变为

<img src="https://pic.downk.cc/item/5e7ea014504f4bcb04f8bf3e.png" alt="3" />

注意我画的状态机的尾部指向的是\(\epsilon\)，而不是成功状态\(&lt;&gt;\)，这是为什么呢？

因为在状态机没有构造好的时候，状态机的尾部相当于是“游离”的，我们有两种情况：

<ul>
  <li>要么在最后的构造中，将尾部指向\(&lt;&gt;\)状态</li>
  <li>要么在某一次构造中，将尾部指向其他状态</li>
</ul>

然后我们来看看两个非终结符之间的连接：

\[A = BC\]

这应该如何处理呢？答案很简单，就是将\(B\)状态机的尾部，指向\(C\)状态机的开始状态，然后把新状态机的尾部设置为\(C\)状态机的尾部就好。

例如，\(B\)状态机还是上次的B状态机，而\(C\)状态机为：

<img src="https://pic.downk.cc/item/5e7ea222504f4bcb04fa18ea.png" alt="4" />

那么，\(A\)状态机就会是：

<img src="https://pic.downk.cc/item/5e7ea27b504f4bcb04fa564d.png" alt="5" />

其他的操作符也大抵类似，不过要注意的是我们这里保证<strong>每一次操作产生的自动机开始状态都有且仅有一个</strong>

<h2 id="把nfa改写成dfa">把NFA改写成DFA</h2>

NFA最大的特点是允许“不确定性”，也就是说，对于一个给定的状态转移因子（比如说”a”），有可能有两种不同的状态转移方法。

例如下图：

<img src="https://pic.downk.cc/item/5e7eabbb504f4bcb040036dd.png" alt="6" />

第“6”号状态如果遇到了“a”，那么它有两种可能，一种是转移到自己本身，另一种是转移到第”7”号状态。

有编程经验的人立刻会想到，如果要解决这个问题，恐怕需要使用一些图的搜索技术，比如深度优先搜索–先转移到自己，如果后面的转移失败就转移到第”7”号状态。

而这样的方法，效率是不佳的。有没有一种方法，可以使得我们不是“搜索”，而是线性地“匹配”呢？

这就是把NFA改写为DFA的原始动力。

至于如何改写呢？我懒得写了，请自行查询相关资料吧。

<h2 id="实现一个正则表达式引擎">实现一个正则表达式引擎</h2>

有了上面的思考，我们就可以来实现一个正则表达式解析引擎了。具体的实现，见<a href="https://github.com/ayanamists/MyRegEngine">此处</a>

<h3 id="第一步-解析正则表达式">第一步 解析正则表达式</h3>

必须指出，正则表达式本身不是正则语法。因为<strong>正则语法不可能匹配一个可以无穷地嵌套括号的语言</strong>，而正则表达式允许括号的无穷嵌套。

所以，要解析正则表达式，必须利用解析CFG的一些办法。

不过，一个比较好的消息是，可以利用解析数学表达式的算法–调度场算法解析正则表达式。

解析的结果并不是一颗树，而是对应树的后序遍历结果–后缀正则表达式

<h3 id="第二步-由正则表达式生成nfa">第二步 由正则表达式生成NFA</h3>

我们使用了自左向右扫描后缀正则表达式的办法来生成NFA。

具体的做法和求一个数学表达式没有太大区别，就是如果是一个字符，就压栈，如果是一个运算符，就弹出对应的元素，运算后放入栈里。

不过这里有一个问题，那就是栈里放些什么呢？

仔细思考一下会发现，栈里有两种元素

<ul>
  <li>一个字符</li>
  <li>一个自动机</li>
</ul>

我们这样来表示栈里的元素

<div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">internal</span> <span class="k">class</span> <span class="nc">BeginState</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">internalState</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="nf">BeginState</span><span class="p">()</span> <span class="p">{</span> <span class="n">internalState</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="nf">BeginState</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">internalState</span> <span class="p">=</span> <span class="n">state</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

  <span class="k">internal</span> <span class="k">class</span> <span class="nc">EndState</span><span class="p">{...}</span>

  <span class="k">internal</span> <span class="k">class</span> <span class="nc">StateInStack</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">BeginState</span> <span class="n">Begin</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="n">EndState</span> <span class="n">End</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">PointEndTo</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="k">in</span> <span class="n">Nfa</span><span class="p">&lt;</span><span class="n">CharWithEmpty</span><span class="p">&gt;</span> <span class="n">nfa</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">PointEndToWithout</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">nfa</span><span class="p">);</span>
            <span class="n">End</span><span class="p">.</span><span class="n">internalList</span><span class="p">.</span><span class="nf">Clear</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">PointEndToWithout</span><span class="p">(</span><span class="kt">int</span> <span class="n">state</span><span class="p">,</span> <span class="k">in</span> <span class="n">Nfa</span><span class="p">&lt;</span><span class="n">CharWithEmpty</span><span class="p">&gt;</span> <span class="n">nfa</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="p">(</span><span class="n">estate</span><span class="p">,</span> <span class="n">how</span><span class="p">)</span> <span class="k">in</span> <span class="n">End</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">nfa</span><span class="p">.</span><span class="nf">SetStateTransition</span><span class="p">(</span><span class="n">estate</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
  <span class="k">internal</span> <span class="k">class</span> <span class="nc">StackElement</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">StateInStack</span> <span class="n">State</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="k">public</span> <span class="n">CharWithEmpty</span> <span class="n">symbol</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="k">public</span> <span class="nf">StackElement</span><span class="p">(</span><span class="k">in</span> <span class="n">BeginState</span> <span class="n">begin</span><span class="p">,</span> <span class="k">in</span> <span class="n">EndState</span> <span class="n">end</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">State</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StateInStack</span><span class="p">();</span>
            <span class="n">State</span><span class="p">.</span><span class="n">Begin</span> <span class="p">=</span> <span class="n">begin</span><span class="p">;</span>
            <span class="n">State</span><span class="p">.</span><span class="n">End</span> <span class="p">=</span> <span class="n">end</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="nf">StackElement</span><span class="p">(</span><span class="kt">char</span> <span class="n">sym</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">symbol</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CharWithEmpty</span><span class="p">(</span> <span class="n">sym</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">public</span> <span class="nf">StackElement</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">State</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StateInStack</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

这样一来就可以优雅地实践刚才所描述的组合算法了。

<h3 id="第三步-由nfa生成dfa">第三步 由NFA生成DFA</h3>

这里我们使用广度优先搜索的方法，从BeginState开始，搜索出它的\(\epsilon\)闭包，然后分析可能的状态转移。对每一个可能的状态转移都求其\(\epsilon\)闭包，之后将它压入队列中，直至队列为空。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/03/27/grammar/">
                                    <p class="title is-2">让我们实现编程语言吧（二）生成文法 <span class="tag is-white is-pulled-right"><small>March 27, 2020</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%94%9f%e6%88%90%e6%96%87%e6%b3%95">什么是生成文法</a></li>
  <li><a href="#%e7%94%9f%e6%88%90%e6%96%87%e6%b3%95%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9">生成文法的注意事项</a>
    <ul>
      <li><a href="#%e7%94%9f%e6%88%90%e6%96%87%e6%b3%95%e7%a9%b6%e7%ab%9f%e4%bb%a3%e8%a1%a8%e4%bb%80%e4%b9%88">生成文法究竟代表什么</a></li>
      <li><a href="#%e7%94%9f%e6%88%90%e5%9b%be">生成图</a></li>
      <li><a href="#parse%e7%9a%84%e7%9c%9f%e6%ad%a3%e6%84%8f%e4%b9%89">Parse的真正意义</a></li>
    </ul>
  </li>
  <li><a href="#%e5%9b%9b%e7%a7%8d%e7%94%9f%e6%88%90%e6%96%87%e6%b3%95">四种生成文法</a>
    <ul>
      <li><a href="#type-0">Type 0</a></li>
      <li><a href="#type-1-context-sensitive-grammar">Type 1 Context-Sensitive Grammar</a></li>
      <li><a href="#type-2-context-free-grammar">Type 2 Context Free Grammar</a>
        <ul>
          <li><a href="#uvwxy%e5%ae%9a%e7%90%86">uvwxy定理</a>
            <ul>
              <li><a href="#uvwxy%e5%ae%9a%e7%90%86%e7%9a%84%e8%af%81%e6%98%8e%e5%92%8c%e6%84%8f%e4%b9%89">uvwxy定理的证明和意义</a></li>
              <li><a href="#%e8%af%81%e6%98%8eanbncn%e4%b8%8d%e8%83%bd%e8%a2%abcfg%e7%94%9f%e6%88%90">证明\(a^{n}b^{n}c^{n}\)不能被CFG生成</a></li>
              <li><a href="#python%e4%b8%8d%e6%98%afcfg">Python不是CFG</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#type-3-regular-grammar">Type 3 Regular Grammar</a></li>
      <li><a href="#type-4">Type 4</a></li>
    </ul>
  </li>
  <li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
</ul>

<h2 id="什么是生成文法">什么是生成文法</h2>

在谈生成文法之前，我们首先要解释一下什么叫做“文法”(grammar)。

<blockquote>
  语法（英语：Grammar），也称文法，在语言学中指任意自然语言中句子、短语以及词等语法单位的语法结构与语法意义的规律
</blockquote>

可见，文法这东西本身的意义是很宽泛的，我们这里研究的是“生成语法”，也就是说，用来产生语言的文法。

这里的“语言”，指的是由所有合法的句子组成的集合。

考虑这样的语言：

\[\{a\}\]

我们如何生成它呢？

答案很简单：

\[S\rightarrow a\]

可以看到，生成文法是类似于\(\lambda\)演算的替换规则。这些替换规则有两种元素：

<ul>
  <li>Terminal</li>
  <li>Non-Terminal</li>
</ul>

其中Terminal，也就是所谓的“终结符”是<strong>不能被继续替换的符号</strong>，Non-Termianl是<strong>可以被继续替换的符号</strong>

用生成文法生成句子，其实就是不断地替换非终结符，直至句子中全部为终结符，就产生了一个句子。

我们再看一个例子：形如\(a^{n}b^{n}\)的语言，也就是有相同数量的a和b的语言：

\[\{\epsilon, ab, aabb, aaabbb, ... \}\]

它可以被以下文法生成：

\[S \rightarrow A\]

\[A \rightarrow aAb\]

\[A \rightarrow ab\]

比如我们要生成\(aabb\)，就进行以下替换就可以：

\[S \rightarrow A\]

\[A \rightarrow aAb\]

\[aAb \rightarrow aabb\]

<h2 id="生成文法的注意事项">生成文法的注意事项</h2>

<h3 id="生成文法究竟代表什么">生成文法究竟代表什么</h3>

生成文法代表了一个语言，也就是一个<strong>集合</strong>，它由所有合法（可被生成语法生成的）的句子组成。

<h3 id="生成图">生成图</h3>

很容易看出来，生成句子的过程是一个有向图。如果我们把刚才的生成过程画出来的话，会是这样的：

<img src="https://pic.downk.cc/item/5e7d6dec504f4bcb041ce470.png" alt="1" />

实际上，这是一棵树。但，为什么还是用“图”来称呼它呢？下面会讨论这个问题。

<h3 id="parse的真正意义">Parse的真正意义</h3>

Parse的过程，就是由给定的句子还原生成图的过程，比如说，给定了aabb，我们要还原出来上面的图。

<h2 id="四种生成文法">四种生成文法</h2>

<h3 id="type-0">Type 0</h3>

这种文法没有任何限制，最为自由，所以也最没用。

<h3 id="type-1-context-sensitive-grammar">Type 1 Context-Sensitive Grammar</h3>

我们对Type 0语法加以一些限制，就得到了Type1型语法–上下文有关语法（CSG）。加上什么限制呢？

在Type 0类语法中，有一些规则我们特别不喜欢：

\[aBc \rightarrow a\]

这种规则是反直觉的，因为如果我们输入了\(a\)，会重建出一颗比\(a\)元素更多的生成图，这在一般情况下都是没有道理的。

所以，我们作以下限制：

<ul>
  <li>所有的规则必须满足<em>箭头左侧的符号数小于等于右侧的符号数</em></li>
</ul>

这也叫做“单调性”。有了这个性质，我们就保证了生成的过程是符号数不减的，Parse的过程是符号数不增的。

但这也有一个副作用：空规则被禁止了。

所谓的空规则，也即是类似于

\[A \rightarrow \epsilon\]

的规则，这明显是不满足“单调性”的，所以它被禁止了。实际上，如果不禁止空规则，单调性的引入是没有意义的：

\[aBc \rightarrow AaC\]

\[A \rightarrow \epsilon\]

\[C \rightarrow \epsilon\]

但我们一般允许语言本身是空的，也即是\(S \rightarrow \epsilon\)

一个比较好的消息是，如果文法中的空规则只有

\[A \rightarrow \epsilon\]

而不存在

\[\alpha A \beta \rightarrow \epsilon\]

那么这是可以被消除成没有空规则的形式的。只要消除以后仍然是单调的，这文法也应该被视作CSG，因为<strong>文法最终定义的是集合</strong>

上下文有关语法还有另外一种定义，这里就不介绍了。

我们来看这样的一个例子：

具有连续相同数目abc的字符串，也就是说: \(a^{n}b^{n}c^{n}\)

\[{abc, aabbcc, aaabbbccc ...}\]

如何用CSG生成它呢？

这规则是不太好理解和写出的：

\[S \rightarrow abc | aSQ\]

\[bQc \rightarrow bbcc\]

\[cQ \rightarrow Qc\]

这也就是CSG不太好用的地方–人类难以理解这种语法，所以很难构造它。

<h3 id="type-2-context-free-grammar">Type 2 Context Free Grammar</h3>

我们喜欢树。树的各种性质都很美妙，对树的操作天生比对图的操作舒服。

那么，可以把Parse图变为Parse树吗？答案是可以。

生成的过程为什么是图？我们看看用上面的语法生成\(aabbcc\)的过程：

<img src="https://pic.downk.cc/item/5e7d790f504f4bcb04234274.jpg" alt="2" />

可以看到，有两个点的入边和出边都有好几条，如果把它变成无向图会产生回路，所以是图而非树。

这两个点的产生是因为语法规则

\[bQc \rightarrow bbcc\]

\[cQ \rightarrow Qc\]

左边的符号是复数个。只要我们令左边的符号只能有一个，生成图就会变成生成树！

这也就是CFG的限制：

<ul>
  <li>箭头左边有且只有一个非终结符。</li>
</ul>

<h4 id="uvwxy定理">uvwxy定理</h4>

这个限制对语言的表现力有什么影响吗，或者说，CFG相比于CSG，在表现力上有什么区别吗？请再次回想我们一直强调的一点：<strong>文法最终定义的是集合</strong>

要看有没有影响，就要比较CSG和CFG所<strong>能</strong>生成的集合的区别。

再来看看\(a^{n}b^{n}c^{n}\)这个集合，我们可以用以下CFG生成它的超集：

\[S \rightarrow A\]

\[A \rightarrow aAc\]

\[A \rightarrow bA\]

\[A \rightarrow b\]

这个文法生成的是形如\(a^{n}b^{m}c^{n}\)的句子，这\(a^{b}b^{n}c^{n}\)构成的集合当然是这些句子构成的集合的子集。

但是，我们能不能找到一个文法，其对应的集合是\(a^{n}b^{n}c^{n}\)所构成的集合呢？

<strong>uvwxy</strong>定理告诉我们，这是不可能的。

<h5 id="uvwxy定理的证明和意义">uvwxy定理的证明和意义</h5>

故事要从生成树或者Parse树的构造讲起。

我们将每个规则标号，再将每个规则右侧的符号标号，就像下面这样：

\[S \rightarrow A^{0} \tag{0}\]

\[A \rightarrow a^{0}A^{1}b^{2}  \tag{1}\]

\[A \rightarrow a^{0}b^{1}  \tag{2}\]

研究生成树，我们会发现<strong>句子中的每个终结符，都存在一条由终结符起，经历一些非终结符至根的路径</strong>，而<strong>这条路径，可以被一个二元组的列表定义</strong>

如何构造该二元组列表呢？我们可以把生成树中除根以外的每个符号都打上标记，标记的内容是\(\{规则编号，位置编号\}\)，这样一来每个非终结符就唯一地对应一个标记，而把标记串联起来，就得到了这个列表。

例如，对\(aabb\)这个句子，我们可以作以下标记：

<img src="https://pic.downk.cc/item/5e7dea04504f4bcb047702c0.png" alt="3" />

这样一来，最左侧的a，它的列表为：

\[\{1, 0\}, \{0, 0\}\]

第二个a的列表为：

\[\{2, 0\}, \{1, 1\}, \{0, 0\}\]

我们立刻可以发现一个问题：

<ul>
  <li>显然地，给定一个合法列表，有且仅有一个终结符与之对应</li>
</ul>

这个时候我们立刻会思考一个问题：列表中的二元组，其数量显然是有限的。

什么意思呢？就是说，对一个给定的语法来说，不同二元组的数量就是

\[C = \sum{Symbols_{rule}}\]

那么，如果这个列表的长度大于\(C\)，这个列表就一定会有两个相同的元素！

如果长度有最大值，那么所有列表组成的集合的大小实际上也有最大值。

又由于一个列表要么是非法的，要么只有一个终结符与之对应，这样的集合所对应的句子，长度也是有限的。

换言之，只要长度超过了这个上限\(n\)，那一个列表中就必然有两个相同的二元组。而如果一个终结符的列表中有两个相同的二元组，那就说明一个问题：<strong>有同一个规则被运用了两次</strong>。

我们用图片展示一下，就是这样：

<img src="https://pic.downk.cc/item/5e7deee7504f4bcb047a6de5.jpg" alt="4" />

所以，一个足够长的句子必然可以被分解为\(uvwxy\)五个部分，且\(v\)和\(x\)不同时为空。为什么不能同时为空呢？我们可以继续使用反证法，由于列表集是离散的且有上界\(n\)，必然可以找到句子长度的真正上界\(n_{real}\)。假设一个句子的长度超过了\(n_{real}\)，且可以被分解为\(uwy\)。这也就是说必然存在一个单元规则\(A \rightarrow A\)，而单元规则是可以被消除的，即，移除对应的生成树节点，该生成树仍然是合法的。我们移除这个节点以后，就有两种情况：

<ul>
  <li>这个句子还可以用别的方式被分解为\(uvwxy\)</li>
  <li>这个句子没有重复的规则。</li>
</ul>

第二种情况和长度超过\(n_{real}\)矛盾，所以不存在“一个长度超过\(n_{real}\)，可以被分解为\(uwy\)而不能被分解为\(uvwxy\)的句子”。为了下面证明的方便，这里直接规定\(x\)和\(y\)不同时为空。

这个时候，如果把第二个A代换成第一个A会怎么样呢？这个代换显然也是成立的，因为这个上下文<strong>无关</strong>文法：

<img src="https://pic.downk.cc/item/5e7df0fc504f4bcb047c54f3.jpg" alt="5" />

我们发现，这句子是\(uvvwxxy\)，或者\(uv^{2}wx^{2}y\)。

也就是说，如果\(uvwxy\)是一个合法的句子，那么，\(uv^{2}wx^{2}y\)也一定是个合法的句子！

<h5 id="证明anbncn不能被cfg生成">证明\(a^{n}b^{n}c^{n}\)不能被CFG生成</h5>

用这个性质，我们立刻可以证明\(a^{n}b^{n}c^{n}\)不能被CFG所生成：

考虑一个句子\(a^{k}b^{k}c^{k}\)：

<ul>
  <li>如果\(v\)或\(x\)中含有\(b\)，那么，\(v\)中就不得含有\(a\)或\(x\)中就不得含有\(c\)，因为这会使得\(v^{2}\)或\(x^{2}\)中出现\(a...b...a\)或\(b...c...b\)的序列，而这显然不是\(a^{n}b^{n}c^{n}\)型的句子。所以\(u\)只能为\(a^{k}\)或\(y\)只能为\(c^{k}\)，而原本\(v, w, x\)中的\(b\)数量之和为\(k\)，\(v^{2}, w, x^{2}\)中\(b\)的数量必然大于\(k\)，所以这会使得\(uv^{2}wx^{2}y\)也不是\(a^{n}b^{n}c^{n}\)型的句子。所以这种情况不成立。</li>
  <li>如果\(v\)和\(x\)中均不含\(b\)，那么，\(b^{k}\)一定被分解到了\(w\)中。由于\(x\)和\(v\)非空，必然存在一部分\(a\)被分解到\(x\)中，一部分\(b\)被分解到\(y\)中。同上，这会使得\(uv^{2}wx^{2}y\)中含有的\(a, b, c\)数不相等。故也不成立。</li>
</ul>

所以，\(a^{n}b^{n}c^{n}\)不能被CFG生成。

<h5 id="python不是cfg">Python不是CFG</h5>

可以证明，一切类似于Python那样的<strong>用多层缩进表示块</strong>的语法，都不能用CFG生成。

<h3 id="type-3-regular-grammar">Type 3 Regular Grammar</h3>

正则文法，就是“正则表达式”的那个文法，我们在下期讨论。

<h3 id="type-4">Type 4</h3>

这类型没什么用，不做讨论。

<h2 id="总结">总结</h2>

四种语法中，比较有用的是CFG和正则文法。下一篇文章我们将重点讨论正则文法。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/03/14/parser/">
                                    <p class="title is-2">让我们实现编程语言吧（一）序 <span class="tag is-white is-pulled-right"><small>March 14, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="为什么要实现编程语言">为什么要实现编程语言</h2>

<ul>
  <li>好玩</li>
  <li>深入理解程序的执行过程</li>
  <li>为以后的逆向工程研究打下一些基础</li>
</ul>

<h2 id="实现什么编程语言">实现什么编程语言</h2>

这里我们实现了类似于ruby的编程语言。它具有以下特性：

<ul>
  <li>纯面向对象，即所有的字面量与值都是对象</li>
  <li>值驱动，任何表达式都具有值，且其值是一个对象</li>
  <li>支持块</li>
  <li>大部分操作都可以归结为调用某个类的成员方法/类方法</li>
</ul>

相比于ruby，我们做出的主要调整有：

<ul>
  <li>只支持部分ruby语法</li>
  <li>彻底推翻了ruby的单件类设计，个人认为单件类是ruby设计中问题最大的一部分</li>
  <li>继承结构简单，所有对象都默认继承object类</li>
</ul>

<h2 id="如何实现编程语言">如何实现编程语言</h2>

简单来说有三步：

<ul>
  <li>实现前端：将输入的字符串变为一棵树（AST）</li>
  <li>实现内部数据结构</li>
  <li>实现eval函数</li>
</ul>

今天（2020年3月14日）我们已经完成了第一个阶段的任务

<h2 id="第一步parser">第一步：Parser</h2>

<h3 id="谈谈parser">谈谈Parser</h3>

Parser是“语法解析器”的意思。一般来说它输入一串Token流，解析出一颗Ast。其实也不一定就是这样，比如说我们实现的产品就没有用词法解析器，直接通过源代码产AST。

如何做到这件事呢？这是有点麻烦的。由于我没有学过编译原理，对LR、LALR的parser generator不太了解，这里只说一说递归下降解析器的原理和我们使用的Parser Generator库。

在此之前，我们先要说一说所谓的“文法”，而这，就留给下面的文章吧。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/02/16/white_album-2/">
                                    <p class="title is-2">WA2的逆向与外挂（二） 实现鼠标自动化操作 <span class="tag is-white is-pulled-right"><small>February 16, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="实现自动操作的几个想法">实现自动操作的几个想法</h2>

实现自动操作，大概有几个方法：

<ul>
  <li>直接调用某些WA2的函数，强行推进</li>
  <li>使用鼠标自动化方法，模拟人的行为</li>
</ul>

这里，我们选择了第二个方案。因为在一番逆向过后，我并没有完全理解WA2剧情推进的机制，只能等日后逆向能力更强后再实践。

<h2 id="windows平台下鼠标自动化的方法">Windows平台下鼠标自动化的方法</h2>

据我所知，要实现UI的自动化，大概有几个方法：

<ul>
  <li>使用win32 api，直接根据windows的消息机制进行注入。</li>
  <li>使用vbs脚本</li>
  <li>使用微软官方的<a href="https://docs.microsoft.com/zh-cn/windows/win32/winauto/uiauto-uiautomationoverview">UI Automation</a>库</li>
  <li>使用python的某些库</li>
  <li>使用自己写的驱动，实现硬件级别模拟</li>
  <li>…</li>
</ul>

这里，我们选择了第一种使用WIN API的方法，原因有两个：

<ul>
  <li>相对比较简单直接，不需要进行内核编程，开发效率高</li>
  <li>能力相对较强，能够处理绝大多数场景</li>
</ul>

<h2 id="初次尝试的折戟沉沙">初次尝试的折戟沉沙</h2>

我们知道，Windows的应用程序基于的是消息机制。什么是消息机制呢？MSDN上有一段令我印象深刻的解说：

<blockquote>
  Unlike MS-DOS-based applications, Windows-based applications are event-driven. They do not make explicit function calls (such as C run-time library calls) to obtain input. Instead, they wait for the system to pass input to them.
</blockquote>

每个Windows App的<strong>GUI线程</strong>都有一个<strong>消息队列</strong>，至于<strong>GUI线程</strong>是什么，我没有再MSDN上查到明确说法，个人认为是调用了<strong>CreateWindow</strong>的线程。

应用程序使用<strong>GetMessage</strong>函数从自己的消息队列中取出消息，使用<strong>DispatchMessage</strong>将消息传给对应的WindowProc，使用<strong>WaitMessage</strong>函数等待外部传入消息。

外部向应用程序发送消息，有两个办法：

<ol>
  <li>
    使用PostMessage()函数，将一个消息压入某个窗口对应线程的消息队列中。

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">BOOL</span> <span class="nf">PostMessageA</span><span class="p">(</span>
 <span class="n">HWND</span>   <span class="n">hWnd</span><span class="p">,</span>
 <span class="n">UINT</span>   <span class="n">Msg</span><span class="p">,</span>
 <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span>
 <span class="n">LPARAM</span> <span class="n">lParam</span>
 <span class="p">);</span>
</code></pre></div>    </div>
  </li>
  <li>
    使用SendMessage()函数，直接调用某个窗口的WindowProc。

    <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">LRESULT</span> <span class="nf">SendMessage</span><span class="p">(</span>
 <span class="n">HWND</span>   <span class="n">hWnd</span><span class="p">,</span>
 <span class="n">UINT</span>   <span class="n">Msg</span><span class="p">,</span>
 <span class="n">WPARAM</span> <span class="n">wParam</span><span class="p">,</span>
 <span class="n">LPARAM</span> <span class="n">lParam</span>
 <span class="p">);</span>
</code></pre></div>    </div>
  </li>
</ol>

我们一向是实践第一，马上在写代码的时候发现了盲点：如何得到那个<strong>HWND</strong>类型的窗口句柄呢？这就要救助于FindWindow()函数了：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HWND</span> <span class="nf">FindWindowA</span><span class="p">(</span>
  <span class="n">LPCSTR</span> <span class="n">lpClassName</span><span class="p">,</span>
  <span class="n">LPCSTR</span> <span class="n">lpWindowName</span>
<span class="p">);</span>
</code></pre></div></div>

就差一点点了！可是又如何得到主窗口的ClassName和WindowName呢？

这里介绍一个工具，就是大名鼎鼎的spy++.

我们可以在vs2019的工具里直接使用它：

<img src="https://pic.downk.cc/item/5e49095348b86553eed809e1.png" alt="1" />

通过这个工具，我们就可以得到WA2主窗口的ClassName和WindowName了：

<img src="https://pic.downk.cc/item/5e490a0748b86553eed82f5f.png" alt="2" />

<img src="https://pic.downk.cc/item/5e490a0748b86553eed82f61.png" alt="3" />

使用Spy++工具，我们还可以得知这个窗口所有的消息，进而得知鼠标点击的坐标：

<img src="https://pic.downk.cc/item/5e490b2348b86553eed86a17.png" alt="4" />

注：这里的坐标是窗口坐标，也就是相对于这个窗口左上角的坐标。

那么，我们只要向这个窗口发送LBUTTONDOWN和LBUTTONUP消息，不就可以模拟鼠标的行为了吗？

写出以下代码：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">PostMessage</span><span class="p">(</span><span class="n">main_window</span><span class="p">,</span> <span class="n">WM_LBUTTONDOWN</span><span class="p">,</span> <span class="n">wparam</span><span class="p">,</span> <span class="n">lparam</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">OnCriticalError</span><span class="p">(</span><span class="s">"Post Down fail"</span><span class="p">);</span>
	<span class="p">};</span>
	<span class="n">Sleep</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
	
	<span class="n">wparam</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lparam</span> <span class="o">=</span> <span class="n">MAKELPARAM</span><span class="p">(</span><span class="mi">600</span><span class="p">,</span> <span class="mi">376</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">PostMessage</span><span class="p">(</span><span class="n">main_window</span><span class="p">,</span> <span class="n">WM_LBUTTONUP</span><span class="p">,</span> <span class="n">wparam</span><span class="p">,</span> <span class="n">lparam</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
		<span class="n">OnCriticalError</span><span class="p">(</span><span class="s">"Post Up fail"</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

实验发现，完全没啥用。第一回合，我败下阵来。

<h2 id="分析原因重整旗鼓">分析原因，重整旗鼓</h2>

为什么刚才的尝试失败了呢？我想，这个问题只能向逆向工程里要答案了。

我们研究一下White AlbumCN这个窗口类的WindowProcess。它处理WM_LBUTTONDOWN或者WM_LBUTTONUP消息的代码在哪里呢？

<img src="https://pic.downk.cc/item/5e4925c948b86553eede746f.png" alt="6" />

呵呵！原来如此！这个函数直接Return 0，根本不处理这个消息！

我感到很迷惑，既然如此，它是如何接收输入的呢？

我们先来看看主消息循环：

<img src="https://pic.downk.cc/item/5e4926ba48b86553eedeae70.png" alt="7" />

注意被我标红的一条执行路径。被我命名为maybe_handle_click的函数，是这样的：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="c1">// line 37</span>
  <span class="n">GetCursorPos</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Point</span><span class="p">);</span>
  <span class="n">ScreenToClient</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Point</span><span class="p">);</span>

<span class="c1">//line 105 - 129</span>
    <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">byte_B601DF</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">v21</span> <span class="o">=</span> <span class="n">GetAsyncKeyState</span><span class="p">;</span>
      <span class="n">if_leftButtonPress</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">if_rightButtonPress</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">LABEL_47:</span>
      <span class="n">byte_B601AB</span> <span class="o">=</span> <span class="p">(</span><span class="n">v21</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">LABEL_48</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">if_leftButtonPress</span> <span class="p">)</span>
    <span class="p">{</span>
      <span class="n">v22</span> <span class="o">=</span> <span class="n">GetAsyncKeyState</span><span class="p">;</span>
      <span class="n">if_leftButtonPress</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">if_rightButtonPress</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">byte_B601AB</span> <span class="p">)</span>
      <span class="p">{</span>
        <span class="n">v21</span> <span class="o">=</span> <span class="n">GetAsyncKeyState</span><span class="p">;</span>
        <span class="n">if_leftButtonPress</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">if_leftButtonPress</span> <span class="p">)</span>
        <span class="p">{</span>
          <span class="n">if_rightButtonPress</span> <span class="o">=</span> <span class="p">(</span><span class="n">GetAsyncKeyState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x8001</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span> <span class="o">!</span><span class="n">if_rightButtonPress</span> <span class="p">)</span>
            <span class="k">goto</span> <span class="n">LABEL_47</span><span class="p">;</span>
</code></pre></div></div>

这个函数里反复调用了一个叫做GetAsyncKeyState的函数，查MSDN，描述如下：

<blockquote>
  Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.
</blockquote>

当这个函数的参数为1时，检测的就是鼠标左键。网上的资料还说，这个函数相当底层，基本是检测硬件的。

几乎可以确定，这个函数就是检测输入的。

那么，我们手里还有什么函数，可以在底层注入鼠标消息呢？

有，就是SendInput()，函数原型如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UINT</span> <span class="nf">SendInput</span><span class="p">(</span>
  <span class="n">UINT</span>    <span class="n">cInputs</span><span class="p">,</span>
  <span class="n">LPINPUT</span> <span class="n">pInputs</span><span class="p">,</span>
  <span class="kt">int</span>     <span class="n">cbSize</span>
<span class="p">);</span>
</code></pre></div></div>

这个函数也工作在底层，相当于直接用键盘/鼠标进行操作。

<h2 id="再次尝试再次失败">再次尝试，再次失败</h2>

我们写出以下代码：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">if</span> <span class="p">(</span><span class="n">IsIconic</span><span class="p">(</span><span class="n">main_window</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">ShowWindow</span><span class="p">(</span><span class="n">main_window</span><span class="p">,</span> <span class="n">SW_RESTORE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SetForegroundWindow</span><span class="p">(</span><span class="n">main_window</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">OnCriticalError</span><span class="p">(</span><span class="s">"Set window fail"</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Inject</span><span class="o">::</span><span class="n">EnablePrivilege</span><span class="p">())</span> <span class="p">{</span>
		<span class="n">OnCriticalError</span><span class="p">(</span><span class="s">"Privilege promt fail"</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BeginEvent</span><span class="o">::</span><span class="n">SendBeginEvent</span><span class="p">(</span><span class="n">main_window</span><span class="p">);</span>
</code></pre></div></div>

其中SendBeginEvent()函数定义如下：
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">BeginEvent</span> <span class="p">{</span>
	<span class="k">const</span> <span class="n">DWORD</span> <span class="n">beginX</span> <span class="o">=</span> <span class="mi">600</span><span class="p">;</span>
	<span class="k">const</span> <span class="n">DWORD</span> <span class="n">beginY</span> <span class="o">=</span> <span class="mi">376</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">SendBeginEvent</span><span class="p">(</span><span class="n">HWND</span> <span class="n">main_window</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">InputInjecter</span><span class="o">::</span><span class="n">SendMouseEvent</span><span class="p">(</span><span class="n">main_window</span><span class="p">,</span> <span class="n">beginX</span><span class="p">,</span> <span class="n">beginY</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">namespace</span> <span class="n">InputInjecter</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">SendMouseEvent</span><span class="p">(</span><span class="n">HWND</span> <span class="n">main_window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">POINT</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
		<span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>

		<span class="n">ClientToScreen</span><span class="p">(</span><span class="n">main_window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
		<span class="n">SetCursorPos</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

		<span class="n">LPMOUSEINPUT</span> <span class="n">input</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MOUSEINPUT</span><span class="p">;</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">MOUSEEVENTF_ABSOLUTE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_MOVE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_LEFTDOWN</span> <span class="o">|</span> <span class="n">MOUSEEVENT_LEFTUP</span><span class="p">;</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">dx</span> <span class="o">=</span> <span class="n">Helper</span><span class="o">::</span><span class="n">CalculateAbsoluteCoordinateX</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">dy</span> <span class="o">=</span> <span class="n">Helper</span><span class="o">::</span><span class="n">CalculateAbsoluteCoordinateY</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">mouseData</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">dwExtraInfo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">input</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">INPUT</span> <span class="n">input_seal</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="n">input_seal</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">type</span> <span class="o">=</span> <span class="n">INPUT_MOUSE</span><span class="p">;</span>
		<span class="n">input_seal</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mi</span> <span class="o">=</span> <span class="o">*</span><span class="n">input</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SendInput</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">input_seal</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">INPUT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">OnCriticalError</span><span class="p">(</span><span class="s">"Send Down fail"</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">Sleep</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

结果很诡异，用spy++可以看到消息是正确的，但桌面上的WA2就是纹丝不动。

为啥又失败了？我百思不得其解。

<h2 id="猜测和成功">猜测和成功</h2>

我们观察到了两个现象：

<ul>
  <li>那个may_be_handle_click函数有很多反复横跳的地方，检测变量更是变来变去，强行分析似乎很麻烦。</li>
  <li>玩游戏的实际体验是，按下左键就会触发，而不是抬起时才触发。</li>
</ul>

我们猜想，是不是只注入DOWN的消息，不注入UP的消息，我们就会成功呢？

修改代码如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input</span><span class="o">-&gt;</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">MOUSEEVENTF_ABSOLUTE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_MOVE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_LEFTDOWN</span> <span class="o">|</span> <span class="n">MOUSEEVENT_LEFTUP</span><span class="p">;</span>
</code></pre></div></div>

修改为：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input</span><span class="o">-&gt;</span><span class="n">dwFlags</span> <span class="o">=</span> <span class="n">MOUSEEVENTF_ABSOLUTE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_MOVE</span> <span class="o">|</span> <span class="n">MOUSEEVENTF_LEFTDOWN</span><span class="p">;</span>
</code></pre></div></div>

结果成功。现在想到这件事，我的脸上仍然会浮现开心的笑容。这就是逆向的魅力所在吧！

现在，我们获得了自动化的“手”，下面，我们要获得自动化的“眼睛”。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/02/16/white_album-1/">
                                    <p class="title is-2">WA2的逆向与外挂（一） 序 <span class="tag is-white is-pulled-right"><small>February 16, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="wa2简介">WA2简介</h2>

WA2，也就是White Album2，是日本leaf公司推出的美少女文字冒险游戏。其感情真实细腻，剧情丝丝入扣，是GALGAME业界天花板级别的作品。

我们这里分析的WA2是国内汉化组汉化过的版本，其所有PE文件罗列如下：

<ul>
  <li>可执行文件
    <ul>
      <li>WA2.exe，似乎是原本的可执行文件
        <ul>
          <li>大小：1,220,608 字节</li>
          <li>SHA1：DBF3BF1688159CC287ACA81BEE10C41DB0CAE74D</li>
        </ul>
      </li>
      <li>WA2_chs.exe，似乎是汉化版的运行文件
        <ul>
          <li>大小：1,220,096 字节</li>
          <li>SHA1：58FEDD7A10BF4EDB41E44FF1FCC365087AA6E880</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>动态链接库
    <ul>
      <li>未发现</li>
    </ul>
  </li>
</ul>

<h2 id="为什么要研究wa2">为什么要研究WA2</h2>

动机最初来源于网上的<a href="https://blog.csdn.net/applebananac123/article/details/59253642">一篇文章</a>：

在这篇文章中，作者通过别人总结的好感度上升流程图，结合编程模拟，认为在随便选择的情况下：

<blockquote>
  最后贴出结果：
雪菜TE概率：39.3%
雪菜NE概率：30.3%
冬马NE概率：30.4%
冬马TE概率：0.024%
</blockquote>

这个结果是准确的吗？我十分想搞清楚。

<h2 id="主要的研究目标与方法">主要的研究目标与方法</h2>

<ul>
  <li>通过实验来验证coda的各结局概率
    <ul>
      <li>自动化地进行游戏和记录结果 – 外挂技术</li>
      <li>通过逆向工程研究WA2的结局判断方法 – 逆向工程技术</li>
    </ul>
  </li>
  <li>解包，研究WA2文件夹里的资源文件 – 逆向工程技术</li>
</ul>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/network_speed/2020/02/15/speed-2/">
                                    <p class="title is-2">谈谈网速（二）不得不首先研究清楚的问题 <span class="tag is-white is-pulled-right"><small>February 15, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="信号传播的物理学理论">信号传播的物理学理论</h2>

就我个人来说，我的物理学得很不好，我也懒得处理很多物理上的内容，但是，要理解网速相关的众多内容，对物理中的波至少要有一点感性认识。

我们就说以太网好了。以太网不涉及什么调制的内容，在以太网上传播的就是数字信号，只不过经过了曼彻斯特编码（就是将源信号和时钟异或一下）

<img src="https://pic.downk.cc/item/5e48162d48b86553ee92ff32.png" alt="1" />

那么，这个信号的传播，究竟是一个什么过程呢？

电信号就是高低变化的电压，以太网的介质(media)就是导线（准确地说，同轴电缆、双绞线等）。那么这样看起来，这个信号的传播似乎是不需要时间的。

何出此言呢？我们考虑一下高中学过的物理或者大学物理课中关于电压的部分，导线的一端电压发生变化，另一端的电压是不是马上就作出与之相符的变化呢？

准确地来说，我个人以前所学过的物理知识，似乎没有处理过这类问题。但前人已经将这件事研究得很清楚了，这就是<a href="https://en.wikipedia.org/wiki/Transmission_line">传输线理论</a>。

<blockquote>
  In radio-frequency engineering, a transmission line is a specialized cable or other structure designed to conduct alternating current of radio frequency, that is, currents with a frequency high enough that their wave nature must be taken into account.
</blockquote>

这个理论是从麦克斯韦方程推导出来的，我们不需要了解其具体内容，只需要知道一个结论：在传输线上传输的信号，本质是一种电磁波，其波速是一个定值，且等于频率与波长的乘积。

<h2 id="transmission-delay-与-propagation-delay">Transmission Delay 与 Propagation Delay</h2>

稍微知道了一点物理学理论，我们就可以研究一下延迟中的<strong>发送时延（Transmission Delay）</strong>和<strong>传播时延（Propagation Delay）</strong>了。

一般在谈到网卡的作用时，网卡将操作系统的网络buffer中的网络包编码为串行的曼彻斯特码信号，然后发送出去。其实，这个过程的图景并不完全是这样。

网卡连接着传输介质，它做的事情主要就是在接口的INPUT部分“观测”电压，在接口的OUTPUT部分“改变”电压。所谓的“发送”，就是不断地改变OUTPUT口的电压，其改变的频率就是时钟频率，而这正是它发送的电磁波的频率。

电磁波的波速，在同一介质中是一定的。所以传播时延只和介质的种类和长度有关，而发送时延实际上与以太网的速率有关。

如果静下心来认真思考的话，我们不难想到，以太网的速率就是时钟频率的倒数。为什么呢？因为一个时钟发送一个bit。在802.3-1985这份最早的ieee以太网标准中，以太网的速率是10 Mbit/s，而标准也很清晰地说明了标准时钟频率应该为

\[100ns = 1 \times 10 ^ {-7}s = \frac{1}{10000000}\]

<img src="https://pic.downk.cc/item/5e489e5448b86553eebc3896.png" alt="2" />

所谓的发送时延，其实就是将网络包按照速率发送出去的时间。

这时可能会有一个问题，为什么要把总时延的计算里，为什么要把发送时延和传输时延加起来呢？我们可以这样去想：自第一个bit被一方发送至第一个bit被对方接收的时间(\(t_{1}\))，是<strong>传播时延</strong>；自一个bit被发送至最后一个bit被发送的时间(\(t_{2}\))，是<strong>发送时延</strong>，总时延应该包括自第一个bit被发送至最后一个bit被接收的时间(\(t_{3}\))，而显然有：

\[t_{3} = t_{1} + t_{2}\]

<h2 id="以太网的速率">以太网的速率</h2>

经过上面的讨论，我们可以知道，以太网的速率，应该是一个定值，与网卡的时钟频率成正比。但是这并不是绝对的。

<ul>
  <li>如果一个以太网是使用集线器或总线连接的共享网络，那么它有CMSA/CD机制避免冲突，实际上的速率是标注值除以共享网络的人数。</li>
  <li>如果一个以太网不是共享的（比如用交换机连接），那么它的速率和标注值一致。</li>
</ul>

现在的以太网基本都不是共享的，所以，可以认为现在使用的以太网速率都是确定的、是由时钟频率决定的，我们其实并没有什么提高速率的办法。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/network_speed/2020/02/15/speed-1/">
                                    <p class="title is-2">谈谈网速（一）序 <span class="tag is-white is-pulled-right"><small>February 15, 2020</small></span></p>
                                    <p class="subtitle"><small><h2 id="为什么要研究网速">为什么要研究网速</h2>

在日常生活中，你有没有遇到过以下情况呢？

<ul>
  <li>想看盗版漫画，辛辛苦苦不辞辛劳地找到资源，却发现加载速度奇慢无比，阅读体验极差</li>
  <li>想在github上clone一个几MB的项目，输入一行<strong>git clone xxx.git</strong>，喝杯咖啡回来后，git居然仍在以挤牙膏般的速度传输</li>
  <li>想用ssh连接到境外远程主机，兴高采烈地在键盘上按下键，却迟迟不出现输出</li>
  <li>…</li>
</ul>

以上情况都是我的亲身体验。我这个人有一点不好，那就是遇到不懂的事情，就一定要搞明白其中的道理。这些问题背后的道理是什么？恐怕和“网速”有着千丝万缕的联系。

<h2 id="什么是网速">什么是“网速”</h2>

“网速”这个词，似乎应该是 Network Speed 或者说 Network Rate. 但是，和这些术语不同，这里说的“网速”，其实是一个比较复杂和综合的概念，它描述的我们使用网络服务时的综合速度体验，包含这两个内容：

<ul>
  <li>比特率，考虑A主机的一个程序向B主机的一个程序发送一段连续信息。这里的比特率指这段信息的长度（以bit计）除以A程序发送信息到B程序收到信息的时间。</li>
  <li>网络延迟，一个包从源站发送到目的站接收需要的时间。</li>
</ul>

必须指出，这两个内容并不是正交的，而是有一定联系的。

我们将上节中所说的问题用这两个内容来规约一下，就是：

<ul>
  <li>看漫画问题 – 比特率太低</li>
  <li>clone问题 – 比特率太低</li>
  <li>ssh问题 – 延迟太高</li>
</ul>

很显然，这两个话题不是很好讨论的，它涉及到计算机网络的方方面面，我们也不打算一一讨论，现在确定了以下的内容：

<ul>
  <li>传输延迟与比特率的关系</li>
  <li>应用层对比特率的直观认识</li>
  <li>以太网的比特率</li>
  <li>ISP接入的比特率与限速</li>
  <li>丢包与TCP</li>
  <li>linux对TCP的实现</li>
  <li>TCP性能调优</li>
  <li>实现自己的TCP</li>
  <li>BBR</li>
</ul>

自问自答一下吧：

<ul>
  <li>为啥网络延迟不怎么研究？
    <ul>
      <li>因为这主要和运营商有关，个人搞不出来太大名堂。</li>
    </ul>
  </li>
  <li>这么多话题，要写多长时间呢？
    <ul>
      <li>或许会写很长时间吧！但愿我能把这些坑都填上。</li>
    </ul>
  </li>
</ul>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/802.11i/2020/02/14/eap/">
                                    <p class="title is-2">802.11i 无线网络安全（二）-- 802.1x eap认证 <span class="tag is-white is-pulled-right"><small>February 14, 2020</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81eap%e8%ae%a4%e8%af%81">为什么需要EAP认证</a></li>
  <li><a href="#%e6%9c%ac%e6%96%87%e8%a6%81%e6%90%9e%e6%b8%85%e6%a5%9a%e7%9a%84%e4%b8%bb%e8%a6%81%e9%97%ae%e9%a2%98">本文要搞清楚的主要问题</a></li>
  <li><a href="#%e5%af%b9%e6%95%b4%e4%b8%aa8021x-eap%e8%ae%a4%e8%af%81%e6%9e%b6%e6%9e%84%e7%9a%84%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d">对整个802.1x EAP认证架构的简单介绍</a></li>
  <li><a href="#%e6%90%ad%e5%bb%ba%e4%bd%bf%e7%94%a8eap%e7%9a%8480211%e6%97%a0%e7%ba%bf%e7%bd%91%e7%bb%9c">搭建使用EAP的802.11无线网络</a>
    <ul>
      <li><a href="#%e6%90%ad%e5%bb%basupplicant">搭建supplicant</a></li>
      <li><a href="#%e6%90%ad%e5%bb%baradius-server">搭建Radius Server</a></li>
      <li><a href="#%e6%90%ad%e5%bb%baap">搭建AP</a></li>
      <li><a href="#%e8%af%b4%e6%98%8e">说明</a></li>
    </ul>
  </li>
  <li><a href="#%e8%bf%9e%e6%8e%a5%e5%88%b0%e8%bf%99%e4%b8%aa%e6%97%a0%e7%ba%bf%e7%bd%91%e8%b7%af">连接到这个无线网路</a>
    <ul>
      <li><a href="#%e4%bd%bf%e7%94%a8peap%e6%96%b9%e6%b3%95">使用PEAP方法</a></li>
      <li><a href="#%e4%bd%bf%e7%94%a8eap%ef%bc%8dtls%e6%96%b9%e6%b3%95">使用EAP－TLS方法</a></li>
    </ul>
  </li>
  <li><a href="#%e5%88%86%e6%9e%90eap%ef%bc%8dtls%e6%96%b9%e6%b3%95%e7%9a%84%e5%85%a8%e8%bf%87%e7%a8%8b">分析EAP－TLS方法的全过程</a>
    <ul>
      <li><a href="#clinet-certificate%e4%b8%8etls12%e4%b8%ad%e7%9a%84client-certificatecertificate-verify%e5%b8%a7">Clinet Certificate与tls1.2中的Client Certificate、Certificate Verify帧</a></li>
      <li><a href="#eap-tls%e6%96%b9%e6%b3%95%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e5%8f%8c%e5%90%91%e8%ae%a4%e8%af%81">EAP-TLS方法如何进行双向认证</a></li>
      <li><a href="#eap-tls%e6%96%b9%e6%b3%95%e7%9a%84%e5%8d%8f%e8%ae%ae%e6%a0%88">EAP-TLS方法的协议栈</a></li>
      <li><a href="#%e7%ac%ac%e4%b8%80%e9%98%b6%e6%ae%b5-%e5%8f%91%e9%80%81%e8%ba%ab%e4%bb%bd%e4%bf%a1%e6%81%af">第一阶段 ：发送身份信息</a></li>
      <li><a href="#%e7%ac%ac%e4%ba%8c%e9%98%b6%e6%ae%b5-%e5%8d%8f%e5%95%86eap%e6%96%b9%e6%b3%95">第二阶段 ：协商EAP方法</a></li>
      <li><a href="#%e7%ac%ac%e4%b8%89%e9%98%b6%e6%ae%b5-eap-tls%e8%bf%87%e7%a8%8b">第三阶段 ：EAP-TLS过程</a></li>
      <li><a href="#%e7%ac%ac%e5%9b%9b%e9%98%b6%e6%ae%b5-eap%e6%88%90%e5%8a%9f%ef%bc%8f%e5%a4%b1%e8%b4%a5">第四阶段 ：EAP成功／失败</a></li>
    </ul>
  </li>
  <li><a href="#eap-tls%e5%a6%82%e4%bd%95%e4%b8%ba80211i%e7%9a%84key-hierarchy%e8%bf%87%e7%a8%8b%e6%8f%90%e4%be%9bpmk">EAP-TLS如何为802.11i的Key Hierarchy过程提供PMK</a></li>
  <li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
</ul>

<h2 id="为什么需要eap认证">为什么需要EAP认证</h2>

我们在<a href="/jekyll-theme-blogfolio/802.11i/2019/11/02/802-11i-1/">无线网络安全（1）</a>中说过，所谓的“认证”，在802.11i的RSN（或者说，WPA）中有两种方式，一种是<strong>802.1x EAP</strong>认证，一种是<strong>pre-shared-key</strong>认证，而<strong>pre-shared-key</strong>认证直接跳过认证过程，通过“四次握手”(密钥生成与分发)过程，验证<strong>AP</strong>和<strong>STA</strong>对于<strong>PSK</strong>的所有权，是一种相互认证。

但<strong>pre-shared-key</strong>认证有一些缺陷。以我们的无线校园网<strong>SYSU_SECURE</strong>为例，如果采取<strong>pre-shared-key</strong>认证，那么就会遇到很多问题：

<ul>
  <li>向一个人分发一份<strong>pre-shared-key</strong>，本意是让一个人使用。但由于密钥生成与分发过程只验证AP和STA对<strong>PSK</strong>的所有权，如果这个人（A）将<strong>PSK</strong>送给了另一个人(B)，那么B也可以用这个<strong>PSK</strong>连接校园网。</li>
  <li>更新<strong>PSK</strong>时如何安全地通知全校同学？</li>
</ul>

实际上，如果范围很大的话，我们很难控制<strong>PSK</strong>的传播。在802.11i中引入EAP，就是为了解决大规模无线网络的认证问题。

<h2 id="本文要搞清楚的主要问题">本文要搞清楚的主要问题</h2>

<ul>
  <li>什么是EAP？</li>
  <li>使用802.1x EAP认证方法如何产生802.11i需要的PMK?</li>
  <li>如何搭建一个WPA2-Enterprise或者说使用802.1x EAP认证方法的无线网络？</li>
  <li>EAP-TLS如何进行双向验证？</li>
</ul>

<h2 id="对整个8021x-eap认证架构的简单介绍">对整个802.1x EAP认证架构的简单介绍</h2>

EAP这个东西，是古董。在PPP链路大行其道的时代，EAP就出现了。它最初就是为了解决PPP的认证问题而引入的。对它的具体描述，参见<a href="https://tools.ietf.org/html/rfc3748">rfc3748</a>。EAP叫做“可扩展认证协议”，它只规定了一个壳子，我们可以通过各种方法改造它以适应我们的要求。

而802.1x，是所谓的“基于端口的介质访问控制”ieee标准。什么意思呢？就是说，在客户端没有认证之前，客户端只能通过“被控制的端口”（controlled port）和网络接入点（比如AP、交换机、路由器等等）进行通信。这就说是，在没有认证之前，网络接入点只接受客户端发来的802.1x帧（在以太网里，TYPE字段值为0x888e），其他的一律扔掉。这样一来，客户端虽然在物理上可以和网络接入点进行通信，但是只能进行认证而不能和别的终端进行通信。如果客户端进行了认证，那么，客户端就可以从不被控制的端口（uncontrolled port）通信，简单地来说就是可以上网了。这样一来，802.1x就提供了一种在以太网上进行访问控制的方法。

那么，802.1x和EAP的关系是怎么样的呢？这是一个略复杂的问题。我们说，在以太网上，TYPE字段设置为0x888e就代表上层协议是802.1x。而它上层的协议包，被称为EAPOL（EAP over LAN），也就是EAP在Lan上的实现。它的包格式被802.1x规定如下：

<img src="https://i.loli.net/2020/02/14/qM7h4IWTSYptlAC.png" alt="1.PNG" />

可是令人迷惑的是，EAP协议有自己的包格式：

<img src="https://i.loli.net/2020/02/14/5XSJcP9bneWv7LQ.png" alt="2.PNG" />

那么，在以太网或者802.11无线网中，使用的包格式究竟是哪一套呢？

答案很简单，这两套都使用。而且这两套包的层次是不同的。简单地说，802.1x的作用是“访问控制”，EAP的作用是“认证”。我们先按下不表，看看这个认证体系的拓扑架构：

<img src="https://i.loli.net/2020/02/14/TJhdktbIyjoqQuz.png" alt="3.PNG" />

我们发现，在这个架构里，有三个角色：

<ul>
  <li>host – 客户</li>
  <li>Network Access Server – <strong>NAS</strong>网络接入服务器</li>
  <li>Authentication Server – 认证服务器</li>
</ul>

这三个角色的作用和它的名字基本一样。那么，我们发现，在这个体系中，“认证”是委托给认证服务器做的。但认证服务器和客户的通信必须借助<strong>NAS</strong>的转发。而<strong>NAS</strong>转发的包，就是EAP包；客户和<strong>NAS</strong>的通信，是802.1x,或者说是EAPOL包, EAP包被封装在EAPOL包中；<strong>NAS</strong>和认证服务器的通信，是RADIUS包。实际上，整个协议栈可以如下示意：

<img src="https://slideplayer.com/slide/4802754/15/images/19/Through+the+protocol+stack.jpg" alt="4.PNG" />

实际上，如果仔细看802.1x-2010的话, 当EAPOL包的TYPE字段被设置为0时, 这个包的PacketBody字段就会是一个EAP包:

<img src="https://i.loli.net/2020/02/14/GN7PgKzLWIib3fZ.png" alt="5.PNG" />

我们用wireshark抓包也会看到这一点:

<img src="https://i.loli.net/2020/02/14/IcFwZpj9BxTDl3b.png" alt="6.PNG" />

为什么说EAP是用来认证的?因为EAP包是客户和认证服务器用来作认证通信的。理解了这一点，让我们暂时放下理论，先搭建一套使用EAP的802.11无线网络吧。

<h2 id="搭建使用eap的80211无线网络">搭建使用EAP的802.11无线网络</h2>

根据802.1x认证的构成要件，这里的无线网络至少要由三个部分：

<ul>
  <li>suplicant – 客户</li>
  <li>Access Point – 无线接入点<strong>AP</strong></li>
  <li>Radius Server – Radius 服务器</li>
</ul>

需要指出的是，这里的<strong>AP</strong>是“胖AP”，也就是说，它既担任接入点，又担任DHCP Server和Radius client，如果将AP换做所谓的“瘦AP”，那么，这里会有四个部分。

<h3 id="搭建supplicant">搭建supplicant</h3>

现在的各种操作系统都有直接连接EAP方法的无线网的组件，这一步不用自己做什么。

<h3 id="搭建radius-server">搭建Radius Server</h3>

这里我们使用了<a href="https://freeradius.org/">FreeRadius</a>这个开源的Radius服务器，在ubuntu18.04 LTS上搭建了Radius服务器。

配置步骤如下：

<ol>
  <li>
    在终端中输入

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo </span>apt-get <span class="nb">install </span>freeradius
</code></pre></div>    </div>
  </li>
  <li>
    安装完成后，打开服务器，修改/etc/freeradius/users，添加一个用户，并使用radtest进行测试：

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">echo </span>bob Cleartext-Password :<span class="o">=</span> <span class="s2">"hello"</span> <span class="o">&gt;&gt;</span> /etc/users
 <span class="nb">sudo </span>freeradus <span class="nt">-X</span>
 radtest bob hello 127.0.0.1 0 testing123
</code></pre></div>    </div>
  </li>
  <li>
    测试成功后，切换到/etc/freeradius/3.0/certs目录，修改client.cnf，填写自己在users中的用户相关信息（比如CN = bob），并使用make工具产生证书：

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> vim client.cnf
 make
</code></pre></div>    </div>
  </li>
  <li>
    修改/etc/freeradius/3.0/mods-enabled/eap文件，将ca证书改成刚刚修改好的证书：

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ca_file <span class="o">=</span> /etc/freeradius/3.0/certs/ca.pem
</code></pre></div>    </div>
  </li>
  <li>
    修改/etc/freeradius/3.0/client.conf文件，新建一个clinet，准备与ap连接

    <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code> client 192.168.1.1 <span class="o">{</span>
   ipaddr <span class="o">=</span> 192.168.1.1
   proto <span class="o">=</span> <span class="k">*</span>
   secret <span class="o">=</span> testing123
 <span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    将此服务器和AP连接到同一个网络，这里我使用的是虚拟机，所以新建了一块桥接网卡。
  </li>
</ol>

至此，Radius服务器就建好了，下面搭建AP。

<h3 id="搭建ap">搭建AP</h3>

这里我们采用了我家的家用路由器。

<ul>
  <li>型号：ASUS RT-AC87R</li>
  <li>固件版本：华硕原生固件 3.0.0.4.376_2769-g1bb5fac</li>
</ul>

配置步骤如下：

<ol>
  <li>在<strong>无线网络-一般设置</strong>中将2.4G的验证方式设置为WPA-Enterprise。</li>
  <li>在<strong>无线网络-Radius设置</strong>中，填写Radius服务器地址、端口、密码等信息。</li>
</ol>

至此，AP配置完成。

<h3 id="说明">说明</h3>

freeradius是一个很强的服务器，如果搭建到了这里，它的默认设置就几乎可以支持市面上常见的所有EAP方法，包括EAP-MD5、EAP-TLS、EAP-TTLS、EAP-PEAP等。

<h2 id="连接到这个无线网路">连接到这个无线网路</h2>

<h3 id="使用peap方法">使用PEAP方法</h3>

在Windows平台和ios平台下，直接连接上面的无线网络，操作系统会默认使用PEAP方法。在GUI中输入用户名和密码即可。

<h3 id="使用eaptls方法">使用EAP－TLS方法</h3>

为什么要使用EAP－TLS方法呢？因为PEAP方法会第一阶段会创造tls信道，第二阶段分析起来不太方便。我们对TLS也相当熟悉，所以决定使用EAP-TLS方法进行分析整个连接过程。如果要分析，就必须先连接上。这里使用Windows平台进行连接。

在上一步的配置中，freeradius会产生一堆证书：

<img src="https://i.loli.net/2020/02/14/h2xVkQqc7KiEOUT.png" alt="7.PNG" />

将clinet.p12复制一份到windows平台下，双击，进行安装。注意选择“标记为可导出的证书”选项。

<img src="https://i.loli.net/2020/02/14/brgWiSUOe2FK6nX.png" alt="8.PNG" />

然后在控制面版中新建一个无线连接：

<img src="https://pic.downk.cc/item/5e46481848b86553ee0f20df.png" alt="" />

填写相关参数，并选择<strong>下一步</strong>：

<img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e2.png" alt="" />

选择<strong>更改连接设置</strong>：

<img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e4.png" alt="" />

在这个界面需要更改两个内容：

<img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e6.png" alt="" />

<ol>
  <li>
    在<strong>高级设置</strong>中将<strong>指定身份验证模式</strong>改为<strong>用户身份验证</strong>

    <img src="https://pic.downk.cc/item/5e4647ff48b86553ee0f1597.png" alt="14.png" />
  </li>
  <li>
    在<strong>选择网络身份验证方法</strong>中选择<strong>Microsoft智能卡或其他证书</strong>，并点击<strong>设置</strong>

    在<strong>设置</strong>页面取消对<strong>通过验证证书验证服务器的身份</strong>的选择：

    <img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e8.png" alt="" />
  </li>
</ol>

然后，在GUI中直接连接。

<h2 id="分析eaptls方法的全过程">分析EAP－TLS方法的全过程</h2>

在刚才的连接过程中，我们可以看到，整个设置很繁琐。这是因为EAP-TLS使用了<strong>Client Certificate</strong>来验证客户端的有效性。

<h3 id="clinet-certificate与tls12中的client-certificatecertificate-verify帧">Clinet Certificate与tls1.2中的Client Certificate、Certificate Verify帧</h3>

在<a href="https://tools.ietf.org/html/rfc3748">rfc5246</a>中，定义了一个我们在TLS系列中没有分析过的帧 – <strong>clinet certificate</strong>. 这一帧是在收到服务器发来的<strong>Certificate Request</strong>帧后，客户端必须发送的帧。服务端通过这一帧来验证客户端的的身份。然而，在https的世界里，我们很少使用这个东西。因为http对应的主要是web应用，web应用一般不会要求验证用户的身份，即使真的要求，基于https的身份验证也会让使用http的用户无法登录，还有部署麻烦等劣势，所以用的很少，我们在之前的TLS文章中也没有研究。

这一帧的结构如下：

<blockquote>
  Client certificates are sent using the Certificate structure defined in Section 7.4.2.
</blockquote>

7.4.2是Server Certificate的定义，所以这里也和Server Certificate一样，是直接<strong>明文</strong>发过去的。

回忆TLS中对于Server Certificate的验证，我们会发现，如果只发送Client Certificate帧，是不能验证客户端对于这个证书的所有权的，验证所有权的关键，应该是私钥。客户端对证书的所有权，是Certificate Verify帧验证的。

这一帧的结构如下：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="p">{</span>
    <span class="n">digitally</span><span class="o">-</span><span class="kt">signed</span> <span class="k">struct</span>
    <span class="p">{</span>
        <span class="n">opaque</span> <span class="n">handshake_messages</span><span class="p">[</span><span class="n">handshake_messages_length</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span> <span class="n">CertificateVerify</span><span class="p">;</span>
</code></pre></div></div>

handshake_messages指的是从握手开始到握手结束的所有消息的连接，而digitally-signed正是指客户端需要用私钥加密这些消息。这样一来，服务端端用证书中的公钥解密，判断一下是否和自己存储/打的哈希一致，就可以验证客户端对证书的所有权了。

<h3 id="eap-tls方法如何进行双向认证">EAP-TLS方法如何进行双向认证</h3>

<ul>
  <li>客户端认证服务端：通过tls的密钥交换，是标准的tls方法，和一般使用的tls一致。</li>
  <li>服务端认证客户端：通过Client Certificate和Certificate Verify消息，是标准的tls方法，但不常用。</li>
</ul>

<h3 id="eap-tls方法的协议栈">EAP-TLS方法的协议栈</h3>

既然这个方法名字叫做EAP-TLS，那么就是使用TLS来进行双向认证的。这里有个问题，那就是我们现在无法使用IP协议和TCP协议，如何使用TLS呢？这里采取的方法是，将TLS的帧封装在EAP协议中。

用wireshark抓包，可以很清晰地看出这个情况：

<img src="https://pic.downk.cc/item/5e4650f348b86553ee1226df.png" alt="" />

下面我们来分析认证的全过程。

<h3 id="第一阶段-发送身份信息">第一阶段 ：发送身份信息</h3>

首先需要说明，以下所有的通信都是发生于Radius Server（认证服务器）和STA之间的，AP只是起转发作用。

在做完<strong>NULL　Authentication</strong>之后，STA发送EAPOL_Start帧，表明开始进行802.1x认证：

<img src="https://pic.downk.cc/item/5e4684c748b86553ee250255.png" alt="" />

之后，STA回应AP的Request Identity消息，发送自己的身份信息：

<img src="https://pic.downk.cc/item/5e46850f48b86553ee2521c4.png" alt="" />
<img src="https://pic.downk.cc/item/5e46850f48b86553ee2521c6.png" alt="" />

如果身份信息合法，进入下一阶段

<h3 id="第二阶段-协商eap方法">第二阶段 ：协商EAP方法</h3>

AP发送Request-MD5-Challenge消息，要求使用EAP-MD5-Challenge方法：

<img src="https://pic.downk.cc/item/5e46859d48b86553ee2562c3.png" alt="" />

客户端不同意，发送NAK消息，并指出自己想使用EAP-TLS方法：

<img src="https://pic.downk.cc/item/5e4685cf48b86553ee257d24.png" alt="" />

<img src="https://pic.downk.cc/item/5e4685cf48b86553ee257d27.png" alt="" />

AP换用EAP-tls方法，发送Request-eap-tls消息：

<img src="https://pic.downk.cc/item/5e4685f548b86553ee25ad82.png" alt="" />

下面的消息就全部是tls协议帧了。

<h3 id="第三阶段-eap-tls过程">第三阶段 ：EAP-TLS过程</h3>

eap-tls由rfc2716定义，现在通行的是<a href="https://tools.ietf.org/html/rfc2548">rfc5216</a>。

成功的eap-tls整个过程大概有三种情况，一种是标准的tls握手过程，另一种是标准的tls快速恢复握手过程，还有一种是支持privacy的两次握手。这里只观察到了第一种，故只讨论第一种。

此过程和一般的tls握手过程主要有以下区别：

<ul>
  <li>服务端发送Certificate Request消息，客户端回应client Certificate 和 Certificate Verify消息。</li>
  <li>同时进行EAP-TLS Key Hierarchy过程。注意，这并不是说TLS的Key Hierarchy过程就不进行了，而是说另外地进行其他的Key Hierarchy过程。由于握手过程的最后一帧finished是加密的，所以标准的TLS的Key Hierarchy也是必须的。</li>
</ul>

抓包结果如下：

<img src="https://pic.downk.cc/item/5e46865748b86553ee260de9.png" alt="" />

<h3 id="第四阶段-eap成功失败">第四阶段 ：EAP成功／失败</h3>

如果成功，AP向STA发送EAP　Success消息，如果失败，AP向STA发送EAP Failure消息。

<img src="https://pic.downk.cc/item/5e46868248b86553ee262794.png" alt="" />

<h2 id="eap-tls如何为80211i的key-hierarchy过程提供pmk">EAP-TLS如何为802.11i的Key Hierarchy过程提供PMK</h2>

我们知道，在802.11i无线网络中，Key Hierachy的起点是<strong>PMK</strong>(Pairwise Master Key)。如果使用<strong>PSK</strong>方法，那么<strong>PMK</strong>就是<strong>PSK</strong>。如果使用EAP方法呢？802.11-2007并没有说得很明白，而是使用了May这样的词，但从“密码”到<strong>PSK</strong>所使用的哈希函数也是may，所以还是很有参考价值的。它指向了一个很奇怪的记号：<strong>MS-MPPE-Recv-Key</strong>。这个<strong>MS</strong>恐怕指的就是<strong>Microsoft</strong>了，而这个符号实际上来源于PEAP，是PEAP第一阶段（也是用TLS，只不过没有用Cilent Certificate校验客户端）通过Key Hierarchy产生的密钥。

EAP-TLS提供了一种和标准TLS不同的方法，来生成PMK，在rfc-5216的2.3节中被这样定义：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">Key_Material</span> <span class="o">=</span> <span class="n">TLS</span><span class="o">-</span><span class="n">PRF</span><span class="o">-</span><span class="mi">128</span><span class="p">(</span><span class="n">master_secret</span><span class="p">,</span> <span class="s">"client EAP encryption"</span><span class="p">,</span> <span class="n">client</span><span class="p">.</span><span class="n">random</span> <span class="o">||</span> <span class="n">server</span><span class="p">.</span><span class="n">random</span><span class="p">)</span>
 <span class="n">MSK</span> <span class="o">=</span> <span class="n">Key_Material</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span>
 <span class="n">EMSK</span> <span class="o">=</span> <span class="n">Key_Material</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span><span class="mi">127</span><span class="p">)</span>
 <span class="n">IV</span> <span class="o">=</span> <span class="n">TLS</span><span class="o">-</span><span class="n">PRF</span><span class="o">-</span><span class="mi">64</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="s">"client EAP encryption"</span><span class="p">,</span> <span class="n">client</span><span class="p">.</span><span class="n">random</span> <span class="o">||</span> <span class="n">server</span><span class="p">.</span><span class="n">random</span><span class="p">)</span>
 <span class="n">Enc</span><span class="o">-</span><span class="n">RECV</span><span class="o">-</span><span class="n">Key</span> <span class="o">=</span> <span class="n">MSK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">31</span><span class="p">)</span> 
    <span class="cm">/*
    Peer to Authenticator Encryption Key
    (MS-MPPE-Recv-Key in [RFC2548]). Also known as the
    PMK in [IEEE-802.11].
    */</span>
 <span class="n">Enc</span><span class="o">-</span><span class="n">SEND</span><span class="o">-</span><span class="n">Key</span> <span class="o">=</span> <span class="n">MSK</span><span class="p">(</span><span class="mi">32</span><span class="p">,</span><span class="mi">63</span><span class="p">)</span> 
    <span class="cm">/*
    Authenticator to Peer Encryption Key
    (MS-MPPE-Send-Key in [RFC2548])
    */</span>
</code></pre></div></div>

为什么<strong>MS-MPPE-Recv-Key</strong>成了事实上的<strong>PMK</strong>呢？这似乎有历史原因，我并没有找到一个解释或是说明。但事实就是这样，我们的好奇心也不必过于旺盛。

这时，所有的问题都解决了吗？确实解决了。但是我们又有了新的问题：tls握手是在Authentication Server和Client之间发生的，AP是如何得到Enc-RECV-Key的呢？下一阶段的Key Hierarchy是AP进行的，它必须得到PMK。

我们仔细研究一下Radius Server发给AP的最后一帧：

<img src="https://pic.downk.cc/item/5e4686bc48b86553ee264917.png" alt="" />

图中确实看到了MS-MPPE-RECV-KEY字段，但为什么长度不是0x22(32byte的Key, 1byte的Id，1byte的length)，而是0x34（52）呢？这是因为它不是明文传的，而是加密+padding后的结果。具体是如何加密的，可以参考<a href="https://tools.ietf.org/html/rfc2548">rfc2548</a>，此处就不赘述了。

<h2 id="总结">总结</h2>

研究EAP是一件不那么轻松的事，主要原因一是资料少，二是资料基本都是英文的，中文搜索几乎没有什么有用结果。通过写这篇文章、研究这些内容，我已经基本搞清楚了802.11i认证过程的所有过程，不过还有很多坑待填，譬如最后产生的GTK究竟有什么用、如何处理漫游等等问题。不过，相信在不远的将来，我会完全研究清楚这些问题。

最后来谈一谈我在部署过程中所踩的坑。

<ul>
  <li>我们必须安装PKCS格式的证书，而不是.crt .pem那样的base64编码的证书（不然私钥无法安装）。</li>
  <li>我们必须勾选“允许导出”选项，不然不会使用这张证书。</li>
  <li>我们必须设置“用户认证”，不然windows会将我们计算机的主机名在eap identity里传过去。</li>
</ul>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2020/01/02/sort/">
                                    <p class="title is-2">数据结构 -- 排序 -- 笔记 <span class="tag is-white is-pulled-right"><small>January 02, 2020</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
  <li><a href="#%e5%85%b3%e4%ba%8e%e6%8e%92%e5%ba%8f%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98">关于排序的基本问题</a></li>
  <li><a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f">插入排序</a>
    <ul>
      <li><a href="#%e5%85%b3%e4%ba%8e%e7%9b%91%e8%a7%86%e5%93%a8">关于“监视哨”</a></li>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%b8%8c%e5%b0%94%e6%8e%92%e5%ba%8f">希尔排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-1">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f">冒泡排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-2">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f">快速排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-3">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f">选择排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-4">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%a0%86%e6%8e%92%e5%ba%8f">堆排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-5">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f">归并排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-6">算法分析</a></li>
    </ul>
  </li>
  <li><a href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f">基数排序</a>
    <ul>
      <li><a href="#%e7%ae%97%e6%b3%95%e5%88%86%e6%9e%90-7">算法分析</a></li>
    </ul>
  </li>
</ul>

<h2 id="前言">前言</h2>

这一章我们学习了排序这一基本算法。本笔记主要做了以下工作：

<ul>
  <li>总结了排序的各种问题</li>
  <li>总结并实现了8种排序算法：
    <ul>
      <li>插入排序</li>
      <li>希尔排序</li>
      <li>冒泡排序</li>
      <li>快速排序</li>
      <li>选择排序</li>
      <li>堆排序</li>
      <li>归并排序</li>
      <li>基数排序</li>
    </ul>
  </li>
  <li>这一章的笔记不同于前面两章。前面两章的笔记所含数据结构和算法的实现代码如无特殊标注，均是我自己实现并测试的。而本章的很多代码都是我从资料中引用的。这是因为某些算法实现起来很简单，或实现价值不大。当然，引用者我们也会标出。</li>
</ul>

<h2 id="关于排序的基本问题">关于排序的基本问题</h2>

<blockquote>
  在计算机科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。
</blockquote>

排序算法有以下基本问题：

<ul>
  <li>稳定性。如果一个排序算法是稳定的，当有两个相等键值的纪录$R$和$S$，且在原本的列表中$R$出现在$S$之前，在排序过的列表中$R$也将会是在$S$之前。</li>
  <li>内排序与外排序。是否需要使用外存储器</li>
  <li>空间复杂度。</li>
  <li>时间复杂度。</li>
</ul>

其实这里教师忽视了一个问题，那就是排序算法是否对现代计算机体系结构友好，或者说的露骨一点，<em>是否会频繁地cache不命中、TLB不命中、页表不命中</em>。当然，作为算法本身来说，这倒是无所谓。但是，既然说到了内排序与外排序这种实现上的问题，那这个问题也应该谈及。

<h2 id="插入排序">插入排序</h2>

插入排序明明是最简单的排序之一，网上有些人却讲的令人云里雾里，不知所云。特别是所谓的“监视哨”，更是让这个简单的算法变得很复杂了。不客气地说，教师的讲述也是不清楚的。

这个算法的基本思想就是一个结构归纳：

<blockquote>
  如果一个长度为$n$的序列自$0$号至$m - 1$号元素都是有序的，那么只要将$m$号元素插入$0$号至$m - 1$号元素的正确位置，那么这个序列就是从$0$号至$m$号有序的。
</blockquote>

有了这个思想，我们定义一个基本操作A(n)，就是将一个从$0$到$n - 1$有序的序列变为一个从$0$到$n$有序的序列。那么，只要自$1$至$n - 1$使用这个操作，这个序列就被排好序了。

我们还要搞定最后一个问题，那就是如何将$m$号元素插入到“正确”位置呢？答案也很简单，那就是设置一个条件$P$，如果$P(list[i], list[m])$满足条件，那就结束，否则将$i$号元素后移，继续和$i - 1$号元素比较。这样有些抽象，为了真正说明白，还是需要代码：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 此段代码来自维基百科--插入排序词条 */</span>
<span class="kt">void</span> <span class="nf">insertion_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span><span class="kt">int</span> <span class="n">len</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">len</span><span class="p">;</span><span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">key</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">j</span><span class="o">=</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span><span class="p">((</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">key</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])){</span>
          <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
          <span class="n">j</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

显然，这段代码是升序排序的代码，它很简单。作为实现来说，不足之处是没有正确利用模板，只能实现对整数序列排序。

<h3 id="关于监视哨">关于“监视哨”</h3>

一个比较麻烦的问题是所谓的“监视哨”，其实说它“比较麻烦”也是因为有些人讲的实在太混乱。

我们重点关注以下刚才探讨的代码的这一句话：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span><span class="p">((</span><span class="n">j</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">key</span><span class="o">&lt;</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">])){</span>
</code></pre></div></div>

什么时候会触发$j &gt;= 0$这一条件呢？那就是$j == -1$的时候，也就是说从$0$到$i - 1$都不满足条件，要把这个元素插在开头。

这样我们会发现，这做法是为了一次失败准备的，但我们却要在成功的时候（绝大部分）来作这次比较。

所以自然地，我们会想到要不要优化一下，想办法消除掉这次比较。

那有些人就想到，把0号位置放入一个一定会满足退出条件的元素不就好了！这就是所谓的“监视哨”（sentinel）

至于放什么、怎么放之类的无聊问题这里就不谈了。但是我们必须指出，现代CPU具有流水线、多发射、乱序执行的特性，这种优化是不是真的可以优化时效，我们是有疑问的。

<h3 id="算法分析">算法分析</h3>

插入排序的

<ul>
  <li>最好时间复杂度为：$O(n)$</li>
  <li>最坏时间复杂度为：$O(n^2)$</li>
  <li>平均时间复杂度为：$O(n^2)$</li>
  <li>是否稳定：稳定</li>
  <li>辅助空间：$O(1)$</li>
</ul>

<h2 id="希尔排序">希尔排序</h2>

插入排序有两个比较快的情况：

<ol>
  <li>序列基本有序</li>
  <li>序列很短</li>
</ol>

希尔排序就是利用这两个情况来使插入排序变为一个比较快速的排序。

维基百科上对希尔排序的解释及其直观，我们这里来复读一下：

考虑一个序列[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，我们一开始把它分为5个列表：
13 14 94 33 82 
25 59 94 65 23
45 27 73 25 39
10

然后分别对这5列排序（这每一列的排序是插入排序）：
10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45

连接到一起得到[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ]，然后再把它分为三个列表：
10 14 73 
25 23 13 
27 94 33 
39 25 59 
94 65 82 
45

然后再对这三个列表排序：
10 14 13 
25 23 33 
27 25 59 
39 65 73 
45 94 82 
94

这时基本有序了，我们把它连接到一起，再进行直接插入排序就好了。

我们看到，这个排序过程有一个“分成n个列表”的动作，这个$n$的不同取值，叫做步长序列。

步长序列怎么取呢？这取法是很多的，算法的发明者采用的是$\frac{n}{2}, \frac{n}{4}, …, 1$这个序列。

我们来实现一下这个“分列 -&gt; 排序”的过程：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MyShellSort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">step</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">step</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">step</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="n">step</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">step</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">)</span>
			<span class="p">{</span>
				<span class="n">vec</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="n">j</span> <span class="o">-=</span> <span class="n">step</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">vec</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">step</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

如果对比一下这份代码和插入排序的代码，我们会发现插入排序就是希尔排序$step == 1$时的情况。

然后我们也会看到，如果step比较大，那么待排序元素数量不大，会进入第一个插入排序较快情况；如果step比较小，那么序列基本有序，进入第二个插入排序较快情况。可见希尔排序的速度应该是比较好的。

<h3 id="算法分析-1">算法分析</h3>

希尔排序的

<ul>
  <li>最好时间复杂度为：$O(n)$</li>
  <li>最坏时间复杂度为：不知道</li>
  <li>平均时间复杂度为：不知道</li>
  <li>是否稳定：不稳定（这个比较复杂，其实也有稳定的实现）</li>
  <li>辅助空间：$O(1)$</li>
</ul>

<h2 id="冒泡排序">冒泡排序</h2>

冒泡排序的基本思想是每一次都把未排序序列中最大/最小的元素交换到未排序序列的头部。

这个算法我们很熟悉，实现起来很简单：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MyBubbleSort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">){</span>
  <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">){</span>
      <span class="k">if</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

但是这样一来即使序列是有序的，我们仍然会是$O(n^2)$的时间复杂度，所以要优化一下:

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">MyBobbleSort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">vec</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>
				<span class="n">hit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hit</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">hit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

这样一来，如果序列有序，就是$O(n)$复杂度了。

<h3 id="算法分析-2">算法分析</h3>

冒泡排序的

<ul>
  <li>最好时间复杂度为：$O(n)$</li>
  <li>最坏时间复杂度为：$O(n^2)$</li>
  <li>平均时间复杂度为：$O(n^2)$</li>
  <li>是否稳定：稳定</li>
  <li>辅助空间：$O(1)$</li>
</ul>

<h2 id="快速排序">快速排序</h2>

这个算法据说是排序随机序列最快的算法。

这是一个<em>很简单</em>的算法
这是一个<em>很简单</em>的算法
这是一个<em>很简单</em>的算法

这个算法一共有三步：

<ol>
  <li>找到一个位置$i$。</li>
  <li>分割序列，使得$i$位置左子序列中的元素都比$i$小，右子序列中的元素都比$i$大</li>
  <li>递归处理左子序列和右子序列中的元素。</li>
</ol>

就按照这个描述，我们用ruby实现一下：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Array</span>
  <span class="k">def</span> <span class="nf">qsort</span>
    <span class="k">return</span> <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span> <span class="o">&lt;=</span> <span class="mi">1</span> 
    <span class="c1"># 默认找到的为置为0</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="mi">1</span><span class="o">...-</span><span class="mi">1</span><span class="p">].</span><span class="nf">partition</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="nb">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">}</span>
    <span class="n">left</span><span class="p">.</span><span class="nf">qsort</span>
    <span class="n">right</span><span class="p">.</span><span class="nf">qsort</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="nb">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">right</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

这个实现就是对算法的直接实现，但是它的效率是很堪忧的，为什么呢？

我们这样写，实际上每次都要新开辟额外的空间，而且这空间还不小，大概是$O(n)$的数量级。

如果用c/c++去写，本事就是要追求性能的，自然不可以这样。

所以我们需要一种叫做“原位排序”的技术。而原位排序的关键是原位分割，也即是说在原数组上实现分割。

为了实现原位分割，人们想了各种奇奇怪怪的方法，这里展示两种

一种是比较难以理解的：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TYPE_ITERATION</span><span class="p">&gt;</span>
<span class="n">TYPE_ITERATION</span> <span class="nf">partition</span><span class="p">(</span><span class="n">TYPE_ITERATION</span> <span class="n">begin</span><span class="p">,</span> <span class="n">TYPE_ITERATION</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">TYPE_ITERATION</span> <span class="n">str</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">iter_swap</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="o">++</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">iter_swap</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">str</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

一种是稍微好理解一点的：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">T</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//在整个范围内搜寻比枢纽小或大的元素，然后将左侧元素与右侧元素交换</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="c1">//试图在左侧找到一个比枢纽更大的元素</span>
    <span class="n">left</span><span class="o">++</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mid</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;</span> <span class="n">right</span><span class="p">)</span> <span class="c1">//试图在右侧找到一个比枢纽更小的元素</span>
    <span class="n">right</span><span class="o">--</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">right</span><span class="p">]);</span> <span class="c1">//交换元素</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">])</span>
  <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">end</span><span class="p">]);</span>
<span class="k">else</span>
  <span class="n">left</span><span class="o">++</span><span class="p">;</span> 
<span class="c1">//arr[left]就是最后被选出的元素</span>
</code></pre></div></div>

不过，有了这个partition函数，下面的操作就很简单了：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">TYPE_ITERATION</span><span class="p">&gt;</span>
<span class="n">VALUE</span> <span class="nf">Mysort</span><span class="p">(</span><span class="n">TYPE_ITERATION</span> <span class="n">begin</span><span class="p">,</span> <span class="n">TYPE_ITERATION</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">TYPE_ITERATION</span> <span class="n">mid</span> <span class="o">=</span> <span class="o">::</span><span class="n">partition</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="o">::</span><span class="n">Mysort</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	<span class="o">::</span><span class="n">Mysort</span><span class="p">(</span><span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法分析-3">算法分析</h3>

快速排序的

<ul>
  <li>最好时间复杂度为：$O(nlog(n))$</li>
  <li>最坏时间复杂度为：$O(n^2)$
    <ul>
      <li>
        <table>
          <tbody>
            <tr>
              <td>这里需要解释一下，如果每次选的元素都是最大的/最小的，那很不幸，分割就会变成 arr[0…n - 2]</td>
              <td> </td>
              <td>arr[n - 1]，这样一来就成了O(n^2)复杂度了。</td>
            </tr>
          </tbody>
        </table>
      </li>
    </ul>
  </li>
  <li>平均时间复杂度为：$O(nlog(n))$</li>
  <li>是否稳定：不稳定</li>
  <li>辅助空间：$O(log(n))$
    <ul>
      <li>这里指的是递归用到的栈空间</li>
    </ul>
  </li>
</ul>

<h2 id="选择排序">选择排序</h2>

<blockquote>
  选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
</blockquote>

实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 来自维基百科 */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="kt">void</span> <span class="nf">selection_sort</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">arr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">min</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">])</span>
				<span class="n">min</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">min</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法分析-4">算法分析</h3>

选择排序的

<ul>
  <li>最好时间复杂度为：$O(n)$</li>
  <li>最坏时间复杂度为：$O(n^2)$</li>
  <li>平均时间复杂度为：$O(n^2)$</li>
  <li>是否稳定：不稳定</li>
  <li>辅助空间：$O(1)$</li>
</ul>

<h2 id="堆排序">堆排序</h2>

堆我们在上一章已经学习过了，我们知道它可以在对数时间内完成取出最大值/最小值并调整的动作。

那么，如果我们从一个堆中取出$n$次，岂不就得到了一个排好序的序列？

这时的时间复杂度为$O(log(n))$，然后还需要把一开始的无序序列变为堆，也需要$O(log(n))$，总体来看，堆排序可以稳定地达到$O(log(n))$的复杂度。

由于上次已经用ruby实现过堆了，我们这次直接实现一个堆排序就极为简单：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">BinaryHeapable</span>
  <span class="k">def</span> <span class="nf">heap_sort</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">convert_to_heap</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="n">arr</span> <span class="o">&lt;&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">remove_from_heap</span>
    <span class="k">end</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="n">arr</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

但这样和快速排序一样，会耗费额外的空间。我们也最好要实现原位排序。

如何实现呢？我们这样去做：
每次排序时，顺序执行这三个步骤：

<ol>
  <li>把堆顶元素和堆尾元素交换</li>
  <li>堆的长度减一</li>
  <li>调整，使得新的堆满足堆序。</li>
</ol>

c++实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 代码来自维基百科 */</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">max_heapify</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 建立父節點指標和子節點指標</span>
    <span class="kt">int</span> <span class="n">dad</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">son</span> <span class="o">=</span> <span class="n">dad</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">son</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 若子節點指標在範圍內才做比較</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="c1">// 先比較兩個子節點大小，選擇最大的</span>
            <span class="n">son</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">dad</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">])</span> <span class="c1">// 如果父節點大於子節點代表調整完畢，直接跳出函數</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span> <span class="c1">// 否則交換父子內容再繼續子節點和孫節點比較</span>
            <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">dad</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">son</span><span class="p">]);</span>
            <span class="n">dad</span> <span class="o">=</span> <span class="n">son</span><span class="p">;</span>
            <span class="n">son</span> <span class="o">=</span> <span class="n">dad</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">heap_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 初始化，i從最後一個父節點開始調整</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
        <span class="n">max_heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="c1">// 先將第一個元素和已经排好的元素前一位做交換，再從新調整(刚调整的元素之前的元素)，直到排序完畢</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">max_heapify</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法分析-5">算法分析</h3>

堆排序的

<ul>
  <li>最好时间复杂度为：$O(nlog(n))$</li>
  <li>最坏时间复杂度为：$O(nlog(n))$</li>
  <li>平均时间复杂度为：$O(nlog(n))$</li>
  <li>是否稳定：不稳定</li>
  <li>辅助空间：$O(1)$</li>
  <li><em>堆排序缓存不友好，容易造成缓存不命中，所以一般不使用</em></li>
</ul>

<h2 id="归并排序">归并排序</h2>

归并排序是很经典的分治算法，一共分为三步：

<ol>
  <li>分，分成两个子序列。</li>
  <li>治，递归处理两个子序列。这一步完成后，两个子序列即为有序。</li>
  <li>合，合并这两个子序列，使得它们有序。</li>
</ol>

c++实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">merge_sort_recursive</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">reg</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">start</span><span class="p">,</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">start1</span><span class="p">,</span> <span class="n">end1</span><span class="p">);</span>
    <span class="n">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="n">start2</span><span class="p">,</span> <span class="n">end2</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span> <span class="o">&amp;&amp;</span> <span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
        <span class="n">reg</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="p">]</span> <span class="o">?</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">]</span> <span class="o">:</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">end1</span><span class="p">)</span>
        <span class="n">reg</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start1</span><span class="o">++</span><span class="p">];</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">start2</span> <span class="o">&lt;=</span> <span class="n">end2</span><span class="p">)</span>
        <span class="n">reg</span><span class="p">[</span><span class="n">k</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">start2</span><span class="o">++</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
        <span class="n">arr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">reg</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">merge_sort</span><span class="p">(</span><span class="kt">int</span> <span class="n">arr</span><span class="p">[],</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">reg</span><span class="p">[</span><span class="n">len</span><span class="p">];</span>
    <span class="n">merge_sort_recursive</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">reg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法分析-6">算法分析</h3>

归并排序的

<ul>
  <li>最好时间复杂度为：$O(nlog(n))$</li>
  <li>最坏时间复杂度为：$O(nlog(n))$</li>
  <li>平均时间复杂度为：$O(nlog(n))$</li>
  <li>是否稳定：稳定</li>
  <li>辅助空间：$O(n)$</li>
</ul>

<h2 id="基数排序">基数排序</h2>

基数排序是很优雅的排序，它的基本过程是：

<ol>
  <li>将所有数字补成相同长度，如果长度不够则补0</li>
  <li>从最低位开始，在第$i$位进行以下过程
    <ol>
      <li>扫描整个序列，将第$i$位为$k$的数放到编号为$k$的桶中</li>
      <li>按$0$到$9$的顺序把桶中的元素依次放回序列中</li>
      <li>如果$i$大于$n$，结束</li>
    </ol>
  </li>
</ol>

这样以后，整个序列就排好序了。可以看到，时间复杂度为$O(kn)$，其中$k$是最大位数。还要花费$O(n)$的额外空间。

实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 这段代码来自维基百科 */</span>
<span class="kt">void</span> <span class="nf">radixsort</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="c1">//基数排序</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">maxbit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span> <span class="c1">//计数器</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">radix</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="c1">//进行d次排序</span>
    <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//每次分配前清空计数器</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">radix</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">//统计每个桶中的记录数</span>
            <span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
            <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">];</span> <span class="c1">//将tmp中的位置依次分配给每个桶</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="c1">//将所有桶中记录依次收集到tmp中</span>
        <span class="p">{</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="n">radix</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">;</span>
            <span class="n">tmp</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="n">count</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span><span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="c1">//将临时数组的内容复制到data中</span>
            <span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">radix</span> <span class="o">=</span> <span class="n">radix</span> <span class="o">*</span> <span class="mi">10</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">delete</span> <span class="p">[]</span><span class="n">tmp</span><span class="p">;</span>
    <span class="k">delete</span> <span class="p">[]</span><span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="算法分析-7">算法分析</h3>

归并排序的

<ul>
  <li>最好时间复杂度为：$O(kn)$</li>
  <li>最坏时间复杂度为：$O(kn)$</li>
  <li>平均时间复杂度为：$O(kn)$</li>
  <li>是否稳定：稳定</li>
  <li>辅助空间：$O(n)$</li>
</ul>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2019/12/22/Graph/">
                                    <p class="title is-2">数据结构 -- 图 -- 笔记 <span class="tag is-white is-pulled-right"><small>December 22, 2019</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
  <li><a href="#%e5%9b%be%e7%9a%84%e5%ae%9a%e4%b9%89">图的定义</a>
    <ul>
      <li><a href="#%e5%9b%be%e7%9a%84%e4%b8%80%e8%88%ac%e5%ae%9a%e4%b9%89">图的一般定义</a></li>
      <li><a href="#%e5%87%a0%e7%a7%8d%e7%89%b9%e6%ae%8a%e7%9a%84%e5%9b%be">几种特殊的图</a></li>
      <li><a href="#%e8%bf%9e%e9%80%9a%e6%80%a7">连通性</a>
        <ul>
          <li><a href="#%e6%97%a0%e5%90%91%e5%9b%be">无向图</a></li>
          <li><a href="#%e6%9c%89%e5%90%91%e5%9b%be">有向图</a></li>
        </ul>
      </li>
      <li><a href="#%e7%94%9f%e6%88%90%e6%a0%91">生成树</a></li>
    </ul>
  </li>
  <li><a href="#%e5%9b%be%e7%9a%84%e5%ad%98%e5%82%a8%e8%a1%a8%e7%a4%ba">图的存储表示</a>
    <ul>
      <li><a href="#adt-%e4%b8%8e-%e6%8a%bd%e8%b1%a1%e7%b1%bb%e6%8e%a5%e5%8f%a3">ADT 与 抽象类接口</a></li>
      <li><a href="#%e9%80%86%e9%82%bb%e6%8e%a5%e8%a1%a8">（逆）邻接表</a>
        <ul>
          <li><a href="#%e9%82%bb%e6%8e%a5%e8%a1%a8">邻接表</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#%e5%9b%be%e4%b8%8a%e7%9a%848%e7%a7%8d%e6%b3%9b%e5%9e%8b%e7%ae%97%e6%b3%95">图上的8种泛型算法</a>
    <ul>
      <li><a href="#%e5%89%8d%e8%a8%80-1">前言</a></li>
      <li><a href="#%e5%9b%be%e7%9a%84%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95">图的深度优先搜索算法</a></li>
      <li><a href="#%e5%9b%be%e7%9a%84%e5%b9%bf%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e7%ae%97%e6%b3%95">图的广度优先搜索算法</a></li>
      <li><a href="#%e7%94%a8%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e6%9c%89%e7%8e%af">用深度优先搜索判断是否有环</a></li>
      <li><a href="#%e7%94%a8%e6%b7%b1%e5%ba%a6%e4%bc%98%e5%85%88%e6%90%9c%e7%b4%a2%e8%bf%9b%e8%a1%8c%e6%8b%93%e6%89%91%e6%8e%92%e5%ba%8f">用深度优先搜索进行拓扑排序</a></li>
      <li><a href="#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91--prim%e7%ae%97%e6%b3%95">最小生成树–Prim算法</a></li>
      <li><a href="#%e6%9c%80%e5%b0%8f%e7%94%9f%e6%88%90%e6%a0%91----kruskal%e7%ae%97%e6%b3%95">最小生成树 – Kruskal算法</a></li>
      <li><a href="#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e7%ae%97%e6%b3%95----dijkstra%e7%ae%97%e6%b3%95">最短路径算法 – Dijkstra算法</a></li>
      <li><a href="#%e6%9c%80%e7%9f%ad%e8%b7%af%e5%be%84%e7%ae%97%e6%b3%95----flyod%e7%ae%97%e6%b3%95">最短路径算法 – Flyod算法</a></li>
    </ul>
  </li>
  <li><a href="#%e4%b8%a4%e4%b8%aa%e4%b8%93%e7%94%a8%e7%ae%97%e6%b3%95----%e9%82%bb%e6%8e%a5%e8%a1%a8%e4%b8%8a%e7%9a%84%e5%a0%86%e4%bc%98%e5%8c%96dijkstra%e7%ae%97%e6%b3%95%e5%92%8cprim%e7%ae%97%e6%b3%95">两个专用算法 – 邻接表上的堆优化Dijkstra算法和Prim算法</a></li>
</ul>

<h2 id="前言">前言</h2>
这一章，我们学习了图这种数据结构。本笔记主要完成了以下工作：
<ul>
  <li>总结了图的各种知识</li>
  <li>实现了邻接矩阵和邻接表定义的Graph类</li>
  <li>实现了IndexMapping 类，使得下面的泛型图算法成为可能（把元素内容和标记分开，下面的泛型图算法实现在整形标记上）</li>
  <li>实现了8个泛型图算法，并进行了简单测试，分别是
    <ul>
      <li>DFS 深度优先搜索</li>
      <li>BFS 广度优先搜索</li>
      <li>通过深度优先搜索判断图中是否有环</li>
      <li>通过深度优先搜索进行拓扑排序</li>
      <li>Prim最小生成树算法</li>
      <li>Kruskal最小生成树算法</li>
      <li>Dijskstra 最短路径算法</li>
      <li>Floyd 最短路径算法</li>
    </ul>
  </li>
  <li>实现了两个专用图算法，分别是
    <ul>
      <li>邻接表上的堆优化Dijkstra算法</li>
      <li>邻接表上的堆优化Prim算法</li>
    </ul>
  </li>
  <li>给出了几个简单的图论算法应用</li>
</ul>

<h2 id="图的定义">图的定义</h2>
<h3 id="图的一般定义">图的一般定义</h3>
<blockquote>
  一张图 $G$ 是一个二元组$(V,E)$，其中$V$称为顶点集，$E$称为边集。它们亦可写成$V(G)$和$E(G)$。 ${\displaystyle E}$的元素是一个二元组数对，用${\displaystyle (x,y)}$表示，其中${\displaystyle x,y\in V}x,y \in V$。
</blockquote>

<ul>
  <li>从定义中可以看到，存储结构的设计主要在于表征此集合关系</li>
  <li>可以从边有无方向、是否允许重边（两条或多条边的起止点相同）、是否允许环、边是否带权将图分为多种</li>
  <li>值得一提的是，树是连通无回路的图</li>
</ul>

<h3 id="几种特殊的图">几种特殊的图</h3>
<ul>
  <li>n-阶完全图(complete graph)$K_{n}$ − $n$个顶点两两之间都有一条边，每个顶点的度数都$n−1$ ◦ 边的总数目为$n(n−1)/2$.</li>
  <li>二部图 - 顶点集可以划分为两个集合$v_{i}, v_{j}$，且$v_{i}$与$v_{j}$之间没有边</li>
</ul>

<h3 id="连通性">连通性</h3>
<h4 id="无向图">无向图</h4>
<ul>
  <li>一个无向图是联通的，当且仅当每两个点都是联通的。
    <ul>
      <li>两个点是联通的，当且仅当他们之间有路径。</li>
    </ul>
  </li>
  <li>如果一个图不是联通的，那么它的最大联通子图就叫做联通分量。</li>
  <li>可以直观地看到，一个无向图联通的最小边数为$n - 1$</li>
</ul>

<h4 id="有向图">有向图</h4>
<ul>
  <li>一个有向图是弱联通的，当且仅当把它对应的无向图是联通的。</li>
  <li>一个有向图是强联通的，当且仅当每两个点都是联通的。</li>
  <li>可以直观地看到，一个有向图强联通的最小边数为$n$</li>
</ul>

<h3 id="生成树">生成树</h3>
<ul>
  <li>一般仅研究无向图的生成树（有向图的“生成树”实际上不能看作树，有术语“最小树形图”来描述此结构，这里不表）</li>
  <li>无向图$G(V, E)$的生成树是一颗含有所有顶点$V$的，边属于$E$的树。</li>
  <li>可以看作$G$的极小联通子图。</li>
  <li>生成树是STP协议的基础。STP 协议就是通过构造网络拓扑图中的生成树来解决环路问题，具体协议内容参见IEEE 802.1D</li>
</ul>

<h2 id="图的存储表示">图的存储表示</h2>
图的存储结构主要分为三种：
<ul>
  <li>（逆）邻接表</li>
  <li>邻接矩阵</li>
  <li>关联矩阵</li>
</ul>

教师还讲述了两种：
<ul>
  <li>有向图的十字链表</li>
  <li>无向图的邻接多重表</li>
</ul>

下面只研究（逆）邻接表和邻接矩阵, 并实现我们自己的Graph C++类。但在此之前，我们首先要知道一个Graph类需要有哪些方法。

<h3 id="adt-与-抽象类接口">ADT 与 抽象类接口</h3>
<ul>
  <li>ADT Name: Graph
    <ul>
      <li>Description: …</li>
      <li>Invariants:
        <ol>
          <li>Empty graph: number of vertices is 0; number of edges is 0.</li>
          <li>Self-loops are not allowed.</li>
        </ol>
      </li>
      <li>Attributes:
        <ul>
          <li>number of vertices</li>
          <li>number of edges.</li>
        </ul>
      </li>
      <li>Operations:
        <ul>
          <li>Graph() …</li>
          <li>addVertex(Vertex v) …</li>
          <li>addEdge(Vertex v_1, Vertex v_2) …</li>
          <li>removeVertex(Vertex v) …</li>
          <li>removeVertex(Vertex v) …</li>
          <li>removeEdge(Vertex v_1, Vertex v_2) …</li>
          <li>getNeighbors(Vertex v)
            <ul>
              <li>returns: a collection containing the Vertices incident on v</li>
            </ul>
          </li>
          <li>getNumberOfVertices()</li>
          <li>getNumberOfEdges()</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

基于以上的ADT，我们写一个抽象类Graph():

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Vertex</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Graph</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">removeVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">removeEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span> <span class="o">&amp;</span> <span class="n">v_2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">getNeighbors</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="n">getNumberOfVertices</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">uint32_t</span> <span class="n">getNumberOfEdges</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">clearGraph</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<h3 id="逆邻接表">（逆）邻接表</h3>
<h4 id="邻接表">邻接表</h4>
邻接表是指把图存到一个线性表中，这个线性表的每一个元素都是一个链表，链表的第一个元素是一个图中的顶点，其他元素是和这个顶点相邻的顶点。线性表中的元素不重复地覆盖所有图中的顶点。
示意图：

<img src="./pic/2.png" />

从描述中可以看出，这个结构实际上用于有向图。
这个结构实现起来很简单，如下所示：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">stdVertex</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">value</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">stdVertex</span><span class="p">()</span> <span class="p">{</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
	<span class="n">stdVertex</span><span class="p">(</span><span class="n">value</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">bool</span> <span class="k">operator</span> <span class="o">==</span><span class="p">(</span><span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/*
 * here we use Vertex class as node,
 * to correctly implement this class, you should follow these rules:
 * 1. overload =(), or don't use anything could cause deep copy/shallow copy problem.
 * 2. implement these methods:
 *    1. getValue()
 */</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;,</span> <span class="k">class</span> <span class="nc">VertexInner</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">ListGraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Graph</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">VertexInner</span><span class="o">&gt;</span> <span class="n">vec_list</span><span class="p">;</span>
		<span class="n">vec_list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">VertexInner</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vec_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}});</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"v_1 is not a vertex in list!"</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">v_2</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">removeVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">bool</span> <span class="n">hit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="n">hit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">begin</span><span class="p">();</span> <span class="n">j</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">j</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">erase</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">else</span> <span class="p">{</span> <span class="o">++</span><span class="n">j</span><span class="p">;</span> <span class="p">}</span>
				<span class="p">}</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hit</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"can't find vertex!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">removeEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* find v_1 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">begin</span><span class="p">();</span> <span class="n">j</span> <span class="o">!=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">j</span><span class="p">)</span> <span class="o">==</span> <span class="n">v_2</span><span class="p">)</span> <span class="p">{</span>
						<span class="cm">/* find v_2 */</span>
						<span class="n">j</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">erase</span><span class="p">(</span><span class="n">j</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">END</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="n">j</span><span class="o">++</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"can't find Edge!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
	<span class="nl">END:</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">getNeighbors</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">adjList</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span> <span class="n">i</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="p">}});</span>

		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">i</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">j</span><span class="p">);</span> <span class="p">});</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">uint32_t</span> <span class="n">getNumberOfVertices</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="p">}</span>
	
	<span class="kt">uint32_t</span> <span class="n">getNumberOfEdges</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="n">sum</span><span class="p">](</span><span class="k">auto</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">i</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="p">});</span>
		<span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">clearGraph</span> <span class="p">()</span> <span class="p">{</span>
		<span class="n">adjList</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">protected:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">VertexInner</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">adjList</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

这个时候问题来了，在这个设计下，我们如何实现带权图呢？

呵呵，这个问题我在设计之初就想到了。

首先我们考虑，只要将VertexInner类的参数改成下面这个类，实际上就实现了带权图：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ValuedVertex</span> <span class="o">:</span> <span class="k">public</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cm">/* edge_value represents the value of edge 
	 * between the former vertex and that vertex
	 * if this vertex is the first vertex, 
	 * then edge_value MUST be INT_MAX
	 */</span>
	<span class="kt">uint32_t</span> <span class="n">edge_value</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

那么，我们只要继承一下ListGraph，再重载一个addEdge方法就可以了。

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ValuedListGraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ListGraph</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ValuedVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">Vertex</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span> <span class="n">v_2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">_value</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
			<span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span><span class="k">if</span> <span class="p">(</span><span class="n">j</span><span class="p">.</span><span class="n">front</span><span class="p">()</span> <span class="o">==</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}});</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">(</span><span class="s">"v_1 is not a vertex in list!"</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ValuedVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">vex</span><span class="p">(</span><span class="n">v_2</span><span class="p">);</span>
		<span class="n">vex</span><span class="p">.</span><span class="n">edge_value</span> <span class="o">=</span> <span class="n">_value</span><span class="p">;</span> 
		<span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">vex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

这样邻接表就实现好了。邻接矩阵的实现其实更加简单：

由于邻接矩阵天生就适合带权图（矩阵的元素是数），所以我们直接实现为带权图。
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define UNCONNECTED INT_MAX
</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">MatrixGraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IndexGraph</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">MatrixGraph</span><span class="p">(){}</span>
	<span class="kt">void</span> <span class="n">addVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* add colunm */</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">push_back</span><span class="p">(</span><span class="n">UNCONNECTED</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* add row */</span>
		<span class="kt">size_t</span> <span class="n">vec_size</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="n">vec_size</span><span class="p">,</span> <span class="n">UNCONNECTED</span><span class="p">);</span>
		<span class="n">vec</span><span class="p">[</span><span class="n">vec_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">matrix</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">vec</span><span class="p">);</span>

		<span class="k">this</span><span class="o">-&gt;</span><span class="n">addVertexToMap</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
	<span class="p">}</span>
	
	<span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">)</span> <span class="p">{</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="p">}</span>

	<span class="kt">void</span> <span class="n">addEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">v_1</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">j</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">v_2</span><span class="p">);</span>
		<span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">removeVertex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">removeEdge</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_1</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v_2</span><span class="p">){}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">getNeighbors</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">i</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">_if_connected</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">j</span><span class="p">)));</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">uint32_t</span> <span class="n">getNumberOfVertices</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="kt">uint32_t</span> <span class="n">getNumberOfEdges</span><span class="p">()</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">_if_connected</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">clearGraph</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">matrix</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">protected:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span> <span class="n">matrix</span><span class="p">;</span>
	
	<span class="kt">bool</span> <span class="n">_if_connected</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index_1</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">index_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">matrix</span><span class="p">[</span><span class="n">index_1</span><span class="p">][</span><span class="n">index_2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UNCONNECTED</span> <span class="o">&amp;&amp;</span> <span class="n">index_1</span> <span class="o">!=</span> <span class="n">index_2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_get_neighbors</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">_if_connected</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">int</span> <span class="n">_get_value</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">pos_1</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">pos_2</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">matrix</span><span class="p">[</span><span class="n">pos_1</span><span class="p">][</span><span class="n">pos_2</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexEdge</span><span class="o">&gt;</span> <span class="n">_get_all_edges</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexEdge</span><span class="o">&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">matrix</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">UNCONNECTED</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">IndexEdge</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">};</span>

</code></pre></div></div>

<h2 id="图上的8种泛型算法">图上的8种泛型算法</h2>

<h3 id="前言-1">前言</h3>

我们实现了8种泛型图算法。“泛型”一词的意思是，这算法不与特定具体实现相关。只要特定具体实现实现了我们在算法中用到的各种函数，就可以使用该算法。

这是怎么做到的呢？这里采用了继承的方法。

我们首先将图中的每个元素与序号（一个整数）建立映射关系，下面的算法就都使用序号进行操作。这个行为被封装为IndexMapping类：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IndexMapping</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">uint32_t</span> <span class="n">getIndex</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">valueToIndex</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">value</span> <span class="n">getValue</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="kt">uint32_t</span> <span class="n">addVertexToMap</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">val</span><span class="p">);</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">valueToIndex</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span>
			<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">uint32_t</span> <span class="n">removeVertexFromMap</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">index_v</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">indexToValue</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index_v</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">valueToIndex</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">valueToIndex</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">second</span> <span class="o">==</span> <span class="n">index_v</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">=</span> <span class="n">valueToIndex</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">index_v</span><span class="p">)</span> <span class="p">{</span>
					<span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">second</span><span class="o">--</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">index_v</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">valueToIndex</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">indexToValue</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

然后，用IndexGraph继承IndexMapping类和Graph类：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;</span> <span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">IndexGraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Graph</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span><span class="p">,</span> <span class="k">public</span> <span class="n">IndexMapping</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span> 
</code></pre></div></div>

最后，用一个具体类继承IndexGraph类：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">value</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Vertex</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="n">value</span><span class="p">&gt;,</span> <span class="k">class</span> <span class="nc">VertexInner</span> <span class="o">=</span> <span class="n">stdVertex</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;&gt;</span>
<span class="k">class</span> <span class="nc">ListGraph</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IndexGraph</span><span class="o">&lt;</span><span class="n">value</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span>
</code></pre></div></div>

有开发经验的人恐怕立刻就会想到我要做什么了。现在只要在IndexGraph类中实现基于整形标记的各种图上算法，各个具体子类就会自动地获得运行这些算法的能力！

下面，我们就来实际地看一下这些算法。

注：所有算法都是IndexGraph的成员函数，public, private, protected是c++成员函数可见性的声明。

<h3 id="图的深度优先搜索算法">图的深度优先搜索算法</h3>
<blockquote>
  深度优先搜索算法（英语：Depth-First-Search，DFS）是一种用于遍历或搜索树或图的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。
我们实现如下：
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">public:</span>
	<span class="cm">/* Depth First Search */</span>
	<span class="kt">void</span> <span class="nf">DFS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_something</span><span class="p">,</span> <span class="n">Vertex</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">help_vec_8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">start_index</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">STD_DFS</span><span class="p">(</span><span class="n">do_something</span><span class="p">,</span> <span class="n">start_index</span><span class="p">);</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="kt">void</span> <span class="nf">STD_DFS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_something</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">vertex</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">do_something</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">vertex</span><span class="p">)));</span>
		<span class="n">help_vec_8</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">vertex</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">STD_DFS</span><span class="p">(</span><span class="n">do_something</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div>
这里用到了一个函数_get_neighbors(uint32_t v)这个函数会返所有与v相邻的点。声明为：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">_get_neighbors</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="图的广度优先搜索算法">图的广度优先搜索算法</h3>
<blockquote>
  广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。
我们实现如下：
</blockquote>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">public:</span>
	<span class="kt">void</span> <span class="nf">BFS</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">(</span><span class="n">Vertex</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">do_something</span><span class="p">,</span> <span class="n">Vertex</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">_start</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">help_vec_8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">help_quene</span><span class="p">;</span>
		<span class="n">help_quene</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">_start</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(;</span><span class="o">!</span><span class="n">help_quene</span><span class="p">.</span><span class="n">empty</span><span class="p">();)</span> <span class="p">{</span>
			<span class="kt">uint32_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">help_quene</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
			<span class="n">help_quene</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">help_vec_8</span><span class="p">[</span><span class="n">now</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">do_something</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">now</span><span class="p">)));</span>
			<span class="k">auto</span> <span class="n">neighbors</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">now</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">neighbors</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">help_quene</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="用深度优先搜索判断是否有环">用深度优先搜索判断是否有环</h3>
这个算法很简单，大意是将每个点分为三种状态:

{已遍历，未遍历，遍历中}

如果出现了一个{遍历中}的点被再次遍历的情况，那么有环，反之无环。

实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">public:</span>
<span class="cp">#define RED 1
#define WHITE 0
#define GREEN -1
</span>	<span class="cm">/* if the graph have a ring */</span>
	<span class="kt">bool</span> <span class="nf">ifRing</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">help_vec_8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">WHITE</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">RING_DFS</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">ring_hit</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
	<span class="kt">void</span> <span class="nf">RING_DFS</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ring_hit</span> <span class="o">==</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">RED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ring_hit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">help_vec_8</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">RED</span><span class="p">;</span>
			<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">GREEN</span><span class="p">)</span>
				<span class="p">{</span>
					<span class="n">RING_DFS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">help_vec_8</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">GREEN</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">bool</span> <span class="n">ring_hit</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="用深度优先搜索进行拓扑排序">用深度优先搜索进行拓扑排序</h3>
拓扑排序有一种不使用深度优先搜索、基于引用计数的算法，这里没有实现。我们实现的是稍微不太好理解的基于深度优先搜索的算法。

这算法简单来说，就是基于这样一个事实
<blockquote>
  在深度优先搜索中，如果一个点的搜索完成，那么它后继的所有点的搜索必定已经完成。
</blockquote>

这个事实告诉我们，如果在一个点搜索完成时将这个点压入结果栈中，那么这个结果栈的顺序必然是一个拓扑排序序列的反序列
实现如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">public:</span>
<span class="cm">/* Topological Sort */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">TopoSort</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ifRing</span><span class="p">())</span> <span class="p">{</span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">"can't sort because of ring!"</span><span class="p">);</span> <span class="p">}</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">help_vec_8</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SORT_DFS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">sort_result_vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">sort_result_vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">result_vec</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">sort_result_vec</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">result_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">)));</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">result_vec</span><span class="p">;</span>
	<span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
		<span class="kt">void</span> <span class="nf">SORT_DFS</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">index</span><span class="p">){</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">neighbor</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_neighbors</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="n">neighbor</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">help_vec_8</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">SORT_DFS</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">sort_result_vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sort_result_vec</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="最小生成树prim算法">最小生成树–Prim算法</h3>
Prim 算法和Dijkstra 算法有些相似，其基本思想是选点，也就是将整个图划分为两个集合

<ul>
  <li>已选出的点</li>
  <li>未选出的点</li>
</ul>

然后每次都在未选出点集合中选出与已选出的点集合距离最近的点。选择n次后，算法结束。

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">Prim</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">add_list</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">INT32_MAX</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">distance</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">INT32_MAX</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result_vec</span><span class="p">;</span>

		<span class="n">distance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">father</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INT32_MAX</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">distance</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span><span class="p">)</span><span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">add_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">pos</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
					<span class="n">min</span> <span class="o">=</span> <span class="n">distance</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">add_list</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">((</span><span class="n">distance</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">add_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
					<span class="n">father</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
					<span class="n">distance</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">add_list</span><span class="p">.</span><span class="n">size</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Vertex</span> <span class="n">v_1</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">Vertex</span> <span class="n">v_2</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
			<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">pair</span><span class="p">(</span><span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">);</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="最小生成树--kruskal算法">最小生成树 – Kruskal算法</h3>
这个算法的基本思想是选边。将这个图中所有的边划分为两个集合：

<ul>
  <li>已选出</li>
  <li>未选出</li>
</ul>

然后每一次选择时，选择未选出集合中边权最小的边加入已选出集合，然后测试，若加入后形成了环，则删掉这个边，再选择次小边，直到加入后不形成环为止。
这样选择N - 1次后，算法结束。

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">Kruskal</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IndexEdge</span><span class="o">&gt;</span> <span class="n">vec</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_all_edges</span><span class="p">();</span>
		<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">vec</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
		<span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">vec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
		<span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0U</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">IndexDSet</span><span class="o">&lt;&gt;</span> <span class="n">set</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">());</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;)</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">v_1</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">edge</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
			<span class="k">auto</span> <span class="n">v_2</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">).</span><span class="n">edge</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
			<span class="cm">/* retrun true means we don't have a ring after merge */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">.</span><span class="n">mergeTwoSet</span><span class="p">(</span><span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span><span class="p">(</span> 
					<span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">v_1</span><span class="p">)),</span> <span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">v_2</span><span class="p">))));</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

这里使用了并查集这种数据结构来判断是否有环。

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define IndexType uint32_t
</span><span class="k">class</span> <span class="nc">DSNode</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">IndexType</span> <span class="n">getParent</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">void</span> <span class="n">setParent</span><span class="p">(</span><span class="n">IndexType</span><span class="o">&amp;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">protected:</span>
	<span class="n">IndexType</span> <span class="n">parent</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">Node</span> <span class="o">=</span> <span class="n">DSNode</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">IndexDSet</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">IndexDSet</span><span class="p">(){}</span>
	<span class="n">IndexDSet</span><span class="p">(</span><span class="n">IndexType</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">this</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setParent</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">IndexType</span> <span class="n">getParent</span><span class="p">(</span><span class="n">IndexType</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">[</span><span class="n">target</span><span class="p">].</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="n">target</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">getParent</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">[</span><span class="n">target</span><span class="p">].</span><span class="n">getParent</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="kt">bool</span> <span class="n">ifSame</span><span class="p">(</span><span class="n">IndexType</span> <span class="n">ele_a</span><span class="p">,</span> <span class="n">IndexType</span> <span class="n">ele_b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">IndexType</span> <span class="n">parent_a</span> <span class="o">=</span> <span class="n">getParent</span><span class="p">(</span><span class="n">ele_a</span><span class="p">);</span>
		<span class="n">IndexType</span> <span class="n">parent_b</span> <span class="o">=</span> <span class="n">getParent</span><span class="p">(</span><span class="n">ele_b</span><span class="p">);</span>
		
		<span class="k">return</span> <span class="n">parent_a</span> <span class="o">==</span> <span class="n">parent_b</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="kt">bool</span> <span class="n">mergeTwoSet</span><span class="p">(</span><span class="n">IndexType</span> <span class="n">ele_a</span><span class="p">,</span> <span class="n">IndexType</span> <span class="n">ele_b</span><span class="p">){</span>
		<span class="n">IndexType</span> <span class="n">parent_a</span> <span class="o">=</span> <span class="n">getParent</span><span class="p">(</span><span class="n">ele_a</span><span class="p">);</span>
		<span class="n">IndexType</span> <span class="n">parent_b</span> <span class="o">=</span> <span class="n">getParent</span><span class="p">(</span><span class="n">ele_b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent_a</span> <span class="o">==</span> <span class="n">parent_b</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">this</span><span class="o">-&gt;</span><span class="n">vec</span><span class="p">[</span><span class="n">parent_a</span><span class="p">].</span><span class="n">setParent</span><span class="p">(</span><span class="n">parent_b</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">protected:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="最短路径算法--dijkstra算法">最短路径算法 – Dijkstra算法</h3>
Dijkstra 算法的基本思想是，将所有的点分为两类：

<ul>
  <li>已选出</li>
  <li>未选出</li>
</ul>

使用一个集合存储所有点与源点的距离；

每次都选出未选出集合中，距离源点（Prim算法中是已选出点的集合）最近的点，然后更新和这个点邻接的所有点与源点的距离。

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">Dijkstra</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortest</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">INT_MAX</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">mark</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="kt">bool</span> <span class="n">end</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">shortest</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">father</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
		<span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">end</span><span class="p">;)</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">min</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shortest</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">end</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="o">&amp;&amp;</span> <span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pos</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
					<span class="n">min</span> <span class="o">=</span> <span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">mark</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shortest</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">_get_value</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">shortest</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mark</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
					<span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">shortest</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">+</span> <span class="n">_get_value</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<h3 id="最短路径算法--flyod算法">最短路径算法 – Flyod算法</h3>
这是一个很有趣的算法，也可以用来求传递闭包，这里不过多解释：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">Floyd</span><span class="p">(</span><span class="n">Vertex</span> <span class="n">v_1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">auto</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> 
			<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">INT_MAX</span><span class="p">));</span>
		
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">_get_value</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span> <span class="o">||</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">INT_MAX</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="p">{</span>
						<span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">temp</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">auto</span> <span class="n">v</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">v_1</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">temp_node</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">temp</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">temp_node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>

<h2 id="两个专用算法--邻接表上的堆优化dijkstra算法和prim算法">两个专用算法 – 邻接表上的堆优化Dijkstra算法和Prim算法</h2>
为什么要进行堆优化？可能有人会说是因为要实现$Elog(V)$的复杂度，但对我们这种算法初学者来说，速度不是学习的重点。

实际上，这是来源于我们对Dijkstra算法的实现很不自然：

<blockquote>
  我们使用了一个vector来存储最短路径，又用了一个vector来存储标记，如果一个点被选出了，就打上标记，下一次就不选择它。
</blockquote>

这实际上是把已选出和未选出的点都放在一起，然后用标记来区分它们。这样很不自然而且很容易出错。

那么可不可以专门建立一个未选出点的集合，一开始有所有点，每选出一个点就删除它呢？这是可以的，但需要二叉搜索树等数据结构的支持，可以用std::set实现这个想法。

但这里不用这种办法，而是使用另一种办法：令未选出集合一开始为空，然后动态地添加和删除。

也就是说，首先把源点加入集合中，然后使用一个循环：

当集合非空时，每次取出集合中距离源点最小的元素，然后用与这个元素相接的元素更新结果集，同时将这些元素加入这个集合。

其中“取出距离最小的元素”恰恰就是一个小顶堆的操作。所以这里使用 std::priority_queue 作为这个集合的实现。

但是这里还有一个问题，如何更新堆中的元素呢？我们无法用std::priority_queue更新，因为它没有顺序迭代器。

这个问题的答案是不需要做任何更新，而是无脑地加入。因为 <em>距离源点最小的元素会被最先选出</em> 所以即使有两个重复的元素，也是我们需要的、距离源点较近的元素先被选出，而当距离源点较远的点被选出时，<em>结果集已经被距离源点较近的点更新过了</em>，对所有与它邻接的点，都不会触发更新条件，也就对结果没有影响了。
实现代码如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">P</span><span class="p">;</span>
	<span class="cm">/* only when use listGraph, fastDijkstra is faster than normal Dijkstra */</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">fastDijkstra</span><span class="p">(</span><span class="n">Vertex</span><span class="o">&amp;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint32_t</span><span class="o">&gt;</span> <span class="n">father</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="mh">0xffffffff</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shortest</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">INT_MAX</span><span class="p">);</span>

		<span class="c1">// pair.first means index, pair.second means distance</span>
		<span class="k">auto</span> <span class="n">cmp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">,</span> <span class="k">auto</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">};</span>
		<span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span> <span class="o">&lt;</span> <span class="n">P</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span><span class="o">&gt;&gt;</span> <span class="n">que</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>

		<span class="k">auto</span> <span class="n">start_index</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">start_index</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="n">shortest</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">father</span><span class="p">[</span><span class="n">start_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">start_index</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">que</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">que</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
			<span class="n">que</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

			<span class="kt">int</span> <span class="n">distance_now</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">now</span><span class="p">.</span><span class="n">first</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">edge_value</span> <span class="o">+</span> <span class="n">distance_now</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">edge_value</span> <span class="o">+</span> <span class="n">distance_now</span><span class="p">;</span>
					<span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
					<span class="n">que</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">]));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">PathNode</span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">(</span><span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">father</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="n">Vertex</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">shortest</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>
Prim算法同理，只不过这时需要打上标记（因为是无向图，不打上标记的话会重复选择）：
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">fastPrim</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">temp_edge</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getNumberOfVertices</span><span class="p">(),</span> <span class="n">temp_edge</span><span class="p">(</span><span class="mh">0xfffffff</span><span class="p">,</span> <span class="n">INT32_MAX</span><span class="p">));</span>
		<span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		
		<span class="k">auto</span> <span class="n">cmp</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">i</span><span class="p">,</span> <span class="k">auto</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">.</span><span class="n">second</span><span class="p">;</span> <span class="p">};</span>
		<span class="n">std</span><span class="o">::</span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">P</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">P</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">pq</span><span class="p">(</span><span class="n">cmp</span><span class="p">);</span>

		<span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">auto</span> <span class="n">now</span> <span class="o">=</span> <span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
			<span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
			<span class="n">vec</span><span class="p">[</span><span class="n">now</span><span class="p">.</span><span class="n">first</span><span class="p">].</span><span class="n">mark</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">:</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">adjList</span><span class="p">[</span><span class="n">now</span><span class="p">.</span><span class="n">first</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">].</span><span class="n">value</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">.</span><span class="n">edge_value</span> <span class="o">&amp;&amp;</span> <span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">].</span><span class="n">mark</span> <span class="o">==</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">].</span><span class="n">father</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
					<span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">].</span><span class="n">value</span> <span class="o">=</span> <span class="n">i</span><span class="p">.</span><span class="n">edge_value</span><span class="p">;</span>
					<span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">P</span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">val</span><span class="p">,</span> <span class="n">i</span><span class="p">.</span><span class="n">edge_value</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;&gt;</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1u</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Vertex</span> <span class="n">v_1</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
			<span class="n">Vertex</span> <span class="n">v_2</span><span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">father</span><span class="p">));</span>
			<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Vertex</span><span class="o">&gt;</span> <span class="n">pair</span><span class="p">(</span><span class="n">v_1</span><span class="p">,</span> <span class="n">v_2</span><span class="p">);</span>
			<span class="n">ret</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pair</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
</code></pre></div></div>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2019/12/10/find/">
                                    <p class="title is-2">数据结构 -- 查找 -- 笔记 <span class="tag is-white is-pulled-right"><small>December 10, 2019</small></span></p>
                                    <p class="subtitle"><small><ul>
  <li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
  <li><a href="#%e6%9f%a5%e6%89%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89">查找的基本定义</a></li>
  <li><a href="#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e7%9a%84%e5%88%86%e6%9e%90%e5%92%8c%e8%ae%be%e8%ae%a1">查找算法的分析和设计</a></li>
  <li><a href="#%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">顺序查找算法</a></li>
  <li><a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91">二分查找算法与二叉查找树</a></li>
  <li><a href="#%e5%88%86%e5%9d%97%e6%9f%a5%e6%89%be">分块查找</a></li>
  <li><a href="#%e5%a0%86%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97">堆/优先队列</a>
    <ul>
      <li><a href="#%e5%a0%86%e7%9a%84%e6%a6%82%e5%bf%b5%e4%b8%8e%e5%ae%9e%e7%8e%b0">堆的概念与实现</a></li>
      <li><a href="#%e5%a0%86%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e5%81%9a%e4%bb%80%e4%b9%88">堆可以用来做什么？</a></li>
    </ul>
  </li>
  <li><a href="#%e6%95%a3%e5%88%97%e8%a1%a8">散列表</a>
    <ul>
      <li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9a%e4%b9%89">哈希表的定义</a></li>
      <li><a href="#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">哈希函数</a></li>
      <li><a href="#%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">碰撞处理</a></li>
      <li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0----%e6%88%91%e5%ae%9e%e7%8e%b0%e7%9a%84c%e7%89%88%e6%9c%ac">哈希表的实现 – 我实现的c++版本</a></li>
      <li><a href="#ruby%e4%b8%ad%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ae%9e%e7%8e%b0">Ruby中的哈希表实现</a>
        <ul>
          <li><a href="#sttable-%e7%9a%84%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">st_table 的哈希函数</a></li>
          <li><a href="#sttable%e7%9a%84%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">st_table的碰撞处理</a></li>
          <li><a href="#sttable%e7%9a%84%e6%89%a9%e5%ae%b9">st_table的扩容</a></li>
          <li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="前言">前言</h2>

这一章，我们学习了查找这种基本操作和堆、散列表这两种非常重要的数据结构。
本笔记主要完成了以下工作：

<ul>
  <li>总结了关于查找的各种知识点</li>
  <li>用ruby语言实现了一个简单的堆模块(这里的模块指module，是ruby中MIX_IN思想的主要实现模式，下面会做简短介绍)，并进行了简单测试</li>
  <li>用C++语言实现了一个简单的哈希表，并进行了简单测试</li>
  <li>讨论了ruby中哈希表的实现</li>
  <li>讨论了stl中std::find, std::binary_search等函数的实现</li>
</ul>

<h2 id="查找的基本定义">查找的基本定义</h2>

查找也可以视为搜索，wikipedia对搜索的定义是：
<blockquote>
  在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题域的搜索空间中计算的信息。
其实简单来说，查找就是“找东西”。
</blockquote>

而我们要找的“东西”，严格来说应该叫做“关键字”，或者更学术一些，叫做“键”。找到“键”之后，如果存在一个“键-值映射”，就可以得到其“值”。

<h2 id="查找算法的分析和设计">查找算法的分析和设计</h2>

查找算法实际上包含三个层次的问题：

<ol>
  <li>在什么数据结构上查找</li>
  <li>如何查找</li>
  <li>查找的效率如何</li>
</ol>

<h2 id="顺序查找算法">顺序查找算法</h2>

顺序查找是最朴素的查找，可以用在各种线性表上。在MSVC的stl中，我们有std::find函数实现这个算法：

<em>以下代码来自&lt;algorithm&gt;</em>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_InIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">&gt;</span>
<span class="n">_NODISCARD</span> <span class="kr">inline</span> <span class="n">_InIt</span> <span class="nf">find</span><span class="p">(</span><span class="n">_InIt</span> <span class="n">_First</span><span class="p">,</span> <span class="k">const</span> <span class="n">_InIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// find first matching _Val</span>
    <span class="n">_Adl_verify_range</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">);</span>
    <span class="n">_Seek_wrapped</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Find_unchecked</span><span class="p">(</span><span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_First</span><span class="p">),</span> <span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_Last</span><span class="p">),</span> <span class="n">_Val</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">_First</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

_Adl_verify_range是检查参数范围是否有效，_Seek_wrapped函数简单来说是把后一个参数的值赋给前一个参数：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_Ty</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">void</span> <span class="nf">_Seek_wrapped</span><span class="p">(</span><span class="n">_Ty</span><span class="o">*&amp;</span> <span class="n">_It</span><span class="p">,</span> <span class="n">_Ty</span><span class="o">*</span> <span class="k">const</span> <span class="n">_UIt</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">_It</span> <span class="o">=</span> <span class="n">_UIt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

实际查找过程在_Find_unchecked函数中：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_InIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">_InIt</span> <span class="nf">_Find_unchecked</span><span class="p">(</span><span class="k">const</span> <span class="n">_InIt</span> <span class="n">_First</span><span class="p">,</span> <span class="k">const</span> <span class="n">_InIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// find first matching _Val; choose optimization</span>
    <span class="c1">// activate optimization for pointers to (const) bytes and integral values</span>
    <span class="k">using</span> <span class="n">_Memchr_opt</span> <span class="o">=</span> <span class="n">bool_constant</span><span class="o">&lt;</span>
        <span class="n">is_integral_v</span><span class="o">&lt;</span><span class="n">_Ty</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">_Is_any_of_v</span><span class="o">&lt;</span><span class="n">_InIt</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="c1">//</span>
            <span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">signed</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;&gt;</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">_Find_unchecked1</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">,</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">_Memchr_opt</span><span class="p">{});</span>
<span class="p">}</span>
</code></pre></div></div>

而这个函数实际上又调用了_Find_unchecked1函数：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_InIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">&gt;</span>
<span class="kr">inline</span> <span class="n">_InIt</span> <span class="nf">_Find_unchecked1</span><span class="p">(</span><span class="n">_InIt</span> <span class="n">_First</span><span class="p">,</span> <span class="k">const</span> <span class="n">_InIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">false_type</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// find first matching _Val</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">_First</span> <span class="o">!=</span> <span class="n">_Last</span><span class="p">;</span> <span class="o">++</span><span class="n">_First</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">_First</span> <span class="o">==</span> <span class="n">_Val</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">_First</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

谢天谢地，_Find_unchecked1函数就是主要实现了。我们可以看到整个过程非常简单，就是顺序地查找整个表，如果找到了就退出。

由于模板的存在，在c++中，只要定义了迭代器，一个类就可以使用这个函数进行查找。这也正是对我们抽象描述–查找线性表–的抽象实现。

如果假设等概率，这个算法有

\(ASL_{success} = \frac{n + 1}{2}\)
\(ASL_{fail} = n + 1\)

<h2 id="二分查找算法与二叉查找树">二分查找算法与二叉查找树</h2>
从上面的分析可以看出，顺序查找查找一次的时间复杂度是$O(n)$的。可不可以有更好的效率呢？

如果假定顺序表是有序的，那么思考这样的结论：

<blockquote>
  如果待查询的元素大于 $array[floor(n / 2)]$，那么，它一定大于$array[0]$到$array[floor(n / 2) - 1]$的所有元素。
</blockquote>

这样一来，下一次的查询就可以不管这些元素，直接查询$array[floor(n/2) + 1]$到$array[n - 1]$这个区间了。

这实际上已经是一个递归算法了。这个算法的实现很简单，但我们还是来研究一下c++ stl中std::binary_search的实现：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FwdIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">&gt;</span>
<span class="n">_NODISCARD</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">binary_search</span><span class="p">(</span>
    <span class="n">_FwdIt</span> <span class="n">_First</span><span class="p">,</span> <span class="n">_FwdIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// test if _Val equivalent to some element, using operator&lt;</span>
    <span class="k">return</span> <span class="n">_STD</span> <span class="n">binary_search</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">,</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">less</span><span class="o">&lt;&gt;</span><span class="p">());</span>
<span class="p">}</span>
</code></pre></div></div>

下面这个binary_search是一个重载的函数，它才是真正用来实现的函数：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// FUNCTION TEMPLATE binary_search</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FwdIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Pr</span><span class="p">&gt;</span>
<span class="n">_NODISCARD</span> <span class="kr">inline</span> <span class="kt">bool</span> <span class="nf">binary_search</span><span class="p">(</span>
    <span class="n">_FwdIt</span> <span class="n">_First</span><span class="p">,</span> <span class="n">_FwdIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">_Pr</span> <span class="n">_Pred</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// test if _Val equivalent to some element, using _Pred</span>
    <span class="n">_Adl_verify_range</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">_UFirst</span>      <span class="o">=</span> <span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_First</span><span class="p">);</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">_ULast</span> <span class="o">=</span> <span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_Last</span><span class="p">);</span>
    <span class="n">_UFirst</span>           <span class="o">=</span> <span class="n">_STD</span> <span class="n">lower_bound</span><span class="p">(</span><span class="n">_UFirst</span><span class="p">,</span> <span class="n">_ULast</span><span class="p">,</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">_Pass_fn</span><span class="p">(</span><span class="n">_Pred</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">_UFirst</span> <span class="o">!=</span> <span class="n">_ULast</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">_Pred</span><span class="p">(</span><span class="n">_Val</span><span class="p">,</span> <span class="o">*</span><span class="n">_UFirst</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

这看起来并不是直接递归，而是使用了一个lower_bound函数。这个函数是干什么的呢？显然的，lower_bound的意思是下界，它定义如下：

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// FUNCTION TEMPLATE lower_bound</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">_FwdIt</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Ty</span><span class="p">,</span> <span class="k">class</span> <span class="nc">_Pr</span><span class="p">&gt;</span>
<span class="n">_NODISCARD</span> <span class="kr">inline</span> <span class="n">_FwdIt</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="n">_FwdIt</span> <span class="n">_First</span><span class="p">,</span> <span class="k">const</span> <span class="n">_FwdIt</span> <span class="n">_Last</span><span class="p">,</span> <span class="k">const</span> <span class="n">_Ty</span><span class="o">&amp;</span> <span class="n">_Val</span><span class="p">,</span> <span class="n">_Pr</span> <span class="n">_Pred</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// find first element not before _Val, using _Pred</span>
    <span class="n">_Adl_verify_range</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_Last</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">_UFirst</span>                <span class="o">=</span> <span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_First</span><span class="p">);</span>
    <span class="n">_Iter_diff_t</span><span class="o">&lt;</span><span class="n">_FwdIt</span><span class="o">&gt;</span> <span class="n">_Count</span> <span class="o">=</span> <span class="n">_STD</span> <span class="n">distance</span><span class="p">(</span><span class="n">_UFirst</span><span class="p">,</span> <span class="n">_Get_unwrapped</span><span class="p">(</span><span class="n">_Last</span><span class="p">));</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">_Count</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// divide and conquer, find half that contains answer</span>
        <span class="k">const</span> <span class="n">_Iter_diff_t</span><span class="o">&lt;</span><span class="n">_FwdIt</span><span class="o">&gt;</span> <span class="n">_Count2</span> <span class="o">=</span> <span class="n">_Count</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// TRANSITION, VSO#433486</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">_UMid</span>                   <span class="o">=</span> <span class="n">_STD</span> <span class="n">next</span><span class="p">(</span><span class="n">_UFirst</span><span class="p">,</span> <span class="n">_Count2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_Pred</span><span class="p">(</span><span class="o">*</span><span class="n">_UMid</span><span class="p">,</span> <span class="n">_Val</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// try top half</span>
            <span class="n">_UFirst</span> <span class="o">=</span> <span class="n">_Next_iter</span><span class="p">(</span><span class="n">_UMid</span><span class="p">);</span>
            <span class="n">_Count</span> <span class="o">-=</span> <span class="n">_Count2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">_Count</span> <span class="o">=</span> <span class="n">_Count2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">_Seek_wrapped</span><span class="p">(</span><span class="n">_First</span><span class="p">,</span> <span class="n">_UFirst</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">_First</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

这个函数比较麻烦，它返回的是第一个不满足_Pred条件的元素。这里_Pred条件是&lt;，所以返回的是第一个大于等于这个元素的迭代器，
然后binary_search函数就用!(_Pred(_Val, *_Ufirst))这个条件来判断是否相等，这相当于构造了
\(a &gt;= b\)
\(a &lt;= b\)
显然地，只有当$a == b$时，表达式才返回真（吐槽一下，这stl写的太“聪明”了）

在二分查找中，成功查找时的ASL为：
\(\sum{i * P(i)} = 1/n*( \sum_{1}^{floor(log(n))}{i * 2^{i}} + ceil(log(n)) * (n - floor(log(n))))\)
这个式子过于繁琐，我们假设它的二叉判定树为满二叉树，可以得到：
\({n - 1}/{n} * log(n + 1) - 1\)

<h2 id="分块查找">分块查找</h2>

分块查找采用了块间有序，块内无序的基本思想，建立一个索引表记录块内的最大值或最小值，然后先查索引表，找到对应的块，然后再到块中查询。

stl中的deque实现有这种思想的影子。

<h2 id="堆优先队列">堆/优先队列</h2>

<h3 id="堆的概念与实现">堆的概念与实现</h3>

堆这个词来自于heap。我们最先学习到的heap，指的是C程序运行时环境的一部分–内存动态分配器及其分配的空间，我们在使用malloc函数、new函数（new实际上是一个函数）时都要用到它来分配空间。

但是这里的heap，指的是一种特殊的数据结构，它具有以下特点：

<ul>
  <li>分为小顶堆和大顶堆</li>
  <li>对自$0$至$floor(n/2) - 1$的元素$heap[i]$有
  \(heap[i] &lt;= heap[2i + 1]\)
  \(heap[i] &lt;= heap[2i + 2]\)</li>
</ul>

其实，第二个特点表明堆可以化为一颗二叉树，这颗二叉树的父亲节点都大于它的子节点。

我们这里用ruby语言实现了一个简单的堆：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">BinaryHeapable</span>
  <span class="k">def</span> <span class="nf">insert_to_heap</span> <span class="n">element</span>
    <span class="n">target</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span>
    <span class="k">while</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span> <span class="o">/</span> <span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">element</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
      <span class="n">target</span> <span class="o">/=</span> <span class="mi">2</span>
    <span class="k">end</span>
    <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">element</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">remove_from_heap</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="nb">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="nb">self</span><span class="p">.</span><span class="nf">pop</span>
    <span class="n">heap_construct</span> <span class="mi">0</span>
    <span class="n">ret</span>
  <span class="k">end</span>
  
  <span class="k">def</span> <span class="nf">convert_to_heap</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span>
      <span class="n">heap_construct</span> <span class="n">i</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">end</span>
    <span class="nb">self</span>
  <span class="k">end</span>

  <span class="kp">private</span>
  <span class="k">def</span> <span class="nf">heap_construct</span> <span class="n">target</span>
    <span class="n">what</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span>
      <span class="k">if</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">self</span><span class="p">.</span><span class="nf">length</span>
        <span class="n">what</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="p">?</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span>
      <span class="k">else</span>
        <span class="n">what</span> <span class="o">=</span> <span class="n">target</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">end</span>
      <span class="k">break</span> <span class="k">if</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">&gt;</span> <span class="nb">self</span><span class="p">[</span><span class="n">what</span><span class="p">]</span>
      <span class="n">temp</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
      <span class="nb">self</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="nb">self</span><span class="p">[</span><span class="n">what</span><span class="p">]</span>
      <span class="nb">self</span><span class="p">[</span><span class="n">what</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span>
      <span class="n">target</span> <span class="o">=</span> <span class="n">what</span>
    <span class="k">end</span>
    <span class="n">what</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

ruby 中的module是mix-in思想的载体。只要我们让一个类include这个模块，这个类就获得了“堆化”的能力。特别地，ruby的数组被封装为Array类，而所有的自带类都是可以修改的：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Array</span>
  <span class="kp">include</span> <span class="no">BinaryHeapable</span>
<span class="k">end</span> 
</code></pre></div></div>

这样一来，我们就可以按照以下方法使用数组：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">].</span><span class="nf">convert_to_heap</span>

<span class="k">while</span> <span class="n">arr</span><span class="p">.</span><span class="nf">length</span> <span class="o">!=</span> <span class="mi">0</span>
  <span class="n">pp</span> <span class="n">arr</span><span class="p">.</span><span class="nf">remove_from_heap</span>
  <span class="n">pp</span> <span class="n">arr</span>
<span class="k">end</span>
</code></pre></div></div>

这段代码会打出：

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">8</span>
<span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">6</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">5</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">3</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
<span class="mi">3</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="mi">1</span>
<span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="mi">0</span>
<span class="p">[]</span>
</code></pre></div></div>

在上面的代码中我们看到，堆只需要实现一个操作，就可以搞定建堆和取出堆顶。

这个操作是什么呢？就是如下的操作：

假设一个堆节点的左子树与右子树均已经满足堆序，把以这个堆节点为根的子树调整成堆序。

这个操作实现起来很简单，具体可参加代码。

实现了这个操作后，

<ul>
  <li>建堆就是自$floor(n/2) - 1$至$0$调用这个操作；</li>
  <li>取出堆顶就是先将堆顶缓存，再将堆尾和堆顶交换，再对堆顶调用这个操作。</li>
</ul>

<h3 id="堆可以用来做什么">堆可以用来做什么？</h3>

堆可以在$O(log(n))$的时间复杂度内完成取出最大/最小元素并调整，这一特性可以作以下用途：

<ul>
  <li>堆排序</li>
  <li>堆优化Dijkstra和Prim算法</li>
  <li>霍夫曼树的实现</li>
  <li>etc</li>
</ul>

<h2 id="散列表">散列表</h2>

<h3 id="哈希表的定义">哈希表的定义</h3>

散列表，又称哈希表，是一种极为重要的数据结构。

为什么极其重要呢？因为

<ul>
  <li>上文提到的ruby，其内部数据结构有很大一部分是用散列表实现的。</li>
  <li>散列表可以用来建立映射，例如把一个字符串映射到一个整数上，这对某些情况是极为有用的(例如图结构笔记中实现的IndexMapping类)。</li>
</ul>

散列表的定义为：
<blockquote>
  散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。
</blockquote>

<h3 id="哈希函数">哈希函数</h3>

首先必须明确，这里的哈希函数和密码学中的哈希函数实质是一样的，都是一个映射：
<blockquote>
  A hash function is any function that can be used to map data of arbitrary size to fixed-size values.
</blockquote>

但是，这里的哈希函数和密码学中的哈希函数侧重点是不一样的：

密码学中的哈希函数主要要求两个性质：

<ol>
  <li>均匀性，所有的输出是<em>等概率</em>的</li>
  <li>唯一性，要求单射，即是说不能存在$a,b$，使得$f(a) == f(b)$</li>
</ol>

高效性（速度）虽然很重要，但远远没有上面两条重要

而这里的哈希函数则要求高效性，因为我们访问哈希表中的元素可能是很频繁的。

所以密码学中的哈希函数用在这里是不太合适的。

教师讲述了6种方法，均以整数为键：

<ol>
  <li>直接定址法(Identity hash function)，找一个整数到整数的线性变换</li>
  <li>折叠法(Folding)，将整数分为几个部分，每个部分都是目标长度的倍数（最后一部分可以小于目标长度），然后将这几部分作运算（加、移位、异或等等），得到结果之后取目标长度位结果。
    <ul>
      <li>密码学哈希算法多与这个方法类似</li>
    </ul>
  </li>
  <li>平方取中法(Mid-squares)，先平方，然后取中间的目标长度位</li>
  <li>除数余留法（Division hashing），直接取模</li>
  <li>代数编码法（Algebraic coding），用数字的不同位作变换。</li>
  <li>随机数法，不解释。</li>
</ol>

<h3 id="碰撞处理">碰撞处理</h3>

如果发生了碰撞，也即是说，存在$a,b$，使得$f(a) == f(b)$，那么就需要进行处理，这大致有四种办法：

<ol>
  <li>开放定址法
    <ul>
      <li>线性探测法</li>
      <li>二次探测法</li>
      <li>随机探测法</li>
    </ul>
  </li>
  <li>再哈希法</li>
  <li>链地址法</li>
  <li>建立公共溢出区法
具体讨论略。</li>
</ol>

<h3 id="哈希表的实现--我实现的c版本">哈希表的实现 – 我实现的c++版本</h3>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* hashtable.h */</span>

<span class="cp">#pragma once
#include &lt;bits/stdc++.h&gt;
</span>
<span class="cp">#define TYPE_KEY char *
#define TYPE_VALUE char *
#define MD5 md5
#define NOT_FIND NULL
#define NUM_NOT_FIND -1
</span>
<span class="k">typedef</span> <span class="nf">uint64_t</span> <span class="p">(</span><span class="o">*</span><span class="n">HASH_FUNC</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">class</span> <span class="nc">HashTable</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">insertTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TYPE_KEY</span><span class="p">,</span> <span class="n">TYPE_VALUE</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pair</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">deleteFrom</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="n">findByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">TYPE_VALUE</span> <span class="n">getValueByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">LinkHashTableNode</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">LinkHashTableNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">LinkHashTableNode</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LinkedHashTable</span> <span class="o">:</span> <span class="k">public</span> <span class="n">HashTable</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">insertTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TYPE_KEY</span><span class="p">,</span> <span class="n">TYPE_VALUE</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pair</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">deleteFrom</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">);</span>
    <span class="k">virtual</span> <span class="n">TYPE_VALUE</span> <span class="n">getValueByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">LinkedHashTable</span><span class="p">(</span><span class="n">uint</span> <span class="n">value</span><span class="p">,</span> <span class="n">HASH_FUNC</span> <span class="n">hashFunction</span><span class="p">);</span>

<span class="nl">private:</span>
    <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="n">findByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">(</span><span class="n">TYPE_KEY</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LinkHashTableNode</span><span class="o">&lt;</span><span class="n">TYPE_VALUE</span><span class="o">&gt;</span> <span class="o">*&gt;</span> <span class="n">nodePool</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* hashtable.cpp */</span>

<span class="cp">#include "./hashtable.h"
#include "md5.h"
</span>
<span class="n">LinkedHashTable</span><span class="o">::</span><span class="n">LinkedHashTable</span><span class="p">(</span><span class="n">uint</span> <span class="n">size</span><span class="p">,</span> <span class="n">HASH_FUNC</span> <span class="n">hashFunction</span><span class="p">)</span> <span class="o">:</span> <span class="n">nodePool</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">hashFunction</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint64_t</span> <span class="n">LinkedHashTable</span><span class="o">::</span><span class="n">findByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_value</span> <span class="o">%</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">NUM_NOT_FIND</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">hash_value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">LinkedHashTable</span><span class="o">::</span><span class="n">insertTo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TYPE_KEY</span><span class="p">,</span> <span class="n">TYPE_VALUE</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pair</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">first</span><span class="p">);</span>
    <span class="n">hash_value</span> <span class="o">=</span> <span class="n">hash_value</span> <span class="o">%</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">new_node</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkHashTableNode</span><span class="o">&lt;</span><span class="n">TYPE_VALUE</span><span class="o">&gt;</span><span class="p">(</span><span class="n">pair</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="n">new_node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">];</span>
    <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_node</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">LinkedHashTable</span><span class="o">::</span><span class="n">deleteFrom</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">findByKey</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">];</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span> <span class="o">=</span> <span class="n">begin</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">begin</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">TYPE_VALUE</span> <span class="n">LinkedHashTable</span><span class="o">::</span><span class="n">getValueByKey</span><span class="p">(</span><span class="n">TYPE_KEY</span> <span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">hash_value</span> <span class="o">=</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">findByKey</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hash_value</span> <span class="o">==</span> <span class="n">NUM_NOT_FIND</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">NOT_FIND</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">this</span><span class="o">-&gt;</span><span class="n">nodePool</span><span class="p">[</span><span class="n">hash_value</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

我们实现了一个很简单的哈希表，采用链地址法进行碰撞处理，采用MD5（这是一个密码学哈希函数）作为哈希函数。

<h3 id="ruby中的哈希表实现">Ruby中的哈希表实现</h3>

我们实现的哈希表，玩具色彩浓厚，特别是直接采用MD5算法这种愚蠢行为，每次查询时，都需要做至少64轮循环，效率是很差的。

所以，本笔记的最后一部分就集中精力来讨论一个工业级哈希表 – ruby中的哈希表。

ruby中的哈希表使用为:

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">hash</span> <span class="o">=</span> <span class="p">{</span><span class="ss">:a</span> <span class="o">=&gt;</span> <span class="s2">"haha"</span><span class="p">,</span> <span class="ss">:b</span> <span class="o">=&gt;</span> <span class="s2">"hahaha"</span><span class="p">}</span>
</code></pre></div></div>

这个数据结构在ruby程序中，使用得特别广泛、特别频繁。如果没有一个优秀的内部实现，ruby程序的性能将会受到很大影响。

笔记篇幅所限，这里不能完整地讨论ruby哈希表底层实现ruby/st.c中1000多行代码的全部内容。这里仅仅讨论一些最重要、和我们所学习内容关系最大的内容。

<strong>下面所称 st_table 指的就是ruby内部的哈希表</strong>

<h4 id="st_table-的哈希函数">st_table 的哈希函数</h4>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 537行 */</span>
    <span class="n">hash_val</span> <span class="o">=</span> <span class="n">do_hash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">table</span><span class="p">);</span>
</code></pre></div></div>

上面这段代码表明哈希函数就是do_hash.我们来看一下这个函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 88行 */</span>
<span class="cp">#define do_hash(key,table) (st_index_t)(*(table)-&gt;type-&gt;hash)((key))
</span></code></pre></div></div>

这段代码似乎不是很好理解，我们来一点点地看：

首先这是一个宏定义，传入两个参数key和table，给出一个值，其类型为st_index_t，也就是哈希表的具体位置（数组下标）

然后来看具体的内容

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">table</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">)((</span><span class="n">key</span><span class="p">))</span>
</code></pre></div></div>

这个语法其实是一个函数调用。(table)-&gt;type-&gt;hash是一个函数指针，指向hash函数，key是其参数。

那么想要找到真正的哈希函数，就必须要找到初始化时这个table-&gt;type-&gt;hash被赋了什么值：

哈希表的初始化有些复杂，但是为了讨论的方便还是介绍一下：

首先，所有的初始化都最终被转发到这个函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_table</span><span class="o">*</span>
<span class="n">st_init_table_with_size</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">st_hash_type</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="n">st_index_t</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div></div>

然后实际使用时有三种初始化方法：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_table</span><span class="o">*</span>
<span class="nf">st_init_numtable_with_size</span><span class="p">(</span><span class="n">st_index_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">st_init_table_with_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">type_numhash</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_table</span><span class="o">*</span>
<span class="n">st_init_strtable_with_size</span><span class="p">(</span><span class="n">st_index_t</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">st_table</span><span class="o">*</span>
<span class="n">st_init_strcasetable_with_size</span><span class="p">(</span><span class="n">st_index_t</span> <span class="n">size</span><span class="p">)</span>
</code></pre></div></div>

我们这里只研究第一种st_init_numtable_with_size。这一种看名字就知道是整数对整数的映射。
它传入了一个type_numhash，这看起来是一个全局常量：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define type_numhash st_hashtype_num
</span><span class="k">const</span> <span class="k">struct</span> <span class="n">st_hash_type</span> <span class="n">st_hashtype_num</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">st_numcmp</span><span class="p">,</span>
    <span class="n">st_numhash</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

那么，整数对整数的映射实际上应该调用到st_numhash这个函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 1666 - 1683行 */</span>
<span class="n">st_index_t</span>
<span class="nf">st_numhash</span><span class="p">(</span><span class="n">st_data_t</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/*
     * This hash function is lightly-tuned for Ruby.  Further tuning
     * should be possible.  Notes:
     *
     * - (n &gt;&gt; 3) alone is great for heap objects and OK for fixnum,
     *   however symbols perform poorly.
     * - (n &gt;&gt; (RUBY_SPECIAL_SHIFT+3)) was added to make symbols hash well,
     *   n.b.: +3 to remove ID scope, +1 worked well initially, too
     * - (n &lt;&lt; 3) was finally added to avoid losing bits for fixnums
     * - avoid expensive modulo instructions, it is currently only
     *   shifts and bitmask operations.
     */</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">st_index_t</span><span class="p">)((</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">RUBY_SPECIAL_SHIFT</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">n</span><span class="o">&lt;&lt;</span><span class="mi">3</span><span class="p">))</span> <span class="o">^</span> <span class="p">(</span><span class="n">n</span><span class="o">&gt;&gt;</span><span class="mi">3</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

这个函数看起来倒是很简单，就是用n做了一些位运算。不过不属于教师讲述的6中方法之一。

这很大程度地激起了我的好奇心：难道Index是32位的整数吗？这个函数没有任何取模操作，如果传入一个很大的n,它该如何处理呢？

不要着急，让我们继续追踪吧：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 584 - 588行 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="n">key</span><span class="p">);</span>
<span class="n">add_direct</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">hash_val</span><span class="p">,</span> <span class="n">bin_pos</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

我们注意到bin_pos这个参数，因为在add_direct函数中，它会调用new_entry函数，最后会执行这个语句：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 445 行 */</span> 
<span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span><span class="n">bin_pos</span><span class="p">];</span>
<span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span><span class="n">bin_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
</code></pre></div></div>

显然地，bin_pos才是数组查找的真正下标！那么bin_pos是在哪里被设置的呢？一个出乎预料的答案是在FIND_ENTRY宏中：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 582行*/</span>
    <span class="n">FIND_ENTRY</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">hash_val</span><span class="p">,</span> <span class="n">bin_pos</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 344行 */</span>
<span class="cp">#define FIND_ENTRY(table, ptr, hash_val, bin_pos) \
    ((ptr) = find_entry((table), key, (hash_val), ((bin_pos) = hash_pos(hash_val, (table)-&gt;num_bins))))
</span></code></pre></div></div>

经历了千辛万苦，我们终于来到了真正获取下标的hash_pos宏：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 89行 */</span>
<span class="cp">#define hash_pos(h,n) ((h) &amp; (n - 1))
</span></code></pre></div></div>

这里可以看到，实际的下标是和哈希表的长度与之后的结果。

有人可能会问，为什么要有两套键（一个hash_val，一个bin_pos）呢？我们下面会谈到，这里埋个伏笔。不过在谈到这个问题之前，我们先要看看它的碰撞处理。

<h4 id="st_table的碰撞处理">st_table的碰撞处理</h4>

如果FIND_ENTRY宏找到了该key，st_table会如何处理呢？其实，这个问题在add_direct调用的new_enrty函数那里就可以看出来：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 445 - 446行 */</span>
    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span><span class="n">bin_pos</span><span class="p">];</span>
    <span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">[</span><span class="n">bin_pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
</code></pre></div></div>

这写法显然是链表的头插法，所以是链地址法。

<h4 id="st_table的扩容">st_table的扩容</h4>

在我们实现的哈希表中，真正的哈希算法为：
\(hash = MD5(key) \% n\)
这样一来带来一个很麻烦的问题 – 扩容时必须重新计算哈希值。

而我们可以猜想到，得益于ruby哈希表中hash_val和bin_pos的分离，扩容时只需要重新计算bin_pos，而不需要重新计算哈希值。

真的是这样吗？让我们再看看源代码：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 459 - 462行 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">&gt;</span> <span class="n">ST_DEFAULT_MAX_DENSITY</span> <span class="o">*</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_bins</span><span class="p">)</span> <span class="p">{</span>
<span class="n">rehash</span><span class="p">(</span><span class="n">table</span><span class="p">);</span>
    <span class="n">bin_pos</span> <span class="o">=</span> <span class="n">hash_pos</span><span class="p">(</span><span class="n">hash_val</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_bins</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

可以清楚地看到，如果现在的哈希表项数大于可以容纳的最大数量 * 一个密度常数，那么就用rehash()函数重新对这个表作哈希，而rehash()函数定义如下：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 609 - 627行 */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">rehash</span><span class="p">(</span><span class="k">register</span> <span class="n">st_table</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">register</span> <span class="n">st_table_entry</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="o">**</span><span class="n">new_bins</span><span class="p">;</span>
    <span class="n">st_index_t</span> <span class="n">new_num_bins</span><span class="p">,</span> <span class="n">hash_val</span><span class="p">;</span>

    <span class="n">new_num_bins</span> <span class="o">=</span> <span class="n">new_size</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">num_bins</span><span class="o">+</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">new_bins</span> <span class="o">=</span> <span class="n">st_realloc_bins</span><span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span><span class="p">,</span> <span class="n">new_num_bins</span><span class="p">,</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_bins</span><span class="p">);</span>
    <span class="n">table</span><span class="o">-&gt;</span><span class="n">num_bins</span> <span class="o">=</span> <span class="n">new_num_bins</span><span class="p">;</span>
    <span class="n">table</span><span class="o">-&gt;</span><span class="n">bins</span> <span class="o">=</span> <span class="n">new_bins</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
	    <span class="n">hash_val</span> <span class="o">=</span> <span class="n">hash_pos</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">new_num_bins</span><span class="p">);</span>
	    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">];</span>
	    <span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fore</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

这段代码有两个地方需要研究

<ol>
  <li>new_size是如何实现的，新的大小和现大小是什么关系？</li>
  <li>现在的哈希表是如何迁移到新的哈希表的？</li>
</ol>

首先研究第一个问题，我们直接研究new_size函数：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 157 - 172行 */</span>
<span class="k">static</span> <span class="n">st_index_t</span>
<span class="nf">new_size</span><span class="p">(</span><span class="n">st_index_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">st_index_t</span> <span class="n">n</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="n">size</span><span class="p">)</span> <span class="cm">/* already a power-of-two? */</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">next_pow2</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#ifndef NOT_RUBY
</span>    <span class="n">rb_raise</span><span class="p">(</span><span class="n">rb_eRuntimeError</span><span class="p">,</span> <span class="s">"st_table too big"</span><span class="p">);</span>
<span class="cp">#endif
</span>    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>			<span class="cm">/* should raise exception */</span>
<span class="p">}</span>
</code></pre></div></div>
可以看到，下一个大小是next_pow2算出来的。也就是说，新的大小和旧的大小有如下关系：
\(size_{new} = 2 \times size_{former}\)

然后研究第二个问题，现在的哈希表如何迁移到新的哈希表。

首先，st_realloc_bins只会重新分配内存，而不会迁移，真正的迁移在这个循环中进行：
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">head</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">do</span> <span class="p">{</span>
	    <span class="n">hash_val</span> <span class="o">=</span> <span class="n">hash_pos</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">new_num_bins</span><span class="p">);</span>
	    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">];</span>
	    <span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fore</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

要说明白这个循环，必须认真研究一下st_table_entry：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* ruby/st.c 18 - 26行 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">st_table_entry</span> <span class="n">st_table_entry</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">st_table_entry</span> <span class="p">{</span>
    <span class="n">st_index_t</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">st_data_t</span> <span class="n">key</span><span class="p">;</span>
    <span class="n">st_data_t</span> <span class="n">record</span><span class="p">;</span>
    <span class="n">st_table_entry</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="n">st_table_entry</span> <span class="o">*</span><span class="n">fore</span><span class="p">,</span> <span class="o">*</span><span class="n">back</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

这个next，指向的是本bin_pos的下一个项；而fore和back，实际上是把整个哈希表中所有的项做成了一个双向链表！

回过头来再看add_direct的最后一部分，我们会有种恍然大悟的感觉：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fore</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">tail</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fore</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
<span class="n">table</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
<span class="n">table</span><span class="o">-&gt;</span><span class="n">head</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">tail</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
<span class="n">entry</span><span class="o">-&gt;</span><span class="n">fore</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">back</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

这也正是双向链表的插入操作，其中table-&gt;head是头指针，table-&gt;tail是尾指针。这样一来，所有的项都串成了一个双向链表，通过从头指针开始的遍历就可以将所有的项加入新的哈希表中，而这正是这个循环所做的事情：

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">do</span> <span class="p">{</span>
	<span class="n">hash_val</span> <span class="o">=</span> <span class="n">hash_pos</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">,</span> <span class="n">new_num_bins</span><span class="p">);</span>
	<span class="n">ptr</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">];</span>
	<span class="n">new_bins</span><span class="p">[</span><span class="n">hash_val</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">fore</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
</code></pre></div></div>

特别地，我们发现它确实只是将哈希值用hash_pos宏变为了bin_pos，即下标，从而避免了再次哈希键。

<h4 id="总结">总结</h4>

总的来说，ruby中的哈希表有这几个特性：

<ol>
  <li>哈希函数是将键做不循环的位运算。</li>
  <li>哈希值和真正的下标分离，真正的下标由哈希值逻辑与哈希表长度得到，扩容时不需要再次计算哈希值，只需要再次计算真正的下标。</li>
  <li>冲突处理采用链地址法。</li>
  <li>容量永远是2的n次方，扩容时，新的容量是现容量的两倍</li>
  <li>将所有的哈希表项用一个双向链表串起来，用头指针和尾指针实现对整个哈希表的高效遍历。</li>
</ol>

</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/802.11i/2019/11/02/802-11i-1/">
                                    <p class="title is-2">802.11i 无线安全（一）建立RSNA <span class="tag is-white is-pulled-right"><small>November 02, 2019</small></span></p>
                                    <p class="subtitle"><small>这学期我选了我校的公选课《无线网络安全技术》。以第二个实验为契机，我学习了一下802.11无线网络的安全。感觉网络上的中文资料太混乱、太不成体系。在这里，我用这些文章来系统地说一下这方面的东西。

首先，我们要先分清楚几个名词：WEP WPA WPA2 802.11 802.11i Wifi RSN RSNA

分清楚这几个东西不是很简单的事情。我们应该知道Wi-Fi是无线局域网的意思，而802.11也是无线局域网的标准，那么它们的区别是什么呢?

参考这本书 <strong>Real 802.11 Security: Wi-Fi Protected Access and 802.11i</strong>的说法：

<blockquote class="wp-block-quote">
  
    In summary, Wi-Fi defines a subset of IEEE 802.11 with some extensions
  
</blockquote>

而会出现这种情况的原因要归结于802.11协议比较开放，没有强制规定很多问题。这也就导致一个采用部分802.11特性的设备很可能不能和令一个采用部分802.11特性的设备通信。这很糟糕。为了解决这个问题，Wi-Fi联盟成立（当时叫做 Wireless Ethernet Compatibility Alliance ，WECA）,它推出了Wi-Fi认证，并保证：两台通过Wi-Fi认证的设备可以通过无线网络相互通信。这样一来就解决了上面的问题。

那么，作为安全标准的WEP、WPA、WPA2和ieee 802.11i的关系是什么呢？首先来看WEP。参考<a href="https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy">维基百科</a>的说法：

<blockquote class="wp-block-quote">
  
    Introduced as part of the original 802.11 standard ratified in 1997, its intention was to provide data <a href="https://en.wikipedia.org/wiki/Confidentiality">confidentiality</a> comparable to that of a traditional wired <a href="https://en.wikipedia.org/wiki/Local_area_network">network</a>.
  
</blockquote>

也就是说WEP是IEEE 802.11标准一开始就规定的安全标准。 WEP的意思是“有线等效加密”。

再来看WPA。WPA和Wi-Fi一样，也是Wi-Fi联盟的认证。和Wi-Fi不同的是，WPA是安全性认证。比较麻烦的是，WPA一开始并不是802.11某个部分的子集，它完全是Wi-Fi联盟设计的安全协议。这是为了避免厂家自行其是，从而产生安全上的不兼容问题。这一部分安全协议最终被标准化为802.11i，也就是今天我们要说的主角了。802.11i是对WPA协议的扩展与重构，Wi-Fi联盟使用WPA2作为新的认证商标，以说明这个产品支持802.11i标准。所以简单地说，WPA2应该被视作802.11i的实现。

虽然WPA3认证（对应802.11-2016）已经在2018年发布，但现今市面上绝大多数产品仍是WPA2认证的。下面的讨论也主要基于WPA2，也就是802.11i-2004和802.11-2007

最后来研究RSN和RSNA。RSN(robust security network)是“鲁棒安全网络”或者“健壮安全网络”的意思。RSN的字面意思很好懂，就是一个健壮的、安全的网络。802.11i引入这个概念来区分使用802.11i规定的、新的安全方法的网络和旧的WEP网络。它将WEP网络称为”pre-RSN”，也就是在RSN提出之前的网络，而将使用802.11i新引入的安全手段建立的网络称为RSN。所以建立RSN其实是使用802.11i安全的目的。

RSNA则是在两个使用802.11i安全套件的终端间建立的逻辑连接。或者用一个更常用的词“链路”。我们说的两个终端（比如说AP和STA）“连上了”，其实就是在这两个终端间建立了RSNA。

值得一提的是， <strong>深入理解Android：Wi-Fi、NFC和GPS卷</strong> 这本书很不错，值得一读，但在RSNA的概念上犯了错误。原文如下：

<blockquote class="wp-block-quote">
  
    RSNA（Robust Secure Network Association，强健安全网络联合）是802.11定义的一组保护无线网络安全的过程，是一套安全组合拳。这套组合拳包含的过程如图3-45所示。
  
</blockquote>

RSNA的Association不是指802.11i各个组件的组合，而是指两个终端的连接。在NIST上查询RSNA这一词，定义很明确：

<blockquote class="wp-block-quote">
  
    A logical connection between communicating IEEE 802.11 entities established through the IEEE 802.11i key management scheme, also known as the four-way handshake.
  
</blockquote>

其实我们查询Association这个词也会发现，它有两个意思，这里应该取第二个：

<blockquote class="wp-block-quote">
  
    1. (often in names) a group of people organized for a joint purpose.
  
  
  
    2. a connection or cooperative link between people or organizations.
  
</blockquote>

下面，我们就围绕两个终端如何建立RSNA这一主题，探索802.11i的世界。

首先，802.11i规定了建立RSNA的方法和建立RSNA后数据如何传输，整个过程可以用802.11i状态机表示：<figure class="wp-block-image"></figure>

<img src="http://www.tech-faq.com/wp-content/uploads/RSN.png" alt="" /> &lt;/figure&gt;

整个连接可以分为五个过程：

发现（Discovery）-&gt; 认证（Authentication）-&gt; 密钥生成与分发（Key Generation and Distribution） -&gt; 加密数据传输（Protected Communication）-&gt; 连接终止（Connection Termination）

其中相当于建立连接的前三个过程，是我们最感兴趣的过程。下面就来近距离观察这三个过程：

<strong>1.发现</strong>

AP会对外发送BEACON帧：<figure class="wp-block-image is-resized"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-1024x17.png" alt="" class="wp-image-427" width="580" height="9" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-1024x17.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-300x5.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-768x13.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1.png 1347w" sizes="(max-width: 580px) 100vw, 580px" /> &lt;/figure&gt;

这个帧是AP在对外广播自己的各种信息。见下：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752.png" alt="" class="wp-image-429" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752.png 587w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752-300x113.png 300w" sizes="(max-width: 587px) 100vw, 587px" /> &lt;/figure&gt;

我们感兴趣的当然是RSN Information:<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753.png" alt="" class="wp-image-430" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753.png 521w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753-300x116.png 300w" sizes="(max-width: 521px) 100vw, 521px" /> &lt;/figure&gt;

这个结构说明了自己支持的加密方法、认证方法等。

STA捕获了这个帧，就可以知道环境中无线网络的信息。如果要求某个AP提供信息，可以用Probe request帧：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-1024x30.png" alt="" class="wp-image-431" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-1024x30.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-300x9.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-768x22.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754.png 1353w" sizes="(max-width: 1024px) 100vw, 1024px" /> &lt;/figure&gt;

在Probe response帧中，AP回答自己的各种信息。

在知道AP的信息后就可以连接了。第一个发送的帧应该是Authentication:<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755.png" alt="" class="wp-image-432" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755.png 932w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755-300x25.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755-768x65.png 768w" sizes="(max-width: 932px) 100vw, 932px" /> &lt;/figure&gt;

聪明的同学可能会问，这里的Authentication不是“认证”的意思吗？而认证不是下一步要做的事情吗？其实这个认证，叫做Open System Authentication，或者叫做Null Authentication. 从第二个名字就可以知道它什么也不做，那为什么还是要进行这个过程呢？前面说过，WEP是802.11协议的一部分，有了新的WPA，不能直接剔除掉WEP的过程。这个帧正是WEP的认证，在RSNA建立的过程中使用这个帧是为了和WEP，更准确地说是和802.11状态机兼容。这也体现了开闭原则，在添加新功能时，不能修改原有的体系。

下一步是Association request and response，在这个过程中，STA发送association request，选择自己想采用的各种连接参数（其中包括认证和加密方式），AP发送association response, 确认STA的选择有效。

（不知道为什么，我没有捕获到AP发送的association response）<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-1024x29.png" alt="" class="wp-image-437" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-1024x29.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-300x9.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-768x22.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756.png 1341w" sizes="(max-width: 1024px) 100vw, 1024px" /> &lt;/figure&gt;

<strong>2.认证</strong>

在介绍这个过程之前，我们首先需要知道802.11i使用的两种认证方法。一种是预共享密钥（Pre Shared Key, PSK）认证，另一种是802.1x EAP（Extensible Authentication Protocol ）认证。PSK就是我们常见的那种一个密码的情况，EAP则是公共网络（比如我校的SYSU-SECURE）常用的认证方式。

预共享密钥认证只认证双方对PSK的所有权，而不认证任何其他内容，这个所有权认证通过下面的4-Way Handshake进行；而EAP则要具体协议具体分析。

第二个过程·认证 分为两种情况，如果采用的是802.1x EAP套件，那么在这一步用EAP协议进行认证。关于EAP协议的情况我会在下一篇文章中涉及。如果采用的是PSK，则直接跳过这个过程

<strong>3. 密钥生成与分发( 4-WAY HANSHAKE</strong> )

这一步就是传说中的四次握手了。这个过程主要有两个目的：

1.验证上一步认证的效果–AP和STA是否都对PMK有了所有权。

2.在AP和STA上安装密钥，以便下面加密通信。

（这个过程还可能会有Group Key的生成与分发，但一般用不到，这里不表）

首先先要解释PMK是什么。PMK（Pairwise Master Key）在下面会被用于密钥派生，它的产生分为两种情况：1.如果是PSK模式，PMK就是PSK。2.如果是802.1x EAP模式，它会在EAP协议过程中被安装在AP和STA中。

这样看，PMK是一个相对不变的参数。如果加密时直接使用PMK，那么安全性是很成问题的（据说tls1.1就有这个问题）。所以我们要使用PRF扩展密钥，生成一个暂时的密钥，也就是PTK（ Pairwise Transient Key ）:

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">PTK = PRF-X(PMK, “Pairwise key expansion”,Min(AA,SPA) || Max(AA,SPA) ||Min(ANonce,SNonce) ||Max(ANonce,SNonce))
</pre>

其中X指长度，可以是384（CCMP）或者512（TKIP）.Nonce在这里指随机数，SNONCE指STA的随机数，ANONCE指客户端的随机数。AA指AP的MAC地址，SA指STA的MAC地址。

TIPS: CCMP是采用AES CCM（一种计数器模式）的加密方法，TKIP是采用RC4的加密方法，在802.11i中只支持这两种加密。

这里的SNONCE和ANONCE显然是这一次连接时产生的，那么应该要有某种形式的交换。第一帧就是AP向STA发送自己的随机数：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757.png" alt="" class="wp-image-441" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757.png 567w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757-300x97.png 300w" sizes="(max-width: 567px) 100vw, 567px" /> &lt;/figure&gt;

拿到这个随机数以后，客户端就可以生成一个随机数，然后开始计算PTK。PTK算出来后会被分为3个部分：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758.png" alt="" class="wp-image-443" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758.png 602w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758-300x106.png 300w" sizes="(max-width: 602px) 100vw, 602px" /> &lt;/figure&gt;

其中TK就是加密通信所用的密钥，KCK是下面计算MIC要用到的，KEK是用来加密某些信息的（这里并不深究KEK到底用来做什么，请自行查阅相关资料）。

之后，客户端会构造将自己的随机数写入第二帧，并且将MIC算出来后写入第二帧。MIC是怎么算出来的呢？其实MIC是一个消息校验码，相当于一个HASH函数，但这里用的是HMAC，用我们前面说过的KCK作为HMAC的key，用本帧的所有字节作为输入，计算出来的结果就是MIC。但这里有个问题，MIC不可能在计算出来之前就被填入本帧，所以在计算MIC的时候，要将本帧的MIC字段全部置为0.

第二帧的MIC用这个方式计算：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">MIC = MIC(KCK, EAPOL)</pre>
<figure class="wp-block-image">

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759.png" alt="" class="wp-image-447" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759.png 545w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759-300x59.png 300w" sizes="(max-width: 545px) 100vw, 545px" /> </figure>

AP在收到第二帧后，用相同的方法计算PTK和MIC，再与第二帧时STA传的MIC进行对比，就可以验证STA对PSK的所有权了。

那么，客户端又是如何验证服务端对AP的所有权的呢？其实也是通过MIC的。因为要计算出正确的MIC，就必须要有正确的KCK，只要这一帧的内容和上一帧不一样就可以了！

而这内容肯定是和上一帧不一样的，因为这一帧的NONCE字段被设置为了：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Key Nonce = ANonce</pre>

STA只需要计算一下MIC，就可以验证AP对PMK的所有权了。验证成功后，发送第四帧，整个4-WAY-HANDSHAKE握手过程就结束了。

下面的数据就会使用CCMP或TKIP加密，是比较安全的。

总的来说，建立RSNA的过程不是很复杂，也有比较好的扩展性。下一篇文章中我们将会讨论关于EAP的内容。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/11/02/tls3/">
                                    <p class="title is-2">SSL/TLS(三) 用RUBY实现TLS握手 <span class="tag is-white is-pulled-right"><small>November 02, 2019</small></span></p>
                                    <p class="subtitle"><small>这部分的工作，我在月中就完成了。但在期中考试和某公选课的双重压力下，直到现在才有时间写出来。

<strong>警告：下面有大量的ruby编程细节</strong>

首先是将报文封装写好

<strong>1.record</strong>

Record是tls的基本报文格式，所有的tls报文最后都应该被封装为Record。Record的内容只有一个: tlsPlainText

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">tlsPlainText = Class.new do 
   attr_accessor :contentType, :protocolVersion, :length, :fragment
end</pre>

Record的Content一共有四种，分别对应于四种类型：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">contentType = {"change_cipher_spec" =&gt; 20, "alert" =&gt; 21, 
  "handshake" =&gt; 22, "application_data" =&gt; 23}</pre>

这里我们只实现handshake和change_cipher_spec

对于具体封装，我写了一个Record#make方法：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">def make(encrypt = false)
        if encrypt == true
            puts tlsPlainText.fragment.to_hex
            @tlsPlainText.fragment = yield(@tlsPlainText.fragment)
            @tlsPlainText.length = @tlsPlainText.fragment.length
        end
        template =
            "C"+  #type
            "CC"+ #protocolVersion
            "n"+  #length
            "a#{@tlsPlainText.length}" #fragment
        
        arr = [@tlsPlainText.contentType, 
               @tlsPlainText.protocolVersion.major,             
               @tlsPlainText.protocolVersion.minor, @tlsPlainText.length, 
               @tlsPlainText.fragment ]
        ret = arr.pack template
        return ret
    end</pre>

由于后面我们的加密器是一个外部对象，要将自己的fragment加密后再替换成新的fragment，如果我们写出这样的代码：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">record_a.tlsPlainText.fragment = Encrypter.encrypt(record_a.tlsPlainText.fragment )</pre>

感觉不是很顺畅，也违背了面向对象封装的思想。

我们使用yield来解决这个问题:

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">str_fin = fin.make do |i|
    encrypt_handler.send_encrypt(22, i)
end</pre>

这样是对的吗？我不太清楚，但至少比上面的写法要好一些。

<strong>2.Handshake</strong>

让Handshake继承Record，有这个想法是因为Handshake是Record的细化。

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class Handshake &lt; Record
    attr_accessor :record, :handshakeType, :handshakeLength, :handshakeBody
    ...
end</pre>

handshakeType一共有四种（哈哈，这里不太对，应该是我们只实现了四种）：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">def self.handshake_type
        return {'1' =&gt; 'client_hello',
                '2' =&gt; 'server_hello',
                '11' =&gt; 'server_certificates',
                '14' =&gt; 'server_hello_done'}
end</pre>

然后具体的make封装如下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">def make(encrypt = false)
        template = 
            "C"+ #handshakeType
            "Cn"+ #length
            "a#{@handshakeLength}" #body
        
        arr = [self.handshakeType, 0 ,self.handshakeLength, 
               self.handshakeBody]
        pack = arr.pack template
        @tlsPlainText.fragment = pack
        @tlsPlainText.length = pack.length
        super(encrypt)
end</pre>

<strong>3.各个Handshake</strong>

虽然只有四种，但是实现起来是很麻烦的。这里进一步简化了一下–不实现ClientHello的扩展。

报文封装写好以后，下面的工作就是最重要、最核心的工作的了–实现密码学计算。这里为了简化，我们只实现一种密码学套件–TLS_RSA_WITH_AES_GCM_128_SHA_256

最开始是ClientHello和ServerHello里的随机数，这里使用OpenSSL::Random#random_bytes

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">time = Time.new
@gmt_unix_time = time.to_i
@random_bytes = OpenSSL::Random.random_bytes(28)</pre>

然后是扩展函数PRF，这里使用一个猴子补丁:

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">class Integer
    def tls_prf(secret = '', label = '', seed = '', hash_methods = 'SHA256')
        return self.tls_P_hash(secret, label + seed, hash_methods)
    end

    def tls_P_hash(secret='', seed = '', hash_methods = 'SHA256')
        t = self.to_f / 32
        t = t.ceil
        ret = ''

        a = seed
        t.times do |i|
            a = OpenSSL::HMAC.send("digest", hash_methods, secret, a)
            ret &lt;&lt; OpenSSL::HMAC.send("digest", hash_methods, secret, a + seed)
        end
        return ret[0, self]
    end
end</pre>

在EncryptMessageHandler这个模块中生成Pre-master-key和master-key

这里需要注意两个细节：

1.不要搞混client_random和server_random的顺序。（这个问题我debug了一天才发现）

2.client_random和server_random都是32字节的、真正发送出去的东西，而不是28字节的random_bytes。

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">@pre_master = @version.pack("CC") + OpenSSL::Random.random_bytes(46)
@master = 48.tls_prf(@pre_master, "master secret", client_random+server_random)</pre>

其中pre-master-key要用server传来的certificate加密：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">rsa = OpenSSL::PKey::RSA.new (certificate.public_key)
@encrypt_pre_master = rsa.public_encrypt @pre_master</pre>

生成主密钥之后，应该是根据实际情况进行密钥扩展。将密钥扩展成六个部分：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">client_write_MAC_key[SecurityParameters.mac_key_length]      server_write_MAC_key[SecurityParameters.mac_key_length]      client_write_key[SecurityParameters.enc_key_length]      server_write_key[SecurityParameters.enc_key_length]      client_write_IV[SecurityParameters.fixed_iv_length]      server_write_IV[SecurityParameters.fixed_iv_length]</pre>

可这个“实际情况”在使用TLS_RSA_WITH_AES_128_GCM_SHA_256这个套件的情况下究竟是什么样的呢?

我找了一些资料，最后发现有两个地方说的比较靠谱：

第一个是RFC5246对于AES_XXX_GCM这种AEAD方式的描述：

<blockquote class="wp-block-quote">
  
    AEAD ciphers take as input a single key, a nonce, a plaintext, and &#8220;additional data&#8221; to be included in the authentication check, as described in Section 2.1 of [AEAD]. <strong>The key is either the client_write_key or the server_write_key. </strong> <strong>No MAC key is used.</strong>
  
  
  
    Each AEAD cipher suite MUST specify how the nonce supplied to the AEAD operation is constructed, and what is the length of the GenericAEADCipher.nonce_explicit part. In many cases, it is appropriate to use the partially implicit nonce technique described in Section 3.2.1 of [AEAD]; with record_iv_length being the length of the explicit part. <strong>In this case, the implicit part SHOULD be derived from key_block as client_write_iv and server_write_iv (as described in Section 6.3), and the explicit part is included in GenericAEAEDCipher.nonce_explicit </strong>
  
</blockquote>

通过第一段文字，我们可以知道两个问题：第一，加密用到的key就是client_write_key和server_write_key。第二，之前说的client_MAC_KEY和server_MAC_KEY都是用不到的。在RFC 5246中也说了，如果用不到，长度设为0就可以（也就是不产生了）。

麻烦的是第二段文字。如果你之前没有接触过相关内容，肯定会感觉到不知所云。这文字显然就是“给已经懂了的人看的”。在这里简单解释一下，第一段里说，AEAD需要有一个nonce作为输入。然后第二段里说，这个nonce可以被分为两部分：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">nonce = implicit_nonce || explicit_nonce</pre>

然后implicit部分应该是上面扩展出来的

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">client_write_IV[SecurityParameters.fixed_iv_length]      server_write_IV[SecurityParameters.fixed_iv_length]</pre>

explicit部分则是直接明文传过去，因为AEAD产生的报文是以下格式的：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="0" data-enlighter-title="" data-enlighter-group="">struct {         
       opaque nonce_explicit[SecurityParameters.record_iv_length];         
       aead-ciphered struct { opaque content[TLSCompressed.length];};      
} GenericAEADCipher;</pre>

GenericAEADCipher.nonce_explicit就是explicit部分填充的地方。

那么，AES_XXX_GCM到底是怎么做的呢？这就要看第二份文件 RFC 5288了：

<blockquote class="wp-block-quote">
  
    The &#8220;nonce&#8221; SHALL be 12 bytes long consisting of two parts as follows: (this is an example of a &#8220;partially explicit&#8221; nonce; see Section 3.2.1 in [RFC5116]).
  
  
  
    struct {
  
  
  
    opaque salt[4];
  
  
  
    opaque nonce_explicit[8];
  
  
  
    } GCMNonce;
  
  
  
    The salt is the &#8220;implicit&#8221; part of the nonce and is not sent in the packet. Instead, the salt is generated as part of the handshake process: it is either the client_write_IV (when the client is sending) or the server_write_IV (when the server is sending). The salt length (SecurityParameters.fixed_iv_length) is 4 octets.
  
</blockquote>

看到这段文字，我们就已经很清楚了。AES_XXX_GCM的nonce是12byte的，其中四个byte来自于

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">client_write_IV[SecurityParameters.fixed_iv_length]   server_write_IV[SecurityParameters.fixed_iv_length]</pre>

后面8个byte就是一个每个报文的都不同的随机数，直接明文写在报文里。

好的，我们据此写出密钥扩展的部分：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">key_block = (length/4 + 4 * 2).tls_prf(@master, "key expansion", server_random + client_random)
arr = key_block.unpack "a#{length/8}a#{length/8}a4a4"
client_write_key = arr[0]
server_write_key = arr[1]
client_write_iv = arr[2]
server_write_iv = arr[3]</pre>

然后是加密和解密的部分。Ruby中Openssl库的AES::GCM加密时需要设置密钥、nonce和auth_data，那这个auth_data又怎么设置呢？再回到RFC 5246:

<blockquote class="wp-block-quote">
  
    The additional authenticated data, which we denote as additional_data, is defined as follows:
  
  
  
    additional_data = seq_num + TLSCompressed.type + TLSCompressed.version + TLSCompressed.length;
  
</blockquote>

别的都好说，这个序列号怎么办？它是几位的？怎么产生？怎么更新？再看RFC 5246,这需要使用搜索功能，搜索seqence number:

<blockquote class="wp-block-quote">
  
    sequence number
  
  
  
    Each connection state contains a sequence number, which is maintained separately for read and write states. The sequence number MUST be set to zero whenever a connection state is made the active state. Sequence numbers are of type uint64 and may not exceed 2^64-1. Sequence numbers do not wrap. If a TLS implementation would need to wrap a sequence number, it must renegotiate instead. A sequence number is incremented after each record: specifically, the first record transmitted under a particular connection state MUST use sequence number 0.
  
</blockquote>

这样一来就明白了，客户端和服务端各维护一个seq_num，长度为8个byte，初始值为0，每发送一个加密报文递增一。

然后我们又遇到了一个大麻烦：AES::GCM加密后会产生一个auth_tag，这个auth_tag解密的时候要用。这又该怎么处理呢？我在协议中没有找到，倒是在stack overflow上找到了相关的问题： <a href="https://crypto.stackexchange.com/questions/25249/where-is-the-authentication-tag-stored-in-file-encrypted-using-aes-gcm?newreg=ac7536f1cb2646d995c2c8607aea7d2c">https://crypto.stackexchange.com/questions/25249/where-is-the-authentication-tag-stored-in-file-encrypted-using-aes-gcm?newreg=ac7536f1cb2646d995c2c8607aea7d2c</a> 回答者引用了RFC 5116的内容：

<blockquote class="wp-block-quote">
  
    The&nbsp;<code>AEAD_AES_128_GCM</code>&nbsp;ciphertext is formed by appending the authentication tag provided as an output to the GCM encryption operation to the ciphertext that is output by that operation.
  
</blockquote>

那么，我们只要将auth_tag直接附在加密的密文后就可以了。这样一来所有的问题就都解决了：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">def send_encrypt(type = 22, seqence = '')
        nonce_explicit = OpenSSL::Random.random_bytes(8)
        nonce = @send_implicit + nonce_explicit
        @send_cipher.iv = nonce
        length = seqence.length
        #the handle of seq_num may be wrong
        @send_cipher.auth_data = [0, @send_seq_num,
            type, @version[0], @version[1], 0 ,length].pack("NNCCCCC")
        puts @send_seq_num
        encrypt = @send_cipher.update(seqence) + @send_cipher.final
        encrypt = encrypt + @send_cipher.auth_tag
        encrypt = nonce_explicit + encrypt
        return encrypt
        @send_seq_num += 1
end</pre>

这时我们离握手成功只差一步了！只要写好Finished消息，就可以和服务器愉快地通信了！

Finished消息需要把所有的握手消息打一个HASH，再将HASH值送进PRF:

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">PRF(master_secret, finished_label, Hash(handshake_messages))            [0..verify_data_length-1];</pre>

但这里也有个大坑：

<blockquote class="wp-block-quote">
  
    Here handshake_messages refers to all handshake messages sent or received, starting at client hello and up to, but not including this message, including the type and length fields of the handshake messages. <strong>This is the concatenation of all the Handshake structures </strong>
  
</blockquote>

注意这个Handshake structures，这不是报文的意思，而应该是报文剥掉Record层的信息后的Record.fragment结构体！另外，ChangeCipherSpec消息不是Handshake消息，这里不应该被包括。

解决Finished后，所有的工作就做完了。下面是和baidu.com握手的结果：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1024x97.png" alt="" class="wp-image-405" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1024x97.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-300x28.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-768x73.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751.png 1345w" sizes="(max-width: 1024px) 100vw, 1024px" /> &lt;/figure&gt;

可以看到握手成功。

通过这一次实现握手的旅程，我们发现，TLS在密码学上可谓固若金汤。最后一定可以100%确保对方有了正确的加密密钥。但是，tls在密码学上固若金汤，并不是说tls实现固若金汤，更不是说使用tls的人写的程序固若金汤。想要MITM攻击TLS的人大可放心，世界上漏洞百出的TLS程序还是多如牛毛的。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/10/06/ssl-tls-2/">
                                    <p class="title is-2">SSL/TLS(二) 证书里都有啥 <span class="tag is-white is-pulled-right"><small>October 06, 2019</small></span></p>
                                    <p class="subtitle"><small>上回说到SSL通过<strong>证书（certificate）</strong>验证服务器或客户端的身份。今天就来解答两个问题：

1.证书是什么？

2.如何使用证书验证服务器（少见地，也可能是客户端）的身份？

<h2 id="证书是什么里面有什么"><strong>证书是什么？里面有什么</strong>？</h2>

首先，我们用openssl自己造一张证书：

<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl genrsa -out server.key</pre>

openssl是什么不用我多说，genrsa指产生rsa密钥。输出到server.key中。这个输出的文件写的是“私钥”，其实里面公私钥和生成公私钥的数应该是都有的。

看一下里面有什么：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">cat server.key</pre>

输出：

<pre class="EnlighterJSRAW" data-enlighter-language="no-highlight" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEApSUo2NghUOYaQGhL6WwLzDDtD1SxEibolifYW4XacaeN3suz
a/5MD5pvTW6dGVf1ah4vfPEqMbG3tglpE+1bQG2Aqy5p+ODcx/4f7rDBMt/Lgthy
QuSXILwTxVE88CthMwnFRSxARAWjQk74CEOQMLRKpS7SnizPP9hTQE0CUi+KXngR
WI9Za20D5gsx4Fzb3w1phNPXZvouBKK2Zsj1sohqVxz8DH5h28/iU3Ynk0tUxmGU
hJJWycOC/NImKeYVhzGN3rFWWcW6lXT9lFoieYuEdcp43kLA3aRzF4cTq0ln//6H
lORJN+uvNqv74NcBax/TbGv9zgUShjr5NkAHLwIDAQABAoIBACL9sp/ve2+msZ0/
/AWjTQSgwTnkWfhcoh9epesOe3Blbhvs0UFqijcsI7UmYMcD6g3oA2vXtXb+DszV
RZxhSFpoWUDr/qwrCNyfLajnbqgW3woEToF56cOX1iCSy/SfXGLyCQhVDfDbuPHN
xaQKnLyVFtPVDe9R0z/V2B3hs0IyVVDC8rJWkHDJ1YteWnNK5UJjsCZB4mhB3crC
kx/JxBMllcLN1DCsIIHliMfwDZa6xUZ37bHCD3Ch3Kmz1Vr6IT8CHjq7EEpHi2Vb
jLmQKl/LUdg3qCS0H8etmUPeKrc1brdxAUUUokNFvYOssyCeZr8PBJW1CieUvjrt
rj1BerECgYEA1SSl17nREmIIHGT/7VJepZfSF5jW3lkWijMGcciKKlsVwS9BrftX
415MDAaTaVWuR+JwicG3MFY/z1U6bHEu3sGpvoFI9R9eqvr8ofiRBdo6avR+kEtk
rEx8rqQ0Yt7pt+RN8ReswROfLytOztAHBrfwsivMYorHg+IeuOGKaNMCgYEAxlnb
mbiHutzPrbQ5SXcSJkCTzVUSYg/pgGkSjfL/MXWUDL0oWTFoQFxwuZ+4khdCpBQJ
crVKs6guGUfwPB8nmD1DuNuFmadl9fYBTDZosYw5EOK4fSjuJcC7MyYpPHFfLFAN
fciVmoFvxZhbdxRlzPPAMIpyjUbfy8fEU+R6LrUCgYEApLKR19VEwZCwtcgxnl+E
tS5QcF1wwxVR/m4ZL7kHUl1ZvRJYDSlnq1CFMNGv/LfxWKiXz0q51AcBfaNc5si6
r/Qzxvo9tvOLglE4/6uD3GLZuyW72qH3Y9AilAxcUn3vWWJ3+7EQk40m9xre5Z4H
n+BohDSl1QtpyfXjSXc2LXMCgYBG+cJ92C0hbYAW/SV+p0/kRjldQTLJyj3YyEBu
cORmM1ed01YLzIUseqePlJq8E/yxr8XNuReY//Y276oEKXXGoS2JiWveFquCftvq
BJIj7jRBWY+AodPNyJBz9hTNXxgaSC77snnuBqETSLh5/N+MnjBIblIdQZ41Ui9r
gZdC/QKBgB3Ty8gu+c68YfTIG3Qzn9ai1iUc6ZeOczPH0H6jdRXBVptD7Ms7PPbp
Pkjj3mea9lAC1Y6der0fBZ+gRYQNhO0Z/vlgWkWSpyic+K5FBlDasZTDSyknLPNO
kfQpMWI6YrnUe8w9qwPxL5J5RFDzZmJvtBSeN3PAzzitydTKdXmz
-----END RSA PRIVATE KEY-----</pre>

看来里面只有私钥，奇怪的是这里面似乎只有可见字符。查询资料后得知，这是BASE64编码后的结果：

<blockquote class="wp-block-quote">
  
    <strong>Base64</strong>是一种基于64个可打印字符来表示<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E8%BF%9B%E5%88%B6">二进制数据</a>的表示方法。
  
</blockquote>

如果想要看里面真的有什么，还是需要openssl的帮助：

<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl rsa -in server.key -text</pre>

这命令会将公私钥一同打出。

好，我们已经有了密钥对，可以来自己签一张证书了。

<pre class="EnlighterJSRAW" data-enlighter-language="shell" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl req -new -key server.key -out server.csr</pre>

注意，这个命令是在生成一个“证书请求”。填好必要信息后就有了server.csr

下面，用自己的私钥对这个“证书请求”签名，得到证书：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl x509 -req -in server.csr -out server.crt -signkey server.key -days 3650</pre>

这“证书请求是”什么东西呢？简单地说， “证书请求”和证书是很相近的，或者说，“证书请求”就是未经签名的证书。我们将想要写入的身份信息写入“证书请求”，然后交给CA进行验证和签名后，就有了证书。要理解具体的过程，需要看一下证书的定义：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Certificate  ::=  SEQUENCE  {        
tbsCertificate       TBSCertificate,        
signatureAlgorithm   AlgorithmIdentifier,
signatureValue       BIT STRING  }
 </pre>

这是RFC 5280中对于证书的定义，这种奇怪的表示方法，叫做ASN.1，可以理解为一种表示数据的方法（其实在我看来就是定义数据结构……），也就说，证书，就是tbsCertficate 后面接 signatireAlgorithm 再后面接 signatureValue。

具体是什么样的过程呢？简单的说，就是openssl对“证书请求”进行了一下加工，将对应的部分填入tbsCertificate。再根据请求的签名算法，对证书进行签名。其中，所请求的签名算法，就是signatureAlgorithm字段。

可以看到，这个过程的重点，是CA校验“证书请求”的真实性，并进行签名。CA如何校验“证书请求”的真实性呢？或者说，“证书请求”的请求者，必须要满足什么条件呢？

用下面的命令查看“证书请求”的内容：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl req -in server.csr -noout -text</pre>

输出如下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Certificate Request:
    Data:
        Version: 0 (0x0)
        Subject: C=CN, ST=GuangDong, L=GuangZhou, O=Sun Yet-san University, OU=Stu, CN=google.com/emailAddress=ayanamists@gmail.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    ......
                Exponent: 65537 (0x10001)
        Attributes:
            a0:00
    Signature Algorithm: sha256WithRSAEncryption
         ......</pre>

想一想的话，这里面最重要的，无疑就是<strong>CN = google.com</strong>这个信息了。请求这张证书的请求者必须证明自己就是google.com（直接通过DNS解析），或者google.com这个域名的所有权归请求者所有（通过DNS的TXT记录）。

好，假设请求者可以证明这点，CA就可以签发证书了。现在只需要把证书最后的signatureValue填好，证书就完成了。具体来说，就是将之前做好的tbsCertificate用请求的hash算法取得摘要，再用自己的rsa私钥进行加密（也可以用别的非对称加密算法），将加密的结果填入signatureValue。

什么？RSA私钥还可以用作加密？这个……确实是的。用私钥加密后，可以用公钥解密。

最终产生的证书的内容，和“证书请求”的内容基本相同，用以下命令查看：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">openssl x509 -in server_.cer -text -noout</pre>

得到输出：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            99:2f:c7:9b:ed:6d:d0:93
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: C=CN, ST=GuangDong, L=GuangZhou, O=Sun Yet-san University, OU=Stu, CN=google.com/emailAddress=ayanamists@gmail.com
        Validity
            Not Before: Oct  6 07:23:29 2019 GMT
            Not After : Oct  3 07:23:29 2029 GMT
        Subject: C=CN, ST=GuangDong, L=GuangZhou, O=Sun Yet-san University, OU=Stu, CN=google.com/emailAddress=ayanamists@gmail.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    ......
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         ......</pre>

可以看到，主要的区别是多了一些字段，比如<strong>Issuer</strong>（用于表面签发者的身份），<strong>Serial Number</strong>（序列号）等等。

<h2 id="客户端如何根据证书验证服务端身份"><strong>客户端如何根据证书验证服务端身份？</strong></h2>

我们假设现在客户端在google上搜素什么东西。现在，服务端发送certificate。客户端收到了服务端www.google.com的一张证书。它是如何验证这张证书不是伪造的呢？

点击chrome浏览器的“锁”，你可以看到证书:<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191741.png" alt="" class="wp-image-325" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191741.png 475w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191741-254x300.png 254w" sizes="(max-width: 475px) 100vw, 475px" /> &lt;/figure&gt;

点击“证书路径”，你会看到：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191742.png" alt="" class="wp-image-326" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191742.png 349w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191742-300x101.png 300w" sizes="(max-width: 349px) 100vw, 349px" /> &lt;/figure&gt;

为什么会有三张证书呢？这就要说到证书链了。

刚才在介绍证书内容时，我们介绍了“签名”就是将证书 的tbsCertificate部分进行HASH，将结果用CA的私钥加密后的值。很自然地，如果客户端要验证这张证书并非伪造，那么可以用CA的公钥解密“签名”，将解密后的值（HASH_1）和自己进行运算的值（HASH_2）进行对比，如果相同，那么这证书就不是伪造的。

那么就会有一个问题：<strong>CA公钥从哪里获得？如何保证CA公钥是正确的？</strong>

证书链的引入就是为了解决这个问题。首先，我们制作一些私钥绝对安全的根证书，这些证书只能是自签的（也就是说，加密自己证书的私钥是自己的，上面的即使一张自签证书），这是因为在此之前没有任何证书可以为他们签名。

然后，用这些根证书签名一些“CA证书”，这些CA证书可以为别的证书签名，但他们不是自签的。证书的扩展（Extension）字段中有一个选项是<strong>Basic Constraints</strong>，定义如下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">BasicConstraints ::= SEQUENCE {        
cA                      BOOLEAN DEFAULT FALSE,        
pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
</pre>

只要这个字段中的cA选项为true，这张证书就可以为其他证书签名。也就是说，我们用root证书制作出cA选项为true的证书，就可以为其他证书签名了。这样就会有至少三级的证书链：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">目标网站的证书 &lt;= CA证书 &lt;= root证书</pre>

这样一来，浏览器只要维护好root证书，就可以通过root证书验证CA证书的真伪，进而验证目标网站的证书的真伪了。至于CA证书如何得到，其实有很多方法，大概有三个：

1.浏览器自己维护。

2.服务器发送自己的证书时，也发送ca证书。

3.通过authorityInfoAccess扩展字段发送ca证书的url:<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191744.png" alt="" class="wp-image-336" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191744.png 649w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191744-300x102.png 300w" sizes="(max-width: 649px) 100vw, 649px" /> &lt;/figure&gt;

不管具体用什么方法，只要证书链上的一环不匹配，浏览器就可以发送alert消息，直接断开连接。

如果证书验证成功，客户端还要校验证书是否被吊销，这可以通过上面那张图中的OCSP验证，不再多说。

等等！如果有人下载了google.com的证书，自己用了起来，会怎么样呢？

这也不用担心。因为证书里的公钥，是google.com的，不是他的。他是无法正确地解密客户端发送的pre-master-key的，进而，他无法正确地发送加密握手消息Finished，客户端会直接发送alert，断开连接。

经过了漫长的旅途，我们终于完全验证了服务端的身份。只要root私钥、CA私钥的安全无虞，CA没有乱发证书，这种验证，就是无懈可击的。

诶？似乎有个东西叫做CDN吧！比如你在访问本站的时候就使用了cloudflare的CDN。这个时候，客户端实际获得的，是CDN的证书。比如本站的：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191745.png" alt="" class="wp-image-340" /> &lt;/figure&gt;

这是怎么做到的呢？要知道，只要证书和域名不匹配，就会使得浏览器报错：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191746.png" alt="" class="wp-image-341" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191746.png 640w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-191746-300x255.png 300w" sizes="(max-width: 640px) 100vw, 640px" /> &lt;/figure&gt;

那么，cdn是怎么做到在我访问本站的时候，给出一张sni.cloudflaresll.com的证书的呢？

哈哈！虽然RFC5280没有明确说，但是一般的证书的<strong>Subject</strong>字段只有一个CN（可以理解为域名，但也可以是别的）在这里就是sni.cloudflaresll.com了。我们查看一下这张证书，会发现它在<strong>Subject Alternative Name</strong>字段别有玄机：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-231341.png" alt="" class="wp-image-343" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-231341.png 769w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-231341-300x69.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-06-231341-768x177.png 768w" sizes="(max-width: 769px) 100vw, 769px" /> &lt;/figure&gt;

这样一来，就可以让浏览器把这证书当作本站的证书了。

不过方便之余，细细一想也有点后怕：这cloudflare在我不知情的情况下，擅自发我域名的证书，如果有一天……

而且更让人担心的是，这时是客户端和cdn节点握手，然后cdn节点和我的服务器再握手，岂不相当于让cdn获得了我的数据？？

不过出于其他因素的考虑，cdn还是利大于弊的，这也是本站挂了cdn的原因。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/10/05/en1/">
                                    <p class="title is-2">SSL/TLS笔记(一) 加密！加密！加密！ <span class="tag is-white is-pulled-right"><small>October 05, 2019</small></span></p>
                                    <p class="subtitle"><small>在互联网的上古时代，大部分协议都是不安全的，其中就包括统治当今互联网的HTTP协议。HTTP协议直接明文传输ASCII码，是窃听和篡改的极好材料。在ARP攻击等等MIMT攻击成功之后，任何用HTTP协议传输的数据都会成为攻击者的待宰羔羊。

更糟的是，如果我们不信任ISP，那么数据的每一次路由都会产生危险。这不只是搞个弹窗吓唬人的问题，随着互联网的发展，越来越多的服务要依赖敏感信息的传输。如果没有某种程度上的加密，那么这些服务便无法成立。基于很多类似的理由，SSL/TLS应运而生。

SSL是一家公司的产品，SSLv1从未公开过，SSLv2有严重漏洞，SSLv3是SSL的最后一个版本，其后，它被IETF收编为了TLSv1.0，随后又有TLSv1.1，TLSv1.2，目前（2019年10月）TLSv1.3还未大规模部署。这篇文章主要介绍TLSv1.2。

TLS，也就是传输层安全，是一个三层上的协议，但它的下层一般是TCP协议（当然其实也可以是UDP协议），上层则一般是HTTP协议。读者可能认为TLS只是用作HTTPS的加密层，实际上它的上层可以是任何协议，只不过现今多用于http协议。（这就是为什么DNS over HTTPS和DNS over TLS是不一样的）它在安全方面有三个主要目的：

<ol>
  <li>对服务器和客户端的数据进行端对端加密，使得任何中间节点无法理解数据，防止窃听。</li>
  <li>通过证书的引入，验证服务端（有时也验证客户端）的身份。</li>
  <li>通过校验的引入，保证数据在传输过程中未被篡改。</li>
</ol>

探索TLS，就是一遍遍的问自己“TLS如何做到这三点的”。首先来解决第一个问题:

TLS如何保证数据是加密的？如何保证在攻击者监听了这个TCP请求的全过程时，攻击者仍然无法理解数据？

好吧，让我来做一次监听者。用浏览器打开<a href="https://cnnic.com.cn">https://cnnic.com.cn</a>，在Wireshark中抓包，看一下这个连接的全貌：<figure class="wp-block-image is-resized"></figure>

<img src="http://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213714-1024x415.png" alt="一次TLS连接" class="wp-image-214" width="869" height="352" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213714-1024x415.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213714-300x122.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213714-768x311.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213714.png 1345w" sizes="(max-width: 869px) 100vw, 869px" /> &lt;/figure&gt;

在WINDOWS下抓包每一个己方的包都会被捕捉两次，应该是wireshark的捕获有些问题，先不管这些，看一下这个连接：

前三个包是TCP握手，不用多说，第四个包叫做Client Hello，这是啥呢？

随便查一下资料，发现这是tls握手的第一个包。看来，要窃听数据，需要先学习一下tls握手的过程。<figure class="wp-block-image"></figure>

<img src="https://www.researchgate.net/profile/Wazen_Shbair/publication/321347130/figure/fig5/AS:631648328630324@1527608105567/The-TLS-handshake-protocol-messages-sequence.png" alt="" /> &lt;figcaption&gt;注：这图对于加密信息和未加密信息的划分是错误的&lt;/figcaption&gt;&lt;/figure&gt;

看上去有点复杂，实际上也有点复杂。不过好消息是，当我们理解了握手过程后，我们就理解了数据是如何加密的。

只能硬着头皮上了!

第一个包叫做Client Hello，这是干什么的呢？用wireshark看看有啥吧。<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213715.png" alt="" class="wp-image-219" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213715.png 583w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-213715-300x172.png 300w" sizes="(max-width: 583px) 100vw, 583px" /> &lt;/figure&gt;

哇！一个handshake头里竟然有这么多内容，要学到什么时候才能掌握啊？但又有一个好消息，下面都是“Extension”，在大部分时候，extension都是不用重点关注的。不然为啥不放在不是扩展的参数里面呢？那就先看看上面的字段。

1.<strong>Handshake Type</strong>，这不用多说，就是来标识握手进入哪一阶段的。

2.<strong>Length</strong> 这也不用多说。

3.<strong>Version</strong>, 不用多说。

4.<strong>Random</strong>，听名字就知道这是一个随机数，而且显然是客户端产生的。它是干什么的呢？先按下不表。

5.<strong>Session ID Length 和 Session ID，</strong>这和对话恢复有关，按下不表。

<ol>
  <li><strong>Cipher Suites Length 和 Cipher Suites，</strong>这似乎到了重点了！这长度这么长（34个字节），看看都有啥：<figure class="wp-block-image"></figure></li>
</ol>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21376.png" alt="" class="wp-image-228" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21376.png 616w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21376-300x178.png 300w" sizes="(max-width: 616px) 100vw, 616px" /> &lt;/figure&gt;

34 = 17 * 2，看来每一个选项都有两个字节（<s>废话，图上都是四个十六进制数，可不就是两个字节吗）</s>，这Cipher的意思，是密钥，密钥套装，岂不就是加密方式套装……仔细看看<a href="https://tools.ietf.org/pdf/rfc5246.pdf">RFC5246</a>，你会发现这选项的原型是<strong>TLS_NULL_WITH_NULL_NULL</strong>，看来，每个选项都是分为三个部分的。比如说，

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">TLS_RSA_WITH_AES_256_CBC_SHA</pre>

肯定就是表示RSA和什么 什么。但是后面的怎么划分呢？不用着急，求助一下搜索引擎，<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21377.png" alt="" class="wp-image-231" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21377.png 801w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21377-300x126.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21377-768x322.png 768w" sizes="(max-width: 801px) 100vw, 801px" /> &lt;/figure&gt;

哈哈，这样的话，肯定就是AES-256-CBC 和 SHA了!

那新的问题就来了，为什么要发这么多呢？聪明的你肯定猜到了。这种要商量用啥的协议经常是一方宣示自己可以用啥，另一方在一方的宣示中选一个。是不是客户端在宣示自己可以用这17种方式，然后让服务端选一个呢？是不是呢？让我们看看第二个包 <strong>Server Hello</strong>吧！<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21378.png" alt="" class="wp-image-240" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21378.png 661w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21378-300x105.png 300w" sizes="(max-width: 661px) 100vw, 661px" /> &lt;/figure&gt;

Bingo!服务端只回复了一种方式，果然是在客户端提供的17种方式中选择了一种。可以看到这个包和上一个的头部没啥太大差别，只不过扩展少了很多，随机数变了而已。

下一个包是什么？是TLS的核心：<strong>Certificate</strong>。这证书可不是一般的东西，但我们留到下一篇文章研究。现在要知道的是，这证书里有一个宝贝：客户端的公钥。公钥是什么？咳咳，如果这个也不知道，就请自行查询吧。

那么在证书发送完成后，服务端（如果采用RSA）就会发送一个<strong>Server Hello Done</strong>，表示我的事情已经做完了，下面看你（客户端）表演了。

客户端在收到这个包（之前没有收到要求客户端的证书的请求）后，会发送一个<strong>Client Key Exchange</strong>。这个包，毫不夸张地说，是握手中最关键的一个包。先看看里面有什么：<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21379.png" alt="" class="wp-image-249" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21379.png 730w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21379-300x49.png 300w" sizes="(max-width: 730px) 100vw, 730px" /> &lt;/figure&gt;

emmm……这么简单就说是关键，不脸红吗？还真不脸红，因为生成加密的密钥靠的就是这个。

下面开始我的半吊子密码学秀。

首先，上面的AES-256-CBC是啥呢？求助一下维基：

<blockquote class="wp-block-quote">
  
    <strong>高级加密标准</strong>（英语：<strong>A</strong>dvanced&nbsp;<strong>E</strong>ncryption&nbsp;<strong>S</strong>tandard，<a href="https://zh.wikipedia.org/wiki/%E7%BC%A9%E5%86%99">缩写</a>：AES），在<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6">密码学</a>中又称<strong>Rijndael加密法</strong>，是<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E8%81%94%E9%82%A6%E6%94%BF%E5%BA%9C">美国联邦政府</a>采用的一种<a href="https://zh.wikipedia.org/wiki/%E5%8D%80%E5%A1%8A%E5%8A%A0%E5%AF%86">区块加密</a>标准。这个标准用来替代原先的<a href="https://zh.wikipedia.org/wiki/DES">DES</a>，已经被多方分析且广为全世界所使用。经过五年的甄选流程，高级加密标准由<a href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E5%AE%B6%E6%A0%87%E5%87%86%E4%B8%8E%E6%8A%80%E6%9C%AF%E7%A0%94%E7%A9%B6%E9%99%A2">美国国家标准与技术研究院</a>（NIST）于2001年11月26日发布于FIPS PUB 197，并在2002年5月26日成为有效的标准。2006年，高级加密标准已然成为<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">对称密钥加密</a>中最流行的<a href="https://zh.wikipedia.org/wiki/%E6%BC%94%E7%AE%97%E6%B3%95">算法</a>之一。
  
</blockquote>

看来也就是一种对称加密算法。对称加密也就是说有一个密钥就可以搞定加解密。那看来256就是说，密钥是256位的。这时就可以联想到有个说法说，为了性能，TLS加密实际上采用的对称加密算法，但是对称加密的密钥是非对称加密的。AES-256-CBC恐怕就是那个“对称加密算法”了。

这个Pre-Master就是256位的，会不会它就是密码呢?即使是，也应该是用公钥加密后的吧。

咦？似乎得到答案了呢！客户端生成一个对称加密的密钥，加密以后送给服务端，依据非对称加密的特性，这岂不就只有服务端可以解密？

这是比较接近的答案。但是，TLS并不是这么做的。查看一下RFC 5246:

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">struct {
 ProtocolVersion client_version;
 opaque random[46];
 } PreMasterSecret;</pre>

看来这实际上是版本+随机数。那么这个东西是怎么产生密钥的呢？

再看RFC 5246:

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">master_secret = PRF(pre_master_secret, "master secret",
 ClientHello.random + ServerHello.random)[0..47];</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">key_block = PRF(SecurityParameters.master_secret,
 "key expansion",
 SecurityParameters.server_random +
 SecurityParameters.client_random);
</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">client_write_MAC_key[SecurityParameters.mac_key_length]
 server_write_MAC_key[SecurityParameters.mac_key_length]
 client_write_key[SecurityParameters.enc_key_length]
 server_write_key[SecurityParameters.enc_key_length]
 client_write_IV[SecurityParameters.fixed_iv_length]
 server_write_IV[SecurityParameters.fixed_iv_length]</pre>

不知道你什么感觉，但是我看到这个的时候，感觉只有一个：这都是什么？PRF是什么？master_key是什么？最后一堆东西又是什么？

好。我们先来看PRF，查询一下维基，你会发现甚至没有中文版：

<blockquote class="wp-block-quote">
  
    In&nbsp;<a href="https://en.wikipedia.org/wiki/Cryptography">cryptography</a>, a&nbsp;<strong>pseudorandom function family</strong>, abbreviated&nbsp;<strong>PRF</strong>, is a collection of&nbsp;<a href="https://en.wikipedia.org/wiki/Efficiently-computable">efficiently-computable</a>&nbsp;<a href="https://en.wikipedia.org/wiki/Function_(computer_science)">functions</a>&nbsp;which emulate a&nbsp;<a href="https://en.wikipedia.org/wiki/Random_oracle">random oracle</a>&nbsp;in the following way: no efficient algorithm can distinguish (with significant&nbsp;<a href="https://en.wikipedia.org/wiki/Advantage_(cryptography)">advantage</a>) between a function chosen randomly from the PRF family and a random oracle (a function whose outputs are fixed completely at random). Pseudorandom functions are vital tools in the construction of&nbsp;<a href="https://en.wikipedia.org/wiki/Cryptographic_primitive">cryptographic primitives</a>, especially secure&nbsp;<a href="https://en.wikipedia.org/wiki/Encryption">encryption schemes</a>.
  
</blockquote>

硬着头皮看完了，我觉得还不是很懂，这是一“族”输出随机数的函数吗？幸好RFC 5246里有一个PRF的定义：

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">P_hash(secret, seed) = HMAC_hash(secret, A(1) + seed) +
 HMAC_hash(secret, A(2) + seed) +
 HMAC_hash(secret, A(3) + seed) + ...</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">PRF(secret, label, seed) = P_&lt;hash&gt;(secret, label + seed)</pre>

看到这里我终于有点懂了。首先这个HMAC_hash函数是“带密钥的hash函数”。也就是说，如果密钥不同，hash的结果一定不同，其实也可以想成受两个参数影响的hash函数。然后这个A(n)是递归定义的：

<blockquote class="wp-block-quote">
  
    A() is defined as:
  
  
  
    A(0) = seed
  
  
  
    A(i) = HMAC_hash(secret, A(i-1))
  
</blockquote>

<strong>（以上+表示连接，比如说a+b = ab）</strong>

这个P_hash函数其实是很简单的。因为HMAC_hash函数只能生成定长的输出，要想得到变长的输出，就要想点办法（像P_hash一样去构造）。P_hash就是“变长的HMAC_hash的函数”。这里举个例子，比如说HMAC_hash的输出是48位的，你想要一个100位的，那就让N = 3，最后得到144位输出，然后取前100位就好啦。（当然，严格来说P_hash的输出长度只能是HMAC_hash函数的整倍数）

理解了P_hash，下面的PRF就水到渠成了。因为这个PRF只是把自己的第二和第三个参数连接起来，再把自己的第一个参数和连接起来的东西作为P_hash的参数。

这样我们就知道了PRF是个什么东西，它确实是一个伪随机生成函数，而且生成的长度是不定的。

回到那三组代码：

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">master_secret = PRF(pre_master_secret, "master secret",
 ClientHello.random + ServerHello.random)[0..47];</pre>

这是说，master_key是P_hash(pre_master_secret, “master secret”+ClientHello.random + ServerHello.random)的输出取前48位。至于这两个random，还记得我们分析Client Hello 和 Server Hello时的情况吗？

然后下面的事情就更简单了，我们把master_key作为P_hash的第一个参数，生成一个符合要求长度的key_block，把这个key_block顺序分为6组（字面意思），生成下面的东西：

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">client_write_MAC_key[SecurityParameters.mac_key_length]
 server_write_MAC_key[SecurityParameters.mac_key_length]
 client_write_key[SecurityParameters.enc_key_length]
 server_write_key[SecurityParameters.enc_key_length]
 client_write_IV[SecurityParameters.fixed_iv_length]
 server_write_IV[SecurityParameters.fixed_iv_length]</pre>

名字里都带key了，肯定就是加解密用的了。具体每一个是什么作用，这里不再多说。

注意，上面的运算，是服务器和客户端同时都在做的。所以他们共享同一组密钥。

现在是不是皆大欢喜了呢？似乎还有一个问题，那个<strong>TLS_RSA_WITH_AES_256_CBC_SHA</strong> 最后的 <strong>SHA</strong>是什么呢？恐怕读者知道这应该是哈希算法吧，注意到HMAC_<strong>hash</strong>，嗯？<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21380.png" alt="" class="wp-image-289" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21380.png 647w, https://blog.ayanamists.xyz/wp-content/uploads/2019/10/批注-2019-10-05-21380-300x126.png 300w" sizes="(max-width: 647px) 100vw, 647px" /> &lt;/figure&gt;

但实际上，这个SHA指的是HMAC-SHA1，它被用作MAC算法，而PRF使用的HMAC算法则由协议版本决定，比如tls1.2是HMAC-SHA256。

好了好了，说了这么多，简单总结一下 <strong>RSA_WITH_AES_256_CBC_SHA</strong> 加密的核心：

客户端产生一个随机数作为<strong>pre_master_key</strong>，将它用服务端公钥加密后送给服务端，然后客户端和服务端同时用基于<strong>HMAC-SHA</strong>的PRF产生<strong>master_key</strong>，再用<strong>master_key</strong>和随机数作为PRF的输入得到六个密钥，用于<strong>AES-256-CBC</strong>加密。以后的通信，都用<strong>AES-256-CBC</strong>加密，具有了反窃听的特性。只要私钥是安全的，就只能有客户端和服务端进行解密。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/10/04/trap/">
                                    <p class="title is-2">记录一下最近踩的坑 <span class="tag is-white is-pulled-right"><small>October 04, 2019</small></span></p>
                                    <p class="subtitle"><small>这博客很久没更新了，一方面是由于手里有两台VPS、一个域名，一直没有想好怎么分配，怕有一天心情不好将这个WP撤掉；另一方面是因为感觉写博客有点浪费时间，平常的日子有点不太愿意写。

今天终于配置好了域名分配、CDN加速等等事项，再也不用担心第一个问题。现在也正好是国庆，也有写博客的时间了，于是就有了这篇东西。

最近踩了不少的坑，但是最令我痛心的是我的两次VPS误操作。为什么用痛心这么严肃的词语呢？因为这两次误操作让我不得不重装VPS的系统，直接使得我暑假对它的经营付诸东流。

先看看第一次误操作吧。记得那天我将VPS上的auth.log下载到了本地，用ruby写了个脚本随便分析了一下，发现居然有1000多个ip曾经试图登录过我的主机，其中欺人最甚的218.92.0.186居然试了1192次……又联想到我的密码很弱、用户名和域名有关系，我果断将ssh的密码登录关闭了，改用公钥登录。增加安全性当然是好事情，但有时候过于追求安全反而会发生一些意想不到的情况。为了进一步提高安全性，我决定将SSH监听的端口由22改到一个大端口上。就在我修改、重启ssh完成后，敲下 ^D的一刹那，我意识到出大事了。为什么呢？我的VPS配置了防火墙，只允许几个端口入站，而我刚刚改成的那个端口，不在此列！

也就是说，这次改动过后，我就无法用SSH登录了。我联系了superVPS的工作人员，得知他们也无法处理，于是只好重装系统……

其实也许有一个解决问题的方法。我的VPS上不是部署了V2RAY吗？如果我们配置了

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">iptables -A INPUT -i lo -j ACCEPT</pre>

那么就是可以使用V2RAY做代理在内部访问ssh的端口的。SSH命令如下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">ssh -o ProxyCommand="nc -X 5 -x localhost:YourPort %h %p" YourUser@YourIp</pre>

当然上面的-X 5 socks5代理，要是http代理就是其他的选项了。

这就是第一次误操作。如果说第一次误操作的源头是不小心的话，那么第二次误操作的源头恐怕是对于Linux的了解不足了。

再讲故事之前，容我先问一句。能看到这里的读者们想必都是知道在Linux中，..表示上层目录。那么这个“表示”，究竟只是一种“表示”，还是“就是”呢？也许这种问法可能还比较晦涩。读者想必也知道目录就是一种特殊的文件，那么 .. 和上层目录的关系，究竟是一个链接（先不论软硬），还是只是将上层目录的一些特性复制了过来呢？

无论读者有什么答案，我先讲故事。为了传输一些文件，我配置了ftp。作为一个立志于搞安全的人，我绝对不会做直接用日常用户登录家目录的事。因为ftp密码明文传输，非常危险。基于此我创建了一个用户，并且把他的家目录权限设为了755。感觉这似乎不很过瘾，最理想的情况是该用户登陆后不能进入上层目录。那么，为了尽可能简单，我直接输入了

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">sudo chmod 700 ..</pre>

打下这命令后我就感觉事情似乎有点不妙，因为700似乎有点严厉了。事情和我想得一点不差，在敲下这命令后，无论我做什么，都会出现权限错误。最后，我只好重装了系统。

这是为什么呢？参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html</a>的说法，..文件是上层文件夹的一个硬链接。这也就是说，他们的权限是一样的，你改变一个的权限，另一个的权限也会跟着改变，而这个时候，我们的上层文件夹，叫做 /

因为这个时候/已经不能读取，所以所有基于/的路径都不能读取，无论我们是想要用su还是sudo su来变成root用户，在这之前bash都要去exec对应的可执行文件，而这个时候就会用到基于/的绝对路径，在开始读取/的时候，我们就会遇到权限错误了。换句话说，除非你^alt+F[1-6]用root来登录，否则都是在做无用功。而VPS是不可能做到这一点的……

这两次误操作，都是由于我过度追求安全，而忽视了其他潜在问题导致的。话又说回到森口阿姨的那句歌词“ 見知らぬ力に流されて 心がどこかへはぐれてく ”，哈哈，对于不很了解的力量，我们还是谨慎使用吧！
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/08/09/nine/">
                                    <p class="title is-2">解九连环 <span class="tag is-white is-pulled-right"><small>August 09, 2019</small></span></p>
                                    <p class="subtitle"><small>“九连环”是一种传统游戏，我上周在亲戚家发现。它的构造比较复杂，但实际上规则却很简单，即只有下面的几种情况才可以对编号为 i 的环进行操作：

i == 1, 无论后面何种情况，都可以解下或放上它。

i == 2，若 i==1的环解下，则它可以与 i == 1的环一同被放上；若i==1的环放上，则它可以同 i==1的环一同解下.

i &gt; 2，当 前 i-2 个环被解下，第 i-1 个环被放上时，它可以被解下或放上。

基于此，我们编写程序解决：

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">#include &lt;bits/stdc++.h&gt;

void lock(int);
void unlock(int);

int count = 0;
void lock(int n)
{
    if (n == 1)
    {
        std::cout &lt;&lt; "lock 1\n";
    }
    else if (n == 2)
    {
        std::cout &lt;&lt; "lock 1 and 2\n";
        count++;
    }
    else
    {
        lock(n - 1);
        unlock(n - 2);
        std::cout &lt;&lt; "lock" &lt;&lt; n &lt;&lt; std::endl;
        lock(n - 2);
    }
    count++;
}

void unlock(int n)
{
    if (n == 1)
    {
        std::cout &lt;&lt; "unlock 1\n";
    }
    else if (n == 2)
    {
        std::cout &lt;&lt; "unlock 1 and 2\n";
        count++;
    }
    else
    {
        unlock(n - 2);
        std::cout &lt;&lt; "unlock" &lt;&lt; n &lt;&lt; std::endl;
        lock(n - 2);
        unlock(n - 1);
    }
    count++;
}

int main()
{
    int n;
    std::cin &gt;&gt; n;
    unlock(n);
    std::cout &lt;&lt; count &lt;&lt; '\n';
}</pre>

输出：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">9
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock7
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock6
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock9
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock6
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock7
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock6
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock8
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock6
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock7
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
lock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock6
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
lock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
unlock5
lock 1 and 2
unlock 1
lock3
lock 1
unlock 1 and 2
unlock4
lock 1 and 2
unlock 1
unlock3
lock 1
unlock 1 and 2
341</pre>

最后341步的结论和现有的是一样的。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/08/07/linux-net-1/">
                                    <p class="title is-2">Linux 网络编程的getaddrinfo()函数 <span class="tag is-white is-pulled-right"><small>August 07, 2019</small></span></p>
                                    <p class="subtitle"><small>最近学习socket编程，首先遇到的就是getaddrinfo()这个函数。某些教程上将它的作用称为“ 它帮你设定之後需要的 struct” 。其实这个函数的作用是为了下面的工作做准备。这个函数根据已有的信息设定了了 addrinfo 这个结构体。它做的主要工作是：进行DNS查询，将主机名解析为ip地址（这需要联网），并将其他信息一并填入addrinfo结构体。

先看看声明：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">extern int getaddrinfo (const char *__restrict __name,
            const char *__restrict __service,
            const struct addrinfo *__restrict __req,
            struct addrinfo **__restrict __pai);</pre>

可以看到，第一个参数是主机名（或域名），第二个参数是服务名（端口名）。第三个和第四个参数很奇怪，一个是addrinfo* 类型，另一个则是addrinfo** 类型，这是为什么呢？

这就要说起这个函数的结果如何记录的问题。addrinfo的声明如下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">struct addrinfo
{
  int ai_flags;            
  int ai_family;        
  int ai_socktype;       
  int ai_protocol;        
  socklen_t ai_addrlen;       
  struct sockaddr *ai_addr;    
  char *ai_canonname;       
  struct addrinfo *ai_next;    
};</pre>

注意到最后的一个成员ai_next，这似乎是被设计来串成链表的。实际上也确实是这样。由于一个主机名可能对应着不同的地址（最简单的情况就是一个ipv4地址，一个ipv6地址）被填入的addrinfo 结构的数量是不确定的。所以为了方便，设计者用一个指向addrinfo*的指针作为参数传入，以便将链表的头指针写调用者提供的地址。

这就是第四个参数了，那么第三个参数是什么呢？这个函数查找到ip后，会将连接需要的所有信息填好，而这“所有信息”也是需要调用者提供的。第三个参数指向一个已经写好部分信息的addrinfo结构体，通过这个结构体中的信息决定结果链表如何填写。

那么，很自然的，我们会问，这个函数可以同时进行ipv4 和 ipv6填写吗？答案当然是可以的。但是，它真正写入的是sockaddr结构体。设计者们创造了两个马甲：sockaddr_in和sockaddr_in6，分别对应ipv4和ipv6的情况，很多时候需要通过转型拿到具体的地址，比如，需要ipv4的地址时，我们用这种写法：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">((struct sockaddr_in *)(p-&gt;ai_addr))-&gt;sin_addr</pre>

/*这里吐槽一下，这样实在是不太漂亮*/

学会了这个函数，我们就可以编一个查询ip地址的小程序：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">#include&lt;sys/types.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netdb.h&gt;
#include&lt;bits/stdc++.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;netinet/in.h&gt;

int main(int argc, char *argv[])
{
    addrinfo hints, *res, *p;
    int ret;
    char ipstr[INET6_ADDRSTRLEN];

    /* if (argc != 2)
    {
        std::cout &lt;&lt; "bad input\n";
        exit(-1);
    }*/

    memset(&amp;hints, 0, sizeof(hints));
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_CANONNAME;
    ret = getaddrinfo(argv[1], "80", &amp;hints, &amp;res);

    if (ret)
    {
        fprintf(stderr, "%s", gai_strerror(ret));
        exit(-1);
    }

    for (p = res; p != NULL; p = p-&gt;ai_next)
    {
        if (p-&gt;ai_family == AF_INET)
        {
            inet_ntop(p-&gt;ai_family,
                      &amp;(((struct sockaddr_in *)(p-&gt;ai_addr))-&gt;sin_addr),
                      ipstr, sizeof(ipstr));
            std::cout &lt;&lt; "IPV4: " &lt;&lt; ipstr &lt;&lt; '\n';
        }
        else
        {
            inet_ntop(p-&gt;ai_family,
                      &amp;(((struct sockaddr_in6 *)(p-&gt;ai_addr))-&gt;sin6_addr),
                      ipstr, sizeof(ipstr));
            std::cout &lt;&lt; "IPV6: " &lt;&lt; ipstr &lt;&lt; '\n';
        }
    }

    freeaddrinfo(res);
}</pre>

运行结果：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">ayanamists@ubuntu:~/netLab$ ./b google.com
IPV4: 172.217.27.142
IPV6: 2404:6800:4012::200e
ayanamists@ubuntu:~/netLab$ ./b apple.com
IPV4: 17.172.224.47
IPV4: 17.142.160.59
IPV4: 17.178.96.59
ayanamists@ubuntu:~/netLab$ ./b www.baidu.com
IPV4: 182.61.200.7
IPV4: 182.61.200.6
ayanamists@ubuntu:~/netLab$ ./b chenxi.com
IPV4: 104.250.144.22
ayanamists@ubuntu:~/netLab$ ./b blog.ayanamists.xyz
IPV4: 178.128.88.147
</pre>
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/08/06/iredmail/">
                                    <p class="title is-2">使用iRedMail配置邮箱服务器 <span class="tag is-white is-pulled-right"><small>August 06, 2019</small></span></p>
                                    <p class="subtitle"><small>iRedMail是一个一键式配置邮箱服务器的解决方案。分为iRedMail（免费）、iRedMail Easy\Pro（付费），近日，我用iRedMail配置了本站的邮箱，将过程记录在此。

首先，我们要配置好一个二级域名作为邮箱服务器的主机名。鉴于后面邮箱的域名不能和主机名相同，这里不建议使用mail.mydomain.me（不然就要和我一样用别的作为邮箱的域名了）。添加一条DNS A类型记录，然后修改主机名即可。

有人可能会问了，为啥主机名一定要是一个二级域名呢？原因是iRedMail会自动创建证书和网页的服务，这个时候需要一个域名，它似乎是直接将主机名作为这个域名处理的。

后面的步骤很简单，直接wget下载脚本，然后bash运行即可。这里记录几个要点：

1.安装完成后用chown和chgrp将iRedMail.tips设为root所有，并设置440权限。

2.安装过程中iRedMail会自动设置防火墙，有别的网络服务（比如apache2服务器）时，其端口很可能会被防火墙封掉。

3.注意不要用弱密码。

重点是之后的步骤。用这样设置好的邮箱发邮件，几乎是100%被拒收。我们还需要配置以下几项服务：SPF、反向解析、DKIM、DMRAC。

反向解析：向服务器或VPS服务商发TICKET。

SPF、DIMM、DMRAC完全是靠添加DNS的TXT记录实现的，其实很简单，这里也不赘述了。

注：可以在 <a rel="noreferrer noopener" href="https://www.mail-tester.com/" target="_blank">https://www.mail-tester.com/</a> 上检测，按照他的说明配置，得10分基本就没问题了。

注2：测试时不要发标题是TEST的邮件，网易会拒收。

注3：自签的SSL证书会被拦截，推荐使用acme.sh创建SSL证书并替换原有的证书。 <a href="https://github.com/Neilpang/acme.sh">https://github.com/Neilpang/acme.sh</a>

这样配好之后，可以和gmail、qq、微软、网易互相发几封邮件，可以降低被拒收的可能性。

以后的计划：研究一下iRedMail的具体实现。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/07/25/ffff/">
                                    <p class="title is-2">编写程序验证《全部成为F》中的巧妙trick <span class="tag is-white is-pulled-right"><small>July 25, 2019</small></span></p>
                                    <p class="subtitle"><small>我们在写程序时，时常要用到文件操作。文件操作是一种I/O读写，必定要用到系统调用或API。在WinApi的CreateFile函数中

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">HANDLE CreateFileA(
  LPCSTR                lpFileName,
  DWORD                 dwDesiredAccess,
  DWORD                 dwShareMode,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  DWORD                 dwCreationDisposition,
  DWORD                 dwFlagsAndAttributes,
  HANDLE                hTemplateFile
);

</pre>

倒数第二个参数设置为 CREATE_ALWAYS时，创建的新文件会覆盖原有的同名文件。《终将成为F》就利用了类似的思想，构造了一个非常巧妙的结构。

假设一个监控程序P，它在每分钟开始的时刻创建监控文件，这个文件记录该分钟内的事件。考虑以下情况：在程序开始运行时，系统时间比标准时间快1分钟（这里的“快”指数值比标准时间大）。在程序运行的过程中，系统通过校准，将时间调整为了标准时间，会发生什么呢？

假设调整为标准时间的时刻是a:b:c（标准时间），那么该系统错误显示的时间就是a:(b+1):c。假设P在a:(b+1):00（系统时间）时刻创建的文件名为a:b+1，那么在系统正确显示后，在新的a:b+1时刻，系统会创建新的a:b+1文件。这样一来，实际上的a:b（标准时间）文件就被覆盖了。《全部成为F》的作者就用这样的构造，做出了一个密室。具体情况可参见小说或动画。

我在WINDOWS环境下编写了以下程序来验证这个构造的正确性：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">SYSTEMTIME time;
GetLocalTime(&amp;time);</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">while (true)
{
    while (true)
    {
        GetLocalTime(&amp;time);
        if (time.wSecond == 0 &amp;&amp; time.wMilliseconds == 0)
        {
            break;
        }
    }

    wchar_t* name = (wchar_t*)malloc(0xff);
    memset(name, 0, 0xff);
    wsprintf(name, L"Time is %02d：%02d", time.wHour, time.wMinute);

    HANDLE hFile = CreateFile(name, GENERIC_READ | GENERIC_WRITE, 
        0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, 0);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        GetError(0);
        exit(-1);
    }

    DWORD real = 0;     

    if (WriteFile(hFile, &amp;count, 4, &amp;real, NULL) == false)
    {
        GetError(1);
        exit(-1);
    }

    Sleep(1);
    count++;
    CloseHandle(hFile);
    free(name);
}</pre>

在运行前，我将系统时间调快了一分钟，并在运行时开启自动对时。结果成功地验证了该构造的正确性。<figure class="wp-block-image"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1024x161.png" alt="" class="wp-image-119" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1024x161.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-300x47.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-768x121.png 768w" sizes="(max-width: 1024px) 100vw, 1024px" /> &lt;/figure&gt; <figure class="wp-block-image is-resized"><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-2.png" alt="" class="wp-image-122" width="354" height="153" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-2.png 749w, https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-2-300x129.png 300w" sizes="(max-width: 354px) 100vw, 354px" /></figure>

2:55的计数为0，2：56的计数为1……系统在2：58调整为了正确的时间，按照前述，2：58的计数应该为4，因为计数为3的2：58文件被覆盖了。用WINHEX查看：<figure class="wp-block-image is-resized"></figure>

<img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1.png" alt="" class="wp-image-120" width="591" height="212" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1.png 909w, https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1-300x108.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/07/image-1-768x275.png 768w" sizes="(max-width: 591px) 100vw, 591px" /> &lt;figcaption&gt;4在前面是因为x86采取小端序，小端在前&lt;/figcaption&gt;&lt;/figure&gt;

这样来就验证了该结构的正确性。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/07/17/maxituan/">
                                    <p class="title is-2">魔偶马戏团：不幸的动画与伟大的原作 <span class="tag is-white is-pulled-right"><small>July 17, 2019</small></span></p>
                                    <p class="subtitle"><small>去年的十月新番中，有一部叫 《魔偶马戏团》的漫改动画特别地吸引我的目光。<figure class="wp-block-image"></figure>

<img src="https://image.gcores.com/c57c5b7f-d9e7-434e-88de-a78fa889543f.jpg?x-oss-process=style/original_hsat2x" alt="Related image" /> &lt;/figure&gt;

为什么呢？看到那个银发小姐姐了吗？她的声优正是曾经饰演过灰原哀、绫波丽、FAYE的林原惠美。这也是林原女王多年（自《昭和元禄落语君中》）后再次在长篇电视动画中担任主役。

<div class="wp-block-image">
  <figure class="aligncenter is-resized"><img src="http://img31.mtime.cn/ph/2016/08/25/114404.68927057_290X440X4.jpg" alt="Image result for æåæ ç¾" width="184" height="279" /><figcaption>林原惠美</figcaption></figure>
</div>

可惜，它失败的命运似乎从一开始就注定了。《魔偶马戏团》的原作是由著名漫画家藤田和日郎自1997年至2006年连载，用8年时间精心创作的、<strong>总计43卷、91幕</strong>的超长篇漫画，而动画组只做了<strong>36集</strong>。

作为对比，《进击的巨人》到马雷篇前的剧情总计<strong>22卷</strong>，而动画已有<strong>59集</strong>。在我的kindle上，《进击的巨人》一卷的页数在150-180之间，而《魔偶马戏团》在180-200页左右（<s>两位老师原谅我白嫖，为了赎罪会买正版的</s>）。也就是说，实际上《魔偶马戏团》的动画集数/漫画页数比不及《进击的巨人》一半。在这样的篇幅下，动画怎么可能原汁原味地表现漫画的故事？更不要说什么对漫画有所超越了。

例如第14集路西尔和德托勒的对决，有很多观众无法理解路西尔的死，更有甚者说什么“1换1”之类的话。其实早在路西尔、奇、鸣海坐飞机的那一幕中，路西尔就说过，白银如果死了，那么只有两种可能，一种是由失血过多或者别的原因引起的生命之水耗尽，另一种则是白银自己已经不想继续活下去。但动画删掉了这一部分台词，导致有人认为路西尔是被杀死的。其实德托勒那一刀根本无足轻重，路西尔死亡的原因是自己大仇得报，且已经厌倦了成为“和自动傀儡对战的另一种傀儡”的生活，因此已无留意了。

话虽如此，这部动画还是有一点功劳的：让人们再次回忆起了《魔偶马戏团》这部伟大的漫画。

“伟大”这两个字用在一部少年漫身上，是否有些过于沉重了呢？不，一点也不。《魔偶马戏团》的故事不缺少沉重。这部漫画虽有一定的浪漫主义色彩，但在它的故事中，没有所谓的坏人，有的只是在无可救药的迷恋、无可救药的追求和无可救药的命运的驱使下犯下罪行的人。它虽有着少年漫常有的英雄主义色彩，却并没有将其流之于表面，在刻画英雄的过程中，作者表达了他对成为英雄的代价和英雄背负着什么这两个命题的理解。而更抽象一些的命题，如对死亡的思辨、对人生的思考等等更是点缀在整个故事之中，让整个故事有了很强的思想性。

即使完全抛开故事的思想性，《魔偶马戏团》的剧情也足以支撑“伟大”二字。在作为铺垫的“起”之后，在“承”的内容中作者使用多线叙事，这里的多线叙事并不是指小胜线和鸣海线的并行，而是指推进故事情节发展的内在逻辑的交织。比如探寻自动傀儡和白银的起源和真相；消灭自动傀儡；寻找ZONAHAPHA症的真相；小胜的奇妙的身世的解释；小胜会遇到爱蕾诺的解释；小胜的爷爷和父亲是什么关系；小胜父亲离奇的死亡的真相；探寻柔石的下落……在“承”的内容中，作者不断地从各个侧面组织叙事，最后在撒哈拉沙漠之战中开始收线。

在小胜进入正二记忆之后，整个故事进入“转”。作者将其埋下的所有故事线全部收回，将之编成了一股七彩线。他讲述了一个极为宏大的、跨越200年的故事，将所有谜雾全部一扫而空。其强烈的前后呼应和严丝合缝的设定让人拍案叫绝。在剧情这一点上，《魔偶马戏团》的伟大是毋庸置疑的。

作者的塑造功力更是一流。路西尔对仇人杀人诛心、鸣海背负着众白银的信念击败四大元老、法兰西奴临终前的笑、小胜继承祖父的意志、奇一人对战三千傀儡等等场景浸透着真正的感情，在作者的笔下让读者为之动容，为之流泪。

可惜，这样伟大的漫画永远也等不到一部伟大的动画为其作注了。
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/index.php/2019/07/16/g-bug/">
                                    <p class="title is-2">消失的__free_hook=NULL:一个G++编译优化的BUG <span class="tag is-white is-pulled-right"><small>July 16, 2019</small></span></p>
                                    <p class="subtitle"><small>我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">chxAlloc::chxAlloc()
{
    //std::cout &lt;&lt; "invoke chxAlloc\n";
    void *begin =
        mmap(NULL, sizeof(allocChunk) * INIT_NUMBER + 0X10,
             PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if ((long long)begin == -1)
    {
        std::cout &lt;&lt; "error occur in mmap\n";
        exit(-1);
    }

    for (int i = 0; i &lt; INIT_NUMBER; ++i)
    {
        allocChunk *temp = (allocChunk *)begin;
        temp-&gt;nextPtr = fast_TARGET;
        fast_TARGET = temp;
        temp-&gt;sign = -TARGET;
        begin = ((char *)begin + sizeof(allocChunk));
    }
}</pre>

对GLIBC有了解的读者应该知道，这样其实是手工建立了一个大小为0x1010的fast_chunk链表。由于我不太了解全局对象的构造和其他初始化阶段的顺序，为避免出现问题，我在第一次调用deque的函数时才将malloc和free钩住。

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (__builtin_expect(count == 0, 0))
    {
        __malloc_hook = chx.chenxiAlloc;
        __free_hook = chx.chenxiFree;
        count++;
    }</pre>

在这样钩住之后，调用malloc就会调用到chenxiAlloc，调用free就会调用到chenxiFree. 如果申请或释放的大小不是0x1010（这里我们将自己的chunk_size设为-0x1010，在free的时候就可以检测到），我们就调用GLIBC的malloc和free:

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__malloc_hook = NULL;
void *ret = malloc(size);
if (ret == NULL)
{
    std::cout &lt;&lt; "error occur in glibc malloc\n";
    exit(0);
}
__malloc_hook = &chenxiAlloc;
return ret;</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (*((long long *)ptr - 1) &lt; 0)
 {
    *((void **)ptr - 2) = fast_TARGET;
    fast_TARGET = (allocChunk&lt;TARGET&gt; *)((void **)ptr - 2);
}
else
{
    __free_hook = NULL;
    free(ptr);
    __free_hook = &chenxiFree;
}</pre>

有趣的是，在使用O2编译优化的情况下，分配一个大小不为0x1010的块会出现意想不到的结果：free和chenxiFree反复相互调用，最终导致栈地址空间被用尽，产生segment fault.

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Program received signal SIGSEGV, Segmentation fault.
0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710) at malloc.c:3094
3094	malloc.c: No such file or directory.
(gdb) bt
#0  0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#2  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#3  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#4  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#5  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#6  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#7  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#8  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#9  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#10 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#11 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#12 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#13 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#14 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094</pre>

更有趣的是，如果不开启编译优化，上述行为就不会出现错误。基于此，笔者想到了GCC内嵌汇编中的__volatile__关键字。

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__asm__ __volatile__ (...);</pre>

这里的__volatile__表示后面的语句不作优化（可以理解为强制按指令顺序执行），但这个关键字并不是标准的C关键字，而是类似于__builtin__expected()的仅GCC实现的关键字。利用这个关键字是否可以实现不去优化呢？

遗憾的是，无论是查找中文还是英文资料，这个关键字都只用这一种用法。但令笔者眼前一亮的是，C/C++语言中有一个类似的标准关键字：volatile.

volatile是一个加在变量的声明前的关键字，类似于这样使用：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int volatile a = 0;</pre>

这表示变量a是“易变的”，也就是说，每次访问a时，必须到内存中访问，不可以用寄存器中的值。它多用于多线程环境中。为什么必须访问内存呢？假设a可以被T1和T2两个线程访问，T1首先将a的值写入EAX寄存器，但在T1使用a之前，T2更新了a的值，那么现在T1现在要使用a，应该使用内存中的更新后的值，而非EAX中的值。

笔者立刻修改了__malloc_hook和\__free_hook的声明，都加入了volatile：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">typedef void *(*mallocType)(unsigned);
extern volatile mallocType __malloc_hook;

typedef void (*freeType)(void *);
extern volatile freeType __free_hook;</pre>

问题果然解决了。可是为什么不加volatile会产生那么滑稽的错误呢？笔者进行了反汇编分析：

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) f 1
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
   0x000055555555df80 &lt;+0&gt;:	cmpq   $0x0,-0x8(%rdi)
   0x000055555555df85 &lt;+5&gt;:	js     0x55555555dfa8 &lt;_ZN8chxAlloc10chenxiFreeEPv+40&gt;
   0x000055555555df87 &lt;+7&gt;:	sub    $0x8,%rsp
   0x000055555555df8b &lt;+11&gt;:	callq  0x55555555b450 &lt;free@plt&gt;
=&gt; 0x000055555555df90 &lt;+16&gt;:	lea    -0x17(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv&gt;
   0x000055555555df97 &lt;+23&gt;:	mov    %rax,0x28e5f2(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555df9e &lt;+30&gt;:	add    $0x8,%rsp
   0x000055555555dfa2 &lt;+34&gt;:	retq   
   0x000055555555dfa3 &lt;+35&gt;:	nopl   0x0(%rax,%rax,1)
   0x000055555555dfa8 &lt;+40&gt;:	mov    0x28e871(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfaf &lt;+47&gt;:	sub    $0x10,%rdi
   0x000055555555dfb3 &lt;+51&gt;:	mov    %rax,(%rdi)
   0x000055555555dfb6 &lt;+54&gt;:	mov    %rdi,0x28e863(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfbd &lt;+61&gt;:	retq   
End of assembler dump.
</pre>

注意那句callq的上方，反汇编给出的语句是sub $8, %rsp, 也就是将rsp-8h，这语句的作用肯定不是将__free_hook置空，它其实应该在开头执行，是函数常有的抬高栈顶的操作。只是编译器检测出，另外的一条分支不需要抬高栈顶。所以只需要在这个分支做（这是一种编译优化策略，读者可自行查找相关资料）。那么我的那句\__free_hook = NULL去了哪里呢？正是因为这里没有置空，所以才导致了free调用chenxiFree，chenxiFree调用free的死锁。保险起见，我们再用IDA反编译一下：

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">else
  {
    free((void *)this);
    result = chxAlloc::chenxiFree;
    _free_hook = (__int64)chxAlloc::chenxiFree;
  }</pre>

果然如此，将__free_hook置NULL的操作竟然被编译器无视了。为什么会这样？笔者对编译原理了解很肤浅，难以解答这个问题。但是，这个问题确实可以通过加入volatile关键字来解决。很自然地，我们用加入后的反汇编代码做个对比：

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
=&gt; 0x000055555555df80 &lt;+0&gt;:	hlt    
   0x000055555555df81 &lt;+1&gt;:	cmpq   $0x0,-0x8(%rdi)
   0x000055555555df86 &lt;+6&gt;:	js     0x55555555dfb0 &lt;_ZN8chxAlloc10chenxiFreeEPv+48&gt;
   0x000055555555df88 &lt;+8&gt;:	sub    $0x8,%rsp
   0x000055555555df8c &lt;+12&gt;:	movq   $0x0,0x28e5f9(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555df97 &lt;+23&gt;:	callq  0x55555555b450 &lt;free@plt&gt;
   0x000055555555df9c &lt;+28&gt;:	lea    -0x23(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv&gt;
   0x000055555555dfa3 &lt;+35&gt;:	mov    %rax,0x28e5e6(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555dfaa &lt;+42&gt;:	add    $0x8,%rsp
   0x000055555555dfae &lt;+46&gt;:	retq   
   0x000055555555dfaf &lt;+47&gt;:	nop
   0x000055555555dfb0 &lt;+48&gt;:	mov    0x28e869(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfb7 &lt;+55&gt;:	sub    $0x10,%rdi
   0x000055555555dfbb &lt;+59&gt;:	mov    %rax,(%rdi)
   0x000055555555dfbe &lt;+62&gt;:	mov    %rdi,0x28e85b(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfc5 &lt;+69&gt;:	retq   
End of assembler dump.
</pre>

注意eip+12的位置，这一句话执行了__free_hook = NULL.

最后，用贝木泥舟式的话来说，从这次的事件中我应该得到的教训是：编译优化会产生BUG.
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                
                <div class="box">
                    <article class="media">
                        <div class="media-content">
                            <div class="content">
                                <a href="/jekyll-theme-blogfolio/2017/06/10/first-post/">
                                    <p class="title is-2">Hello World! <span class="tag is-white is-pulled-right"><small>June 10, 2017</small></span></p>
                                    <p class="subtitle"><small>Hey, it’s just my first post!
</small></p>
                                </a>
                            </div>
                        </div>
                    </article>
                </div>
                

            </div>
        </div>
    </div>
</section>
:ET