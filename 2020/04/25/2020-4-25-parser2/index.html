<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树 | aya ⊢ blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/highlight.css">

  
  <meta name="description" content="词法分析器  为什么要有词法分析器 如何构建一个词法分析器   语法分析器  语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树  递归向下解析器的情况 Yacc的情况   需要注意的几个问题  不要给Parser增加太多负担 最好不要实现Parser     词法分析器 词">
<meta property="og:type" content="article">
<meta property="og:title" content="让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树">
<meta property="og:url" content="https://ayanamists.xyz/2020/04/25/2020-4-25-parser2/index.html">
<meta property="og:site_name" content="aya ⊢ blog">
<meta property="og:description" content="词法分析器  为什么要有词法分析器 如何构建一个词法分析器   语法分析器  语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树  递归向下解析器的情况 Yacc的情况   需要注意的几个问题  不要给Parser增加太多负担 最好不要实现Parser     词法分析器 词">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-25T00:00:00.000Z">
<meta property="article:modified_time" content="2022-05-23T13:58:10.736Z">
<meta property="article:author" content="ayanamists">
<meta property="article:tag" content="编程语言实现">
<meta property="article:tag" content="PL">
<meta property="article:tag" content="Parser">
<meta name="twitter:card" content="summary">
  <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://use.typekit.net/ruq6mdv.css">
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>

<body>
  <div id="wrapper">
    <header id="header">
  <h1 id="title">
    <a href="/">aya ⊢ blog</a>
  </h1>
  <nav>
    
    
      
      <a class="nav-link" href="/">Home</a>
    
      
        <span class="nav-spacer">×</span>
      
      <a class="nav-link" href="/archives">Archives</a>
    
    
  </nav>
</header>

    <div id="content">
      
<article id="post-2020-4-25-parser2" class="article article-type-post" itemprop="blogPost" itemscope>
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h2 class="article-title" itemprop="headline name">
      让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树
    </h2>
  


        <div class="article-meta">
          <time class="article-date" datetime="2020-04-25T00:00:00.000Z" itemprop="datePublished">2020-04-25</time>

          
            × <span class="article-word-count">4.4k words</span>
            
            × <span class="article-time-to-read">17 minutes</span>
            
          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
      
        <ul>
<li><a href="#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">词法分析器</a>
<ul>
<li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">为什么要有词法分析器</a></li>
<li><a href="#%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">如何构建一个词法分析器</a></li>
</ul>
</li>
<li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">语法分析器</a>
<ul>
<li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98">语法分析器的基本问题</a></li>
<li><a href="#%e5%b8%82%e9%9d%a2%e4%b8%8a%e7%9a%84%e5%b8%b8%e8%a7%81parser">市面上的常见Parser</a></li>
<li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8">递归向下解析器</a></li>
<li><a href="#parser-combinator">Parser Combinator</a></li>
<li><a href="#parser-generator">Parser Generator</a></li>
<li><a href="#%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7%e8%a7%a3%e6%9e%90%e5%99%a8">算符优先级解析器</a></li>
</ul>
</li>
<li><a href="#%e4%bb%8e%e8%a7%a3%e6%9e%90%e6%a0%91%e5%88%b0%e8%af%ad%e6%b3%95%e6%a0%91">从解析树到语法树</a>
<ul>
<li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8%e7%9a%84%e6%83%85%e5%86%b5">递归向下解析器的情况</a></li>
<li><a href="#yacc%e7%9a%84%e6%83%85%e5%86%b5">Yacc的情况</a></li>
</ul>
</li>
<li><a href="#%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98">需要注意的几个问题</a>
<ul>
<li><a href="#%e4%b8%8d%e8%a6%81%e7%bb%99parser%e5%a2%9e%e5%8a%a0%e5%a4%aa%e5%a4%9a%e8%b4%9f%e6%8b%85">不要给Parser增加太多负担</a></li>
<li><a href="#%e6%9c%80%e5%a5%bd%e4%b8%8d%e8%a6%81%e5%ae%9e%e7%8e%b0parser">最好不要实现Parser</a></li>
</ul>
</li>
</ul>
<h2 id="词法分析器"><a class="markdownIt-Anchor" href="#词法分析器"></a> 词法分析器</h2>
<p>词法分析器，是将输入的字符串解析为符号串的工具；语法分析器，即parser，是将符号串解析为解析树（并将解析树映射为语法树）的工具。</p>
<h3 id="为什么要有词法分析器"><a class="markdownIt-Anchor" href="#为什么要有词法分析器"></a> 为什么要有词法分析器</h3>
<p>一般的编译器教科书，常常是先讲词法分析器，再讲语法分析器，顺带着讲讲生成文法。个人认为这是<strong>完全错误</strong>的。</p>
<p>我们必须要知道，我们这里提到的Parser解析的全部都是<strong>上下文无关文法</strong>（CFG），而词法分析器解析的是<strong>正则文法</strong>，我们还知道，<strong>所有的正则文法都是上下文无关文法</strong>，那么这就得出一个结论，因为Parser也可以解析正则文法，所以词法分析起是完全不需要的。</p>
<p>为了解释为什么需要词法分析器，我们必须考察一下市面上常见的各种Parser。</p>
<p>Parser从大的方面上分，有三个属性：</p>
<ul>
<li>定向/非定向</li>
<li>确定型/非确定型</li>
<li>自底向上/自顶向下</li>
</ul>
<p>其中非定向方法构建的Parser在程序语言中用的不多，这里不表。</p>
<p>如果你认真阅读过关于上一篇正则文法的文章，你会知道“确定型”和“非确定型”的区别在于“确定型”不需要搜索，时间复杂度是线性的；“非确定型”需要搜索，时间复杂度按你搜索的方法不同，从$$O(n<sup>2)$$到$$(O(e</sup>n))$$都有可能。如果从这个角度出发，那么这个解析器最好是确定型的。</p>
<p>但凡事有得必有失，确定型的解析器有一个天然劣势–<strong>不存在可以解析任何CFG的确定型解析器</strong>。这就要求我们必须对文法进行限制，以满足特定的解析器。</p>
<p>这种限制有时候是很不舒服的。而正则文法则不同，<strong>只要你的文法是正则文法，不需任何限制即可获得一个确定型解析器</strong>。</p>
<p>所以我们需要正则文法，来将字符串变为符号串，提前解决一些Parser解析起来很麻烦的东西。</p>
<h3 id="如何构建一个词法分析器"><a class="markdownIt-Anchor" href="#如何构建一个词法分析器"></a> 如何构建一个词法分析器</h3>
<p>如果你使用的语言有正则表达式支持，那就直接使用正则表达式构建即可；如果没有（常用的语言也就C没有了吧），建议使用flex之类的工具。</p>
<p>这里我们需要注意几个问题：</p>
<ul>
<li>正则表达式最好写在一起，否则和搜索没有区别。</li>
<li>如果你的正则表达式不支持捕获，那么是无法实现的。</li>
<li>注意错误处理，生成好看的错误。</li>
</ul>
<h2 id="语法分析器"><a class="markdownIt-Anchor" href="#语法分析器"></a> 语法分析器</h2>
<h3 id="语法分析器的基本问题"><a class="markdownIt-Anchor" href="#语法分析器的基本问题"></a> 语法分析器的基本问题</h3>
<p>我个人分为三个问题：</p>
<ul>
<li>如何正确、快速地识别输入符号串</li>
<li>如何构建的解析树</li>
<li>如何把解析树映射成语法树</li>
</ul>
<p>接下来的讨论，只讨论第一个问题。后面两个问题见下一节。</p>
<h3 id="市面上的常见parser"><a class="markdownIt-Anchor" href="#市面上的常见parser"></a> 市面上的常见Parser</h3>
<p>现在市面上有很多Parser，大概分为五类：</p>
<ul>
<li>手写的递归向下解析器</li>
<li>函数式编程语言里的Parser Combinator</li>
<li>Parser Generator</li>
<li>手写的算符优先级解析器</li>
<li>一些使用特定算法的其他解析器</li>
</ul>
<h3 id="递归向下解析器"><a class="markdownIt-Anchor" href="#递归向下解析器"></a> 递归向下解析器</h3>
<p>递归向下指的是一种编程方法。比如说你有这样的文法：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">A \rightarrow aBc 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">c</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">B \rightarrow dB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>那么，你写出这种函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VALUE <span class="title">handle_A</span><span class="params">(SYMBOL * stream, <span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == a)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SUCCESS</span>(<span class="built_in">handle_B</span>(stream, pos)))&#123;</span><br><span class="line">      <span class="keyword">if</span>(stream[pos] == c)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// error_handle</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE <span class="built_in">handle_B</span>(SYMBOL * stream, <span class="type">int</span> pos)&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == d)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">SUCCESS</span>(<span class="built_in">handle_B</span>(stream, pos)))&#123;</span><br><span class="line">      <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从外形上说，这就是把每一个非终结符写成一个函数，然后在这个函数里处理这个非终结符的内容，并返回成功或失败。</p>
<p>从本质上说，这是一个自顶向下解析器。它是一个下推自动机，具有一个栈，以如下方式运行：</p>
<ul>
<li>初始化：将初始符号压入栈中（调用handle_S）</li>
<li>从栈顶弹出一个符号
<ul>
<li>如果是终结符就与当前字符串的第一个符号进行比较，如果成功则继续，失败返回错误</li>
<li>如果是非终结符就将这个非终结符的右手侧压入栈中（调用handle_X）</li>
</ul>
</li>
</ul>
<p>这个时候，读者应该隐隐约约地感到到了一些问题。</p>
<p>第一个问题是，一个非终结符可以生成不同的符号串，比如说：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi><mi>c</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(0)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">A \rightarrow aBc \tag{0}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">c</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">0</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>A</mi><mo>→</mo><mi>c</mi><mi>D</mi><mi>f</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">A \rightarrow cDf \tag{1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>如果现在的栈顶符号是$$A$$，你如何判断压入哪个符号串呢？</p>
<p>这就有了递归向下Parser内部的两个实质Parser：</p>
<ul>
<li>回退解析器。如果遇到这种问题，我们使用搜索广度优先或深度优先搜索算法，将两种路径都尝试一下，如果失败就回退。（非确定型）</li>
<li>LL(k)解析器。我们保证文法是LL(k)的，这样一来就可以根据当前输入符号串的前$$k$$个符号判断采取哪条路径。（确定型）</li>
</ul>
<p>第二个问题是，如果我们遇到的是左递归文法：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⇒</mo><mi>A</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow Aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>这个规则会使得自动机不停地弹出A和压入A，是一个死循环。所以从本质上来说，执行最左推导的下推自动机极其实现，永远不可能处理原始的左递归文法。</p>
<p>而有时候我们又必须要求左递归，比如四则运算的减号。</p>
<p>有人可能会说，有一个算法可以把左递归强行化成右递归。确实是有，但是如果你把该算法作用于减号上，你会发现，强行化成右递归会导致语义不正确。这个问题是每一个使用递归向下的人不得不解决的。</p>
<h3 id="parser-combinator"><a class="markdownIt-Anchor" href="#parser-combinator"></a> Parser Combinator</h3>
<p>我们知道，所有的生成文法其实都可以写成连接的形式（当然，必须允许重复定义，或者允许选择符号）。而上面的递归向下解析器其实是在用代码定义这些东西：</p>
<ul>
<li>终结符–是否匹配的if判断语句</li>
<li>非终结符–是否匹配的if判断函数</li>
<li>连接–顺序执行</li>
<li>选择–判断进入哪条路径的if判断语句</li>
</ul>
<p>很多人会敏锐的认识到，这些东西都可以进行抽象。把代码的运行逻辑留下，作为一个高阶函数；把具体的代码封装成函数作为其参数。而这恰恰就是函数式编程的思想。</p>
<p>如此一来，我们就获得了一个新的工具–Parser Combinator.</p>
<p>我这里举<a target="_blank" rel="noopener" href="https://www.quanttec.com/fparsec/">FParsec</a>作为例子，看看它是如何构建解析器的：</p>
<p>FParsec把输入流进行封装。其中最重要的概念就是“position”，即当前要处理的符号串位置。<strong>这里需要特别注意，FParsec只支持将字符串作为输入，无法使用词法分析器，这是其美中不足之处。</strong></p>
<p>FParsec将解析器定义为一个函数，原型如下：</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Parser</span><span class="operator">&lt;</span><span class="symbol">&#x27;Result</span>, <span class="symbol">&#x27;UserState</span><span class="operator">&gt;</span> <span class="operator">=</span> CharStream<span class="operator">&lt;</span><span class="symbol">&#x27;UserState</span><span class="operator">&gt;</span> <span class="operator">-&gt;</span> Reply<span class="operator">&lt;</span><span class="symbol">&#x27;Result</span><span class="operator">&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的UserState是我们自己定义的State，一般设为unit（即空类型，没有内容）即可，暂时不去管他；这里的’Result是一个泛型类型，用户可以自己定义结果。</p>
<p>这个函数的意义是，一个输入为CharStream型，输出为Reply的函数。</p>
<p>FParsec提供了一些用来从字符构建非终结符的函数，比如说:</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">internal</span> charReturnE (c<span class="operator">:</span> <span class="type">char</span>) result error <span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">fun</span> stream <span class="operator">-&gt;</span></span><br><span class="line">      <span class="keyword">if</span> stream.Skip(c) <span class="keyword">then</span> Reply(result)</span><br><span class="line">      <span class="keyword">else</span> Reply(<span class="literal">Error</span>, error)</span><br></pre></td></tr></table></figure>
<p>我们使用</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a <span class="operator">=</span>  charReturnE <span class="string">&quot;a&quot;</span> <span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>
<p>即是定义了非终结符a，对应的字符也是&quot;a&quot;。</p>
<p>FParsec提供了一系列用于连接符号的函数。</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (<span class="operator">.&gt;&gt;</span>) (p<span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span>) (q<span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;b</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span>) <span class="operator">=</span></span><br><span class="line">  <span class="keyword">fun</span> stream <span class="operator">-&gt;</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mutable</span> reply1 <span class="operator">=</span> p stream</span><br><span class="line">      <span class="keyword">if</span> reply1.Status <span class="operator">=</span> <span class="literal">Ok</span> <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">let</span> stateTag1 <span class="operator">=</span> stream.StateTag</span><br><span class="line">          <span class="keyword">let</span> reply2 <span class="operator">=</span> q stream</span><br><span class="line">          <span class="keyword">let</span> error <span class="operator">=</span> <span class="keyword">if</span> isNull reply1.<span class="literal">Error</span> <span class="keyword">then</span> reply2.<span class="literal">Error</span></span><br><span class="line">                      <span class="keyword">elif</span> stateTag1 <span class="operator">&lt;&gt;</span> stream.StateTag <span class="keyword">then</span> reply2.<span class="literal">Error</span></span><br><span class="line">                      <span class="keyword">else</span> mergeErrors reply2.<span class="literal">Error</span> reply1.<span class="literal">Error</span></span><br><span class="line">          reply1.<span class="literal">Error</span>  <span class="operator">&lt;-</span> error</span><br><span class="line">          reply1.Status <span class="operator">&lt;-</span> reply2.Status</span><br><span class="line">      reply1</span><br></pre></td></tr></table></figure>
<p>这个符号是将两个非终结符连接起来，形成一个新的非终结符的函数。<br />
比如说：</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> A <span class="operator">=</span> charReturnE <span class="string">&quot;a&quot;</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">let</span> B <span class="operator">=</span> charReturnE <span class="string">&quot;a&quot;</span> <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">let</span> C <span class="operator">=</span> A <span class="operator">.&gt;&gt;</span> B</span><br></pre></td></tr></table></figure>
<p>实际上就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">B \rightarrow b 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>→</mo><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">C \rightarrow AB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>的实现。</p>
<p>FParsec本质上是一个回退解析器，但它的性能却相当不错。这是因为它对选择符号(&lt;|&gt;)的实现：</p>
  <figure class="highlight f#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (<span class="operator">&lt;|&gt;</span>) (p1<span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span>) (p2<span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span>) <span class="operator">:</span> Parser<span class="operator">&lt;</span><span class="symbol">&#x27;a</span>,<span class="symbol">&#x27;u</span><span class="operator">&gt;</span> <span class="operator">=</span></span><br><span class="line">  <span class="keyword">fun</span> stream <span class="operator">-&gt;</span></span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mutable</span> stateTag <span class="operator">=</span> stream.StateTag</span><br><span class="line">      <span class="keyword">let</span> <span class="keyword">mutable</span> reply <span class="operator">=</span> p1 stream</span><br><span class="line">      <span class="keyword">if</span> reply.Status <span class="operator">=</span> <span class="literal">Error</span> <span class="operator">&amp;&amp;</span> stateTag <span class="operator">=</span> stream.StateTag <span class="keyword">then</span></span><br><span class="line">          <span class="keyword">let</span> error <span class="operator">=</span> reply.<span class="literal">Error</span></span><br><span class="line">          reply <span class="operator">&lt;-</span> p2 stream</span><br><span class="line">          <span class="keyword">if</span> stateTag <span class="operator">=</span> stream.StateTag <span class="keyword">then</span></span><br><span class="line">              reply.<span class="literal">Error</span> <span class="operator">&lt;-</span> mergeErrors reply.<span class="literal">Error</span> error</span><br><span class="line">      reply</span><br></pre></td></tr></table></figure>
<p>我们看到，如果第一个Parser失败，<strong>当且仅当在stateTag没有改变时</strong>，才会进行用第二个Parser进行解析。</p>
<p>这个stateTag，实际上就是position，也就是是当前解析到的位置。如此设计，保证了这个Parser<strong>仅仅会回退一个字符</strong>，因为如果第一个字符是匹配的，position就发生了变化。如此设计，使得它在某种意义上具有了$$LL(1)$$的特性。</p>
<p>当然，我们也可以使用attempt强行使它回退。</p>
<p>针对下推自动机无法识别左递归的问题，FParsec引入了一个算符优先级解析器，帮助我们识别(1 + 1 - 2)一类的式子。</p>
<p>个人认为FParsec是一个不错的东西。但是F#和Haskell一样，本身语言设计有诸多麻烦之处，实际开发体验并没有特别舒服。</p>
<h3 id="parser-generator"><a class="markdownIt-Anchor" href="#parser-generator"></a> Parser Generator</h3>
<p>这个东西应该是最为正统的方式了。Parser Generator可以做到由文法直接生成代码，我们不太需要关系内部是如何实现的。这个东西的集大成者是yacc，我们没什么好说的。</p>
<h3 id="算符优先级解析器"><a class="markdownIt-Anchor" href="#算符优先级解析器"></a> 算符优先级解析器</h3>
<p>我们并不陌生，大名鼎鼎的调度场算法即是这类解析器的一种，这里也不耗费笔墨了。</p>
<h2 id="从解析树到语法树"><a class="markdownIt-Anchor" href="#从解析树到语法树"></a> 从解析树到语法树</h2>
<p>解析树，顾名思义，就是解析器生成的树。这里有两个问题：</p>
<ul>
<li>逻辑上的解析树是唯一的，也就是生成文法生成句子的那棵生成树。</li>
<li>一个可以正确识别出输出符号串的解析器，一定是正确地构建出解析树了的，但是这颗解析树是逻辑上的，而非实现上的。实现上的解析树是什么样的，需要一一讨论。</li>
</ul>
<p>语法树则不同，语法树和解析树的关系是若即若离的：</p>
<ul>
<li>语法树的节点并不是解析器自动生成的，而是人为设计的。</li>
<li>即使没有Parser，我们也可以直接根据想法（<strong>而不是根据生成文法</strong>），构建出语法树。</li>
<li>一般来说，我们的Parser会在解析的同时，将解析时映射为语法树。</li>
</ul>
<p>我们考察两个有代表性的解析器–递归向下解析器与Yacc生成的解析器–是如何构建出解析树，并将其映射为语法树的。</p>
<h3 id="递归向下解析器的情况"><a class="markdownIt-Anchor" href="#递归向下解析器的情况"></a> 递归向下解析器的情况</h3>
<p>以如下文法为例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S \rightarrow A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A \rightarrow M 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>M</mi><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \rightarrow M + A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>→</mo><mi>D</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M \rightarrow D * M 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">M \rightarrow D 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>→</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D \rightarrow int | (A) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></span></p>
<p>这文法定义了一个支持加乘两种运算的式子。</p>
<p>我们用C#实现一下；</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RecursiveDesentParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Parser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> Target &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> pointer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parser</span>(<span class="params"><span class="built_in">string</span> s</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Target = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">bool</span> <span class="title">Parse</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> success = (head = ParseA()) != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ParseEpsilon() &amp;&amp; success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node now = ParseM();</span><br><span class="line">            <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseM</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node now = ParseD();</span><br><span class="line">            <span class="keyword">if</span>(now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseM();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;*&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下代码略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在来解析这样的式子:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1 + 2 * 3 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></span></p>
<p>为了更好地展示解析的过程，我们需要把整个解析的所有调用都画出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ParseA</span><br><span class="line">  ParseM</span><br><span class="line">    ParseD : 1</span><br><span class="line">  ParseChar : +</span><br><span class="line">  ParseA</span><br><span class="line">    ParseM</span><br><span class="line">      ParseD : 2</span><br><span class="line">      ParseChar : *</span><br><span class="line">      ParseM</span><br><span class="line">        ParseD : 3</span><br></pre></td></tr></table></figure>
<p>我们发现：<strong>调用函数的过程，自然地形成了一颗解析树！</strong>，这也正是递归向下解析器的一大特性。</p>
<p>调用函数的过程本身就是解析树，将解析树映射为语法树的做法就呼之欲出了：将返回值作为语法树的节点，在每个函数内部实现解析树到语法树的节点的映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Node now = ParseM();</span><br><span class="line">    <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">            nodes.Add(now);</span><br><span class="line">            <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">            nodes.Add(tail);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个函数里，我们把自然形成的这个解析树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">  M</span><br><span class="line">  +</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>
<p>映射成了这样的语法树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">  M</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>
<h3 id="yacc的情况"><a class="markdownIt-Anchor" href="#yacc的情况"></a> Yacc的情况</h3>
<p>yacc是一个LALR(1)文法的Parser Generator. 它产生的分析器是一个自底向上的确定型分析器。</p>
<p>自底向上的意思是，它对应一个这样的自动机：</p>
<p>（在下面的示意中, .表示在.之前的位置已经被分析完了）</p>
<p>这个自动机的输入是一个字符串，它开始的状态是当然是:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">.a_{0}a_{1}a_{2}a_{3} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这个自动机还具有一个栈，在开始状态，栈中没有元素。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></span></p>
<p>这个自动机有两种操作：</p>
<ul>
<li>读入一个字符，把字符放到栈里。</li>
<li>把栈里的字符进行规约，化成别的符号。</li>
</ul>
<p>它不断地进行这两个操作，直至栈中得到开始符号为止。</p>
<p>以下面的语法和输入字符为例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow Aa | a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aaaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>首先，开始的状态是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">栈：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">.aaaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>移进一个a：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">栈：a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a.aaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>进行规约：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">栈：A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a.aaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>再移入一个a：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>A</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">栈：Aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aa.aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>下面的操作就无需多言了。</p>
<p>这里我们会发现，自底向上的解析器的解析树，实际上体现在“规约”中，<strong>每一次的规约，实际上是以解析树的叶子节点替换解析树的根节点</strong>。</p>
<p>但这样一来，真正的解析树其实没有被留下，也就无法把解析树映射为语法树了。</p>
<p>为了解决这个问题，yacc引入了一个“内容栈”和“符号栈”的概念。</p>
<ul>
<li>内容栈：栈里是类型为YYSTYPE的值，它是保存结果用的栈。</li>
<li>符号栈：我们刚才说得用来分析的栈。</li>
</ul>
<p>这两个栈到底是怎么一回事呢？我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> typedef struct node</span><br><span class="line"> &#123;</span><br><span class="line"> struct node *left;</span><br><span class="line"> struct node *right;</span><br><span class="line"> char *token;</span><br><span class="line"> &#125; node;</span><br><span class="line"> node *mknode(node *left, node *right, char *token);</span><br><span class="line"> void printtree(node *tree);</span><br><span class="line">#define YYSTYPE struct node *</span><br><span class="line">%&#125; </span><br><span class="line"></span><br><span class="line">exp : term &#123;$$ = $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ = mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ = mknode($1, $3, &quot;-&quot;);&#125; </span><br></pre></td></tr></table></figure>
<p>不难看出，node是语法树的节点类型，而那句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YYSTYPE struct node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是将内容栈的元素类型定义为node*指针类型。</p>
<p>下面的那句</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exp : term &#123;$$ = $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ = mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ = mknode($1, $3, &quot;-&quot;);&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果除去大括号，就是生成文法；而大括号里面的内容，则是对每条文法在<strong>内容栈</strong>上的操作，这个写法表示，在运用这条文法进行规约时，将内容栈上的对应元素拿出，并压入新构造的node*指针。</p>
<p>这样一来，我们又实现了从解析树映射到语法树的操作。</p>
<h2 id="需要注意的几个问题"><a class="markdownIt-Anchor" href="#需要注意的几个问题"></a> 需要注意的几个问题</h2>
<h3 id="不要给parser增加太多负担"><a class="markdownIt-Anchor" href="#不要给parser增加太多负担"></a> 不要给Parser增加太多负担</h3>
<p>有些人想要在解析阶段就识别出来这种语法错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">a</span>();</span><br></pre></td></tr></table></figure>
<p>如果真的想做，这需要CSG解析。而CSG解析并没有一个很好的算法，所以，应该放弃这种不切实际的想法，在后面的阶段再检查这种错误。</p>
<h3 id="最好不要实现parser"><a class="markdownIt-Anchor" href="#最好不要实现parser"></a> 最好不要实现Parser</h3>
<p>通过上面的描述，可以看到Parser是一个苦大仇深的行业。如果你实现一个复杂的语法，它的Parser会非常复杂，这会耗尽你对程序语言的热情。所以，让我们一起来实现Lisp吧！</p>

      
    </div>
    
    
    <div class="article-category">
      
        <b>Categories:</b>
        <a class="article-category-link" href="/categories/%E5%AD%A6%E6%9C%AF/">学术</a>
      
      
        <br/>
      
      
        <b>Tags:</b>
        <a class="article-tag-none-link" href="/tags/PL/" rel="tag">PL</a>, <a class="article-tag-none-link" href="/tags/Parser/" rel="tag">Parser</a>, <a class="article-tag-none-link" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/" rel="tag">编程语言实现</a>
      
    </div>
    
    
  </div>
</article>

  
<nav id="article-nav" class="article-nav">
  
    <a href="/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/" id="article-nav-newer" class="article-nav-link-wrap newer">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          如何正确地烹制春笋
        
      </div>
    </a>
  
  
    <a href="/2020/04/21/2020-04-21-CLanguage/" id="article-nav-older" class="article-nav-link-wrap older">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">
        
          谈谈C语言的两个问题
        
      </div>
    </a>
  
</nav>






    </div>
  </div>
  




<div id="settings-container">
  <div id="dark-mode">dark</div>
  <div id="sans-font">sans</div>
</div>
<script type="text/javascript">
let d=document,r=d.documentElement.style,f=r.setProperty.bind(r),l=localStorage,s=l.getItem('s')||(window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches),n=l.getItem('n'),m=d.getElementById("dark-mode"),b=()=>{f('--bg-color','#fafafa');f('--code-bg-color','#f4f4f4');f('--text-color','#212121');f('--secondary-color','#808080');f('--tertiary-color','#b0b0b0');f('--link-color','#b5c8cf');f('--link-hover-color','#618794');f('--link-bg-color','#dae4e7');f('--selection-color','#dae4e7');m.innerHTML="dark"},c=()=>{f('--bg-color','#212121');f('--code-bg-color','#292929');f('--text-color','#fff');f('--secondary-color','#c0c0c0');f('--tertiary-color','#6e6e6e');f('--link-color','#4d6b75');f('--link-hover-color','#96b1bb');f('--link-bg-color','#5d828e');f('--selection-color','#acc1c9');m.innerHTML="light"},o=d.getElementById("sans-font"),e=()=>{f('--body-stack','"Lora", "Georgia", "Times New Roman", serif');o.innerHTML="sans"},g=()=>{f('--body-stack','"Lato", "Lucida Grande", "Lucida Sans Unicode", "Lucida Sans", "Verdana", sans-serif');o.innerHTML="serif"};m.onclick=()=>{if(s==2){s=1;l.setItem('s',s);c()}else{s=2;l.setItem('s',s);b()}};o.onclick=()=>{if(n==2){n=1;l.setItem('n',n);g()}else{n=2;l.setItem('n',n);e()}};if(!s){s=2;l.setItem('s',2)};if(s==1){c()};if(!n){n=2;l.setItem('n',2)};if(n==1){g()};
</script>




</body>
</html>
