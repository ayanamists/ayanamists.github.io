<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#0078E7"><meta name="author" content="Ayanamists"><meta name="copyright" content="Ayanamists"><meta name="generator" content="Hexo 5.2.0"><meta name="theme" content="hexo-theme-yun"><title>让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树 | AyanamistsBlog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.21/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_ed8vp4atwoj.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link rel="shortcut icon" type="image/svg+xml" href="/yun.svg"><link rel="mask-icon" href="/yun.svg" color="#0078E7"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"example.com","root":"/","title":"云游君的小站","version":"1.2.0","mode":"auto","copycode":true,"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><meta name="description" content="词法分析器  为什么要有词法分析器 如何构建一个词法分析器   语法分析器  语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树  递归向下解析器的情况 Yacc的情况   需要注意的几个问题  不要给Parser增加太多负担 最好不要实现Parser     词法分析器 词">
<meta property="og:type" content="article">
<meta property="og:title" content="让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树">
<meta property="og:url" content="http://example.com/2020/04/25/2020-4-25-parser2/index.html">
<meta property="og:site_name" content="AyanamistsBlog">
<meta property="og:description" content="词法分析器  为什么要有词法分析器 如何构建一个词法分析器   语法分析器  语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树  递归向下解析器的情况 Yacc的情况   需要注意的几个问题  不要给Parser增加太多负担 最好不要实现Parser     词法分析器 词">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-04-25T00:00:00.000Z">
<meta property="article:modified_time" content="2020-12-21T13:50:16.949Z">
<meta property="article:author" content="Ayanamists">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.20.0/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Ayanamists"><img width="96" loading="lazy" src="/Yun.png" alt="Ayanamists"></a><div class="site-author-name"><a href="/about/">Ayanamists</a></div><a class="site-name" href="/about/site.html">AyanamistsBlog</a><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">43</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">9</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">2</span></a></div><a class="site-state-item hty-icon-button" target="_blank" rel="noopener" href="https://yun.yunyoujun.cn" title="文档"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-settings-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.</span> <span class="toc-text"> 词法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.1.</span> <span class="toc-text"> 为什么要有词法分析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text"> 如何构建一个词法分析器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text"> 语法分析器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text"> 语法分析器的基本问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%B8%B8%E8%A7%81parser"><span class="toc-number">2.2.</span> <span class="toc-text"> 市面上的常见Parser</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">2.3.</span> <span class="toc-text"> 递归向下解析器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parser-combinator"><span class="toc-number">2.4.</span> <span class="toc-text"> Parser Combinator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#parser-generator"><span class="toc-number">2.5.</span> <span class="toc-text"> Parser Generator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-number">2.6.</span> <span class="toc-text"> 算符优先级解析器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E8%A7%A3%E6%9E%90%E6%A0%91%E5%88%B0%E8%AF%AD%E6%B3%95%E6%A0%91"><span class="toc-number">3.</span> <span class="toc-text"> 从解析树到语法树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.1.</span> <span class="toc-text"> 递归向下解析器的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#yacc%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.2.</span> <span class="toc-text"> Yacc的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text"> 需要注意的几个问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E7%BB%99parser%E5%A2%9E%E5%8A%A0%E5%A4%AA%E5%A4%9A%E8%B4%9F%E6%8B%85"><span class="toc-number">4.1.</span> <span class="toc-text"> 不要给Parser增加太多负担</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E5%AE%9E%E7%8E%B0parser"><span class="toc-number">4.2.</span> <span class="toc-text"> 最好不要实现Parser</span></a></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://example.com/2020/04/25/2020-4-25-parser2/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Ayanamists"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="AyanamistsBlog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-04-25 00:00:00" itemprop="dateCreated datePublished" datetime="2020-04-25T00:00:00+00:00">2020-04-25</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2020-12-21 13:50:16" itemprop="dateModified" datetime="2020-12-21T13:50:16+00:00">2020-12-21</time></div><div class="post-classify"></div><div class="post-author"><span class="author-name">ayanamists</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#0078E7;"><ul>
<li><a href="#%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">词法分析器</a>
<ul>
<li><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%9c%89%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">为什么要有词法分析器</a></li>
<li><a href="#%e5%a6%82%e4%bd%95%e6%9e%84%e5%bb%ba%e4%b8%80%e4%b8%aa%e8%af%8d%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">如何构建一个词法分析器</a></li>
</ul>
</li>
<li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8">语法分析器</a>
<ul>
<li><a href="#%e8%af%ad%e6%b3%95%e5%88%86%e6%9e%90%e5%99%a8%e7%9a%84%e5%9f%ba%e6%9c%ac%e9%97%ae%e9%a2%98">语法分析器的基本问题</a></li>
<li><a href="#%e5%b8%82%e9%9d%a2%e4%b8%8a%e7%9a%84%e5%b8%b8%e8%a7%81parser">市面上的常见Parser</a></li>
<li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8">递归向下解析器</a></li>
<li><a href="#parser-combinator">Parser Combinator</a></li>
<li><a href="#parser-generator">Parser Generator</a></li>
<li><a href="#%e7%ae%97%e7%ac%a6%e4%bc%98%e5%85%88%e7%ba%a7%e8%a7%a3%e6%9e%90%e5%99%a8">算符优先级解析器</a></li>
</ul>
</li>
<li><a href="#%e4%bb%8e%e8%a7%a3%e6%9e%90%e6%a0%91%e5%88%b0%e8%af%ad%e6%b3%95%e6%a0%91">从解析树到语法树</a>
<ul>
<li><a href="#%e9%80%92%e5%bd%92%e5%90%91%e4%b8%8b%e8%a7%a3%e6%9e%90%e5%99%a8%e7%9a%84%e6%83%85%e5%86%b5">递归向下解析器的情况</a></li>
<li><a href="#yacc%e7%9a%84%e6%83%85%e5%86%b5">Yacc的情况</a></li>
</ul>
</li>
<li><a href="#%e9%9c%80%e8%a6%81%e6%b3%a8%e6%84%8f%e7%9a%84%e5%87%a0%e4%b8%aa%e9%97%ae%e9%a2%98">需要注意的几个问题</a>
<ul>
<li><a href="#%e4%b8%8d%e8%a6%81%e7%bb%99parser%e5%a2%9e%e5%8a%a0%e5%a4%aa%e5%a4%9a%e8%b4%9f%e6%8b%85">不要给Parser增加太多负担</a></li>
<li><a href="#%e6%9c%80%e5%a5%bd%e4%b8%8d%e8%a6%81%e5%ae%9e%e7%8e%b0parser">最好不要实现Parser</a></li>
</ul>
</li>
</ul>
<h2 id="词法分析器"><a class="markdownIt-Anchor" href="#词法分析器"></a> 词法分析器</h2>
<p>词法分析器，是将输入的字符串解析为符号串的工具；语法分析器，即parser，是将符号串解析为解析树（并将解析树映射为语法树）的工具。</p>
<h3 id="为什么要有词法分析器"><a class="markdownIt-Anchor" href="#为什么要有词法分析器"></a> 为什么要有词法分析器</h3>
<p>一般的编译器教科书，常常是先讲词法分析器，再讲语法分析器，顺带着讲讲生成文法。个人认为这是<strong>完全错误</strong>的。</p>
<p>我们必须要知道，我们这里提到的Parser解析的全部都是<strong>上下文无关文法</strong>（CFG），而词法分析器解析的是<strong>正则文法</strong>，我们还知道，<strong>所有的正则文法都是上下文无关文法</strong>，那么这就得出一个结论，因为Parser也可以解析正则文法，所以词法分析起是完全不需要的。</p>
<p>为了解释为什么需要词法分析器，我们必须考察一下市面上常见的各种Parser。</p>
<p>Parser从大的方面上分，有三个属性：</p>
<ul>
<li>定向/非定向</li>
<li>确定型/非确定型</li>
<li>自底向上/自顶向下</li>
</ul>
<p>其中非定向方法构建的Parser在程序语言中用的不多，这里不表。</p>
<p>如果你认真阅读过关于上一篇正则文法的文章，你会知道“确定型”和“非确定型”的区别在于“确定型”不需要搜索，时间复杂度是线性的；“非确定型”需要搜索，时间复杂度按你搜索的方法不同，从$$O(n<sup>2)$$到$$(O(e</sup>n))$$都有可能。如果从这个角度出发，那么这个解析器最好是确定型的。</p>
<p>但凡事有得必有失，确定型的解析器有一个天然劣势–<strong>不存在可以解析任何CFG的确定型解析器</strong>。这就要求我们必须对文法进行限制，以满足特定的解析器。</p>
<p>这种限制有时候是很不舒服的。而正则文法则不同，<strong>只要你的文法是正则文法，不需任何限制即可获得一个确定型解析器</strong>。</p>
<p>所以我们需要正则文法，来将字符串变为符号串，提前解决一些Parser解析起来很麻烦的东西。</p>
<h3 id="如何构建一个词法分析器"><a class="markdownIt-Anchor" href="#如何构建一个词法分析器"></a> 如何构建一个词法分析器</h3>
<p>如果你使用的语言有正则表达式支持，那就直接使用正则表达式构建即可；如果没有（常用的语言也就C没有了吧），建议使用flex之类的工具。</p>
<p>这里我们需要注意几个问题：</p>
<ul>
<li>正则表达式最好写在一起，否则和搜索没有区别。</li>
<li>如果你的正则表达式不支持捕获，那么是无法实现的。</li>
<li>注意错误处理，生成好看的错误。</li>
</ul>
<h2 id="语法分析器"><a class="markdownIt-Anchor" href="#语法分析器"></a> 语法分析器</h2>
<h3 id="语法分析器的基本问题"><a class="markdownIt-Anchor" href="#语法分析器的基本问题"></a> 语法分析器的基本问题</h3>
<p>我个人分为三个问题：</p>
<ul>
<li>如何正确、快速地识别输入符号串</li>
<li>如何构建的解析树</li>
<li>如何把解析树映射成语法树</li>
</ul>
<p>接下来的讨论，只讨论第一个问题。后面两个问题见下一节。</p>
<h3 id="市面上的常见parser"><a class="markdownIt-Anchor" href="#市面上的常见parser"></a> 市面上的常见Parser</h3>
<p>现在市面上有很多Parser，大概分为五类：</p>
<ul>
<li>手写的递归向下解析器</li>
<li>函数式编程语言里的Parser Combinator</li>
<li>Parser Generator</li>
<li>手写的算符优先级解析器</li>
<li>一些使用特定算法的其他解析器</li>
</ul>
<h3 id="递归向下解析器"><a class="markdownIt-Anchor" href="#递归向下解析器"></a> 递归向下解析器</h3>
<p>递归向下指的是一种编程方法。比如说你有这样的文法：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi><mi>c</mi></mrow><annotation encoding="application/x-tex">A \rightarrow aBc 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">c</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>d</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">B \rightarrow dB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>那么，你写出这种函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">VALUE handle_A(SYMBOL * stream, int pos)&#123;
  if(stream[pos] &#x3D;&#x3D; a)&#123;
    pos++;
    if(SUCCESS(handle_B(stream, pos)))&#123;
      if(stream[pos] &#x3D;&#x3D; c)&#123;
        pos++;
        &#x2F;&#x2F; 变成语法树返回回去
      &#125;
      else&#123;
        &#x2F;&#x2F; error_handle
      &#125;
    &#125;
    else&#123;
      &#x2F;&#x2F; error_handle
    &#125;
  &#125;
  else&#123;
    &#x2F;&#x2F; error_handle
  &#125;
&#125;

VALUE handle_B(SYMBOL * stream, int pos)&#123;
  if(stream[pos] &#x3D;&#x3D; d)&#123;
    pos++;
    if(SUCCESS(handle_B(stream, pos)))&#123;
      &#x2F;&#x2F; 变成语法树返回回去
    &#125;
    else&#123;
      &#x2F;&#x2F; error_handle
    &#125;
  &#125;
  else&#123;
    &#x2F;&#x2F; error_handle
  &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从外形上说，这就是把每一个非终结符写成一个函数，然后在这个函数里处理这个非终结符的内容，并返回成功或失败。</p>
<p>从本质上说，这是一个自顶向下解析器。它是一个下推自动机，具有一个栈，以如下方式运行：</p>
<ul>
<li>初始化：将初始符号压入栈中（调用handle_S）</li>
<li>从栈顶弹出一个符号
<ul>
<li>如果是终结符就与当前字符串的第一个符号进行比较，如果成功则继续，失败返回错误</li>
<li>如果是非终结符就将这个非终结符的右手侧压入栈中（调用handle_X）</li>
</ul>
</li>
</ul>
<p>这个时候，读者应该隐隐约约地感到到了一些问题。</p>
<p>第一个问题是，一个非终结符可以生成不同的符号串，比如说：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>A</mi><mo>→</mo><mi>a</mi><mi>B</mi><mi>c</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(0)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">A \rightarrow aBc \tag{0}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord mathdefault">c</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">0</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>A</mi><mo>→</mo><mi>c</mi><mi>D</mi><mi>f</mi></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(1)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">A \rightarrow cDf \tag{1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span></span><span class="tag"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">1</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>如果现在的栈顶符号是$$A$$，你如何判断压入哪个符号串呢？</p>
<p>这就有了递归向下Parser内部的两个实质Parser：</p>
<ul>
<li>回退解析器。如果遇到这种问题，我们使用搜索广度优先或深度优先搜索算法，将两种路径都尝试一下，如果失败就回退。（非确定型）</li>
<li>LL(k)解析器。我们保证文法是LL(k)的，这样一来就可以根据当前输入符号串的前$$k$$个符号判断采取哪条路径。（确定型）</li>
</ul>
<p>第二个问题是，如果我们遇到的是左递归文法：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>⇒</mo><mi>A</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \Rightarrow Aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>这个规则会使得自动机不停地弹出A和压入A，是一个死循环。所以从本质上来说，执行最左推导的下推自动机极其实现，永远不可能处理原始的左递归文法。</p>
<p>而有时候我们又必须要求左递归，比如四则运算的减号。</p>
<p>有人可能会说，有一个算法可以把左递归强行化成右递归。确实是有，但是如果你把该算法作用于减号上，你会发现，强行化成右递归会导致语义不正确。这个问题是每一个使用递归向下的人不得不解决的。</p>
<h3 id="parser-combinator"><a class="markdownIt-Anchor" href="#parser-combinator"></a> Parser Combinator</h3>
<p>我们知道，所有的生成文法其实都可以写成连接的形式（当然，必须允许重复定义，或者允许选择符号）。而上面的递归向下解析器其实是在用代码定义这些东西：</p>
<ul>
<li>终结符–是否匹配的if判断语句</li>
<li>非终结符–是否匹配的if判断函数</li>
<li>连接–顺序执行</li>
<li>选择–判断进入哪条路径的if判断语句</li>
</ul>
<p>很多人会敏锐的认识到，这些东西都可以进行抽象。把代码的运行逻辑留下，作为一个高阶函数；把具体的代码封装成函数作为其参数。而这恰恰就是函数式编程的思想。</p>
<p>如此一来，我们就获得了一个新的工具–Parser Combinator.</p>
<p>我这里举<a target="_blank" rel="noopener" href="https://www.quanttec.com/fparsec/">FParsec</a>作为例子，看看它是如何构建解析器的：</p>
<p>FParsec把输入流进行封装。其中最重要的概念就是“position”，即当前要处理的符号串位置。<strong>这里需要特别注意，FParsec只支持将字符串作为输入，无法使用词法分析器，这是其美中不足之处。</strong></p>
<p>FParsec将解析器定义为一个函数，原型如下：</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">type Parser&lt;&#39;Result, &#39;UserState&gt; &#x3D; CharStream&lt;&#39;UserState&gt; -&gt; Reply&lt;&#39;Result&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这里的UserState是我们自己定义的State，一般设为unit（即空类型，没有内容）即可，暂时不去管他；这里的’Result是一个泛型类型，用户可以自己定义结果。</p>
<p>这个函数的意义是，一个输入为CharStream型，输出为Reply的函数。</p>
<p>FParsec提供了一些用来从字符构建非终结符的函数，比如说:</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">let internal charReturnE (c: char) result error : Parser&lt;&#39;a,&#39;u&gt; &#x3D;
  fun stream -&gt;
      if stream.Skip(c) then Reply(result)
      else Reply(Error, error)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们使用</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">let a &#x3D;  charReturnE &quot;a&quot; &quot;a&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>即是定义了非终结符a，对应的字符也是&quot;a&quot;。</p>
<p>FParsec提供了一系列用于连接符号的函数。</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">let (.&gt;&gt;) (p: Parser&lt;&#39;a,&#39;u&gt;) (q: Parser&lt;&#39;b,&#39;u&gt;) &#x3D;
  fun stream -&gt;
      let mutable reply1 &#x3D; p stream
      if reply1.Status &#x3D; Ok then
          let stateTag1 &#x3D; stream.StateTag
          let reply2 &#x3D; q stream
          let error &#x3D; if isNull reply1.Error then reply2.Error
                      elif stateTag1 &lt;&gt; stream.StateTag then reply2.Error
                      else mergeErrors reply2.Error reply1.Error
          reply1.Error  &lt;- error
          reply1.Status &lt;- reply2.Status
      reply1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个符号是将两个非终结符连接起来，形成一个新的非终结符的函数。<br />
比如说：</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">let A &#x3D; charReturnE &quot;a&quot; &quot;a&quot;
let B &#x3D; charReturnE &quot;a&quot; &quot;a&quot;
let C &#x3D; A .&gt;&gt; B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>实际上就是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi><mo>→</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">B \rightarrow b 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mo>→</mo><mi>A</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">C \rightarrow AB 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<p>的实现。</p>
<p>FParsec本质上是一个回退解析器，但它的性能却相当不错。这是因为它对选择符号(&lt;|&gt;)的实现：</p>
  <pre class="line-numbers language-f#" data-language="f#"><code class="language-f#">let (&lt;|&gt;) (p1: Parser&lt;&#39;a,&#39;u&gt;) (p2: Parser&lt;&#39;a,&#39;u&gt;) : Parser&lt;&#39;a,&#39;u&gt; &#x3D;
  fun stream -&gt;
      let mutable stateTag &#x3D; stream.StateTag
      let mutable reply &#x3D; p1 stream
      if reply.Status &#x3D; Error &amp;&amp; stateTag &#x3D; stream.StateTag then
          let error &#x3D; reply.Error
          reply &lt;- p2 stream
          if stateTag &#x3D; stream.StateTag then
              reply.Error &lt;- mergeErrors reply.Error error
      reply<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们看到，如果第一个Parser失败，<strong>当且仅当在stateTag没有改变时</strong>，才会进行用第二个Parser进行解析。</p>
<p>这个stateTag，实际上就是position，也就是是当前解析到的位置。如此设计，保证了这个Parser<strong>仅仅会回退一个字符</strong>，因为如果第一个字符是匹配的，position就发生了变化。如此设计，使得它在某种意义上具有了$$LL(1)$$的特性。</p>
<p>当然，我们也可以使用attempt强行使它回退。</p>
<p>针对下推自动机无法识别左递归的问题，FParsec引入了一个算符优先级解析器，帮助我们识别(1 + 1 - 2)一类的式子。</p>
<p>个人认为FParsec是一个不错的东西。但是F#和Haskell一样，本身语言设计有诸多麻烦之处，实际开发体验并没有特别舒服。</p>
<h3 id="parser-generator"><a class="markdownIt-Anchor" href="#parser-generator"></a> Parser Generator</h3>
<p>这个东西应该是最为正统的方式了。Parser Generator可以做到由文法直接生成代码，我们不太需要关系内部是如何实现的。这个东西的集大成者是yacc，我们没什么好说的。</p>
<h3 id="算符优先级解析器"><a class="markdownIt-Anchor" href="#算符优先级解析器"></a> 算符优先级解析器</h3>
<p>我们并不陌生，大名鼎鼎的调度场算法即是这类解析器的一种，这里也不耗费笔墨了。</p>
<h2 id="从解析树到语法树"><a class="markdownIt-Anchor" href="#从解析树到语法树"></a> 从解析树到语法树</h2>
<p>解析树，顾名思义，就是解析器生成的树。这里有两个问题：</p>
<ul>
<li>逻辑上的解析树是唯一的，也就是生成文法生成句子的那棵生成树。</li>
<li>一个可以正确识别出输出符号串的解析器，一定是正确地构建出解析树了的，但是这颗解析树是逻辑上的，而非实现上的。实现上的解析树是什么样的，需要一一讨论。</li>
</ul>
<p>语法树则不同，语法树和解析树的关系是若即若离的：</p>
<ul>
<li>语法树的节点并不是解析器自动生成的，而是人为设计的。</li>
<li>即使没有Parser，我们也可以直接根据想法（<strong>而不是根据生成文法</strong>），构建出语法树。</li>
<li>一般来说，我们的Parser会在解析的同时，将解析时映射为语法树。</li>
</ul>
<p>我们考察两个有代表性的解析器–递归向下解析器与Yacc生成的解析器–是如何构建出解析树，并将其映射为语法树的。</p>
<h3 id="递归向下解析器的情况"><a class="markdownIt-Anchor" href="#递归向下解析器的情况"></a> 递归向下解析器的情况</h3>
<p>以如下文法为例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>→</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S \rightarrow A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">A \rightarrow M 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>M</mi><mo>+</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">A \rightarrow M + A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>→</mo><mi>D</mi><mo>∗</mo><mi>M</mi></mrow><annotation encoding="application/x-tex">M \rightarrow D * M 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi><mo>→</mo><mi>D</mi></mrow><annotation encoding="application/x-tex">M \rightarrow D 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>D</mi><mo>→</mo><mi>i</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">∣</mi><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">D \rightarrow int | (A) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">t</span><span class="mord">∣</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mclose">)</span></span></span></span></span></p>
<p>这文法定义了一个支持加乘两种运算的式子。</p>
<p>我们用C#实现一下；</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">
namespace RecursiveDesentParser
&#123;
    class Parser
    &#123;
        public string Target &#123; get; set; &#125;
        private int pointer &#x3D; 0;
        private Node head &#x3D; new Node(&quot;S&quot;);
        public Parser(string s)
        &#123;
            Target &#x3D; s;
        &#125;
        public bool Parse()
        &#123;
            var success &#x3D; (head &#x3D; ParseA()) !&#x3D; null;
            return ParseEpsilon() &amp;&amp; success;
        &#125;
        private Node ParseA()
        &#123;
            Node now &#x3D; ParseM();
            if (now !&#x3D; null)
            &#123;
                if (ParseChar(&#39;+&#39;))
                &#123;
                    List&lt;Node&gt; nodes &#x3D; new List&lt;Node&gt;();
                    nodes.Add(now);
                    var tail &#x3D; ParseA();
                    nodes.Add(tail);
                    return new Node(&quot;+&quot;, nodes);
                &#125;
                else &#123; return now; &#125;
            &#125;
            else &#123; return null; &#125;
        &#125;
        private Node ParseM()
        &#123;
            Node now &#x3D; ParseD();
            if(now !&#x3D; null)
            &#123;
                if (ParseChar(&#39;*&#39;))
                &#123;
                    List&lt;Node&gt; nodes &#x3D; new List&lt;Node&gt;();
                    nodes.Add(now);
                    var tail &#x3D; ParseM();
                    nodes.Add(tail);
                    return new Node(&quot;*&quot;, nodes);
                &#125;
                else &#123; return now; &#125;
            &#125;
            else &#123; return null; &#125;
        &#125;
        &#x2F;&#x2F; 以下代码略
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在来解析这样的式子:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>∗</mo><mn>3</mn></mrow><annotation encoding="application/x-tex">1 + 2 * 3 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span></span></span></span></span></p>
<p>为了更好地展示解析的过程，我们需要把整个解析的所有调用都画出来：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">ParseA
  ParseM
    ParseD : 1
  ParseChar : +
  ParseA
    ParseM
      ParseD : 2
      ParseChar : *
      ParseM
        ParseD : 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们发现：<strong>调用函数的过程，自然地形成了一颗解析树！</strong>，这也正是递归向下解析器的一大特性。</p>
<p>调用函数的过程本身就是解析树，将解析树映射为语法树的做法就呼之欲出了：将返回值作为语法树的节点，在每个函数内部实现解析树到语法树的节点的映射：</p>
<pre class="line-numbers language-c#" data-language="c#"><code class="language-c#">private Node ParseA()
&#123;
    Node now &#x3D; ParseM();
    if (now !&#x3D; null)
    &#123;
        if (ParseChar(&#39;+&#39;))
        &#123;
            List&lt;Node&gt; nodes &#x3D; new List&lt;Node&gt;();
            nodes.Add(now);
            var tail &#x3D; ParseA();
            nodes.Add(tail);
            return new Node(&quot;+&quot;, nodes);
        &#125;
        else &#123; return now; &#125;
    &#125;
    else &#123; return null; &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这个函数里，我们把自然形成的这个解析树：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">A
  M
  +
  A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>映射成了这样的语法树：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">+
  M
  A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="yacc的情况"><a class="markdownIt-Anchor" href="#yacc的情况"></a> Yacc的情况</h3>
<p>yacc是一个LALR(1)文法的Parser Generator. 它产生的分析器是一个自底向上的确定型分析器。</p>
<p>自底向上的意思是，它对应一个这样的自动机：</p>
<p>（在下面的示意中, .表示在.之前的位置已经被分析完了）</p>
<p>这个自动机的输入是一个字符串，它开始的状态是当然是:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><msub><mi>a</mi><mn>0</mn></msub><msub><mi>a</mi><mn>1</mn></msub><msub><mi>a</mi><mn>2</mn></msub><msub><mi>a</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">.a_{0}a_{1}a_{2}a_{3} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这个自动机还具有一个栈，在开始状态，栈中没有元素。</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></span></p>
<p>这个自动机有两种操作：</p>
<ul>
<li>读入一个字符，把字符放到栈里。</li>
<li>把栈里的字符进行规约，化成别的符号。</li>
</ul>
<p>它不断地进行这两个操作，直至栈中得到开始符号为止。</p>
<p>以下面的语法和输入字符为例：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>⇒</mo><mi>A</mi></mrow><annotation encoding="application/x-tex">S \Rightarrow A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mo>→</mo><mi>A</mi><mi>a</mi><mi mathvariant="normal">∣</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">A \rightarrow Aa | a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span><span class="mord">∣</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aaaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>首先，开始的状态是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi></mrow><annotation encoding="application/x-tex">栈：
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">.aaaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>移进一个a：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">栈：a 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a.aaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>进行规约：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>A</mi></mrow><annotation encoding="application/x-tex">栈：A 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">A</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">a.aaa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>再移入一个a：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">栈</mi><mi mathvariant="normal">：</mi><mi>A</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">栈：Aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord cjk_fallback">栈</span><span class="mord cjk_fallback">：</span><span class="mord mathdefault">A</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>a</mi><mi mathvariant="normal">.</mi><mi>a</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">aa.aa 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span><span class="mord">.</span><span class="mord mathdefault">a</span><span class="mord mathdefault">a</span></span></span></span></span></p>
<p>下面的操作就无需多言了。</p>
<p>这里我们会发现，自底向上的解析器的解析树，实际上体现在“规约”中，<strong>每一次的规约，实际上是以解析树的叶子节点替换解析树的根节点</strong>。</p>
<p>但这样一来，真正的解析树其实没有被留下，也就无法把解析树映射为语法树了。</p>
<p>为了解决这个问题，yacc引入了一个“内容栈”和“符号栈”的概念。</p>
<ul>
<li>内容栈：栈里是类型为YYSTYPE的值，它是保存结果用的栈。</li>
<li>符号栈：我们刚才说得用来分析的栈。</li>
</ul>
<p>这两个栈到底是怎么一回事呢？我们来看一个例子：</p>
<pre class="line-numbers language-yacc" data-language="yacc"><code class="language-yacc">
%&#123;
#include &lt;stdio.h&gt;
 typedef struct node
 &#123;
 struct node *left;
 struct node *right;
 char *token;
 &#125; node;
 node *mknode(node *left, node *right, char *token);
 void printtree(node *tree);
#define YYSTYPE struct node *
%&#125; 

exp : term &#123;$$ &#x3D; $1;&#125;
 | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;
 | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难看出，node是语法树的节点类型，而那句</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token expression">YYSTYPE <span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token operator">*</span></span></span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>就是将内容栈的元素类型定义为node*指针类型。</p>
<p>下面的那句</p>
<pre class="line-numbers language-yacc" data-language="yacc"><code class="language-yacc">
exp : term &#123;$$ &#x3D; $1;&#125;
 | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;
 | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; 
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果除去大括号，就是生成文法；而大括号里面的内容，则是对每条文法在<strong>内容栈</strong>上的操作，这个写法表示，在运用这条文法进行规约时，将内容栈上的对应元素拿出，并压入新构造的node*指针。</p>
<p>这样一来，我们又实现了从解析树映射到语法树的操作。</p>
<h2 id="需要注意的几个问题"><a class="markdownIt-Anchor" href="#需要注意的几个问题"></a> 需要注意的几个问题</h2>
<h3 id="不要给parser增加太多负担"><a class="markdownIt-Anchor" href="#不要给parser增加太多负担"></a> 不要给Parser增加太多负担</h3>
<p>有些人想要在解析阶段就识别出来这种语法错误：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a &#x3D; 0;
a();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果真的想做，这需要CSG解析。而CSG解析并没有一个很好的算法，所以，应该放弃这种不切实际的想法，在后面的阶段再检查这种错误。</p>
<h3 id="最好不要实现parser"><a class="markdownIt-Anchor" href="#最好不要实现parser"></a> 最好不要实现Parser</h3>
<p>通过上面的描述，可以看到Parser是一个苦大仇深的行业。如果你实现一个复杂的语法，它的Parser会非常复杂，这会耗尽你对程序语言的热情。所以，让我们一起来实现Lisp吧！</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>ayanamists</li><li class="post-copyright-link"><strong>Post link: </strong><a href="http://example.com/2020/04/25/2020-4-25-parser2/" title="让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树">http://example.com/2020/04/25/2020-4-25-parser2/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless stating additionally.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/" rel="prev" title="如何正确地烹制春笋"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">如何正确地烹制春笋</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/04/21/2020-04-21-CLanguage/" rel="next" title="谈谈C语言的两个问题"><span class="post-nav-text">谈谈C语言的两个问题</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div id="comment"><div class="comment-tooltip text-center"><span>点击按钮跳转 GitHub Issues 评论。</span><br><span>若没有本文 Issue，您可以使用 Comment 模版新建。</span><br><a class="hty-button hty-button--raised" id="github-issues" target="_blank" rel="noopener" href="https://github.com/YunYouJun/yunyoujun.github.io/issues?q=is:issue+让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树">GitHub Issues</a></div></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2020 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Ayanamists</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.2.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.2.0</span></div></footer><a class="hty-icon-button" id="goUp" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#0078E7" stroke-width="2" stroke-linecap="round"></circle></svg></a></div><script defer src="/js/utils.js"></script><script defer src="/js/hexo-theme-yun.js"></script></body></html>