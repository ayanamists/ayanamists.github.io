<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="词法分析器 为什么要有词法分析器 如何构建一个词法分析器   语法分析器 语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树 递归向下解析器的情况 Yacc的情况   需要注意的几个问题 不要给Parser增加太多负担 最好不要实现Parser    词法分析器词法分析器，是">
<meta property="og:type" content="article">
<meta property="og:title" content="让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树">
<meta property="og:url" content="http://example.com/2020/04/25/2020-4-25-parser2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="词法分析器 为什么要有词法分析器 如何构建一个词法分析器   语法分析器 语法分析器的基本问题 市面上的常见Parser 递归向下解析器 Parser Combinator Parser Generator 算符优先级解析器   从解析树到语法树 递归向下解析器的情况 Yacc的情况   需要注意的几个问题 不要给Parser增加太多负担 最好不要实现Parser    词法分析器词法分析器，是">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-04-25T00:00:00.000Z">
<meta property="article:modified_time" content="2020-10-11T04:43:47.188Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2020-4-25-parser2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/2020-4-25-parser2/" class="article-date">
  <time datetime="2020-04-25T00:00:00.000Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">词法分析器</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">为什么要有词法分析器</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">如何构建一个词法分析器</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">语法分析器</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">语法分析器的基本问题</a></li>
<li><a href="#%E5%B8%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%B8%B8%E8%A7%81parser">市面上的常见Parser</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8">递归向下解析器</a></li>
<li><a href="#parser-combinator">Parser Combinator</a></li>
<li><a href="#parser-generator">Parser Generator</a></li>
<li><a href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%A3%E6%9E%90%E5%99%A8">算符优先级解析器</a></li>
</ul>
</li>
<li><a href="#%E4%BB%8E%E8%A7%A3%E6%9E%90%E6%A0%91%E5%88%B0%E8%AF%AD%E6%B3%95%E6%A0%91">从解析树到语法树</a><ul>
<li><a href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5">递归向下解析器的情况</a></li>
<li><a href="#yacc%E7%9A%84%E6%83%85%E5%86%B5">Yacc的情况</a></li>
</ul>
</li>
<li><a href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98">需要注意的几个问题</a><ul>
<li><a href="#%E4%B8%8D%E8%A6%81%E7%BB%99parser%E5%A2%9E%E5%8A%A0%E5%A4%AA%E5%A4%9A%E8%B4%9F%E6%8B%85">不要给Parser增加太多负担</a></li>
<li><a href="#%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E5%AE%9E%E7%8E%B0parser">最好不要实现Parser</a></li>
</ul>
</li>
</ul>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>词法分析器，是将输入的字符串解析为符号串的工具；语法分析器，即parser，是将符号串解析为解析树（并将解析树映射为语法树）的工具。</p>
<h3 id="为什么要有词法分析器"><a href="#为什么要有词法分析器" class="headerlink" title="为什么要有词法分析器"></a>为什么要有词法分析器</h3><p>一般的编译器教科书，常常是先讲词法分析器，再讲语法分析器，顺带着讲讲生成文法。个人认为这是<strong>完全错误</strong>的。</p>
<p>我们必须要知道，我们这里提到的Parser解析的全部都是<strong>上下文无关文法</strong>（CFG），而词法分析器解析的是<strong>正则文法</strong>，我们还知道，<strong>所有的正则文法都是上下文无关文法</strong>，那么这就得出一个结论，因为Parser也可以解析正则文法，所以词法分析起是完全不需要的。</p>
<p>为了解释为什么需要词法分析器，我们必须考察一下市面上常见的各种Parser。</p>
<p>Parser从大的方面上分，有三个属性：</p>
<ul>
<li>定向/非定向</li>
<li>确定型/非确定型</li>
<li>自底向上/自顶向下</li>
</ul>
<p>其中非定向方法构建的Parser在程序语言中用的不多，这里不表。</p>
<p>如果你认真阅读过关于上一篇正则文法的文章，你会知道“确定型”和“非确定型”的区别在于“确定型”不需要搜索，时间复杂度是线性的；“非确定型”需要搜索，时间复杂度按你搜索的方法不同，从$$O(n^2)$$到$$(O(e^n))$$都有可能。如果从这个角度出发，那么这个解析器最好是确定型的。</p>
<p>但凡事有得必有失，确定型的解析器有一个天然劣势–<strong>不存在可以解析任何CFG的确定型解析器</strong>。这就要求我们必须对文法进行限制，以满足特定的解析器。</p>
<p>这种限制有时候是很不舒服的。而正则文法则不同，<strong>只要你的文法是正则文法，不需任何限制即可获得一个确定型解析器</strong>。</p>
<p>所以我们需要正则文法，来将字符串变为符号串，提前解决一些Parser解析起来很麻烦的东西。</p>
<h3 id="如何构建一个词法分析器"><a href="#如何构建一个词法分析器" class="headerlink" title="如何构建一个词法分析器"></a>如何构建一个词法分析器</h3><p>如果你使用的语言有正则表达式支持，那就直接使用正则表达式构建即可；如果没有（常用的语言也就C没有了吧），建议使用flex之类的工具。</p>
<p>这里我们需要注意几个问题：</p>
<ul>
<li>正则表达式最好写在一起，否则和搜索没有区别。</li>
<li>如果你的正则表达式不支持捕获，那么是无法实现的。</li>
<li>注意错误处理，生成好看的错误。</li>
</ul>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><h3 id="语法分析器的基本问题"><a href="#语法分析器的基本问题" class="headerlink" title="语法分析器的基本问题"></a>语法分析器的基本问题</h3><p>我个人分为三个问题：</p>
<ul>
<li>如何正确、快速地识别输入符号串</li>
<li>如何构建的解析树</li>
<li>如何把解析树映射成语法树</li>
</ul>
<p>接下来的讨论，只讨论第一个问题。后面两个问题见下一节。</p>
<h3 id="市面上的常见Parser"><a href="#市面上的常见Parser" class="headerlink" title="市面上的常见Parser"></a>市面上的常见Parser</h3><p>现在市面上有很多Parser，大概分为五类：</p>
<ul>
<li>手写的递归向下解析器</li>
<li>函数式编程语言里的Parser Combinator</li>
<li>Parser Generator</li>
<li>手写的算符优先级解析器</li>
<li>一些使用特定算法的其他解析器</li>
</ul>
<h3 id="递归向下解析器"><a href="#递归向下解析器" class="headerlink" title="递归向下解析器"></a>递归向下解析器</h3><p>递归向下指的是一种编程方法。比如说你有这样的文法：</p>
<p>$$ A \rightarrow aBc $$</p>
<p>$$ B \rightarrow dB $$</p>
<p>那么，你写出这种函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VALUE <span class="title">handle_A</span><span class="params">(SYMBOL * stream, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == a)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS(handle_B(stream, pos)))&#123;</span><br><span class="line">      <span class="keyword">if</span>(stream[pos] == c)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// error_handle</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE handle_B(SYMBOL * stream, <span class="keyword">int</span> pos)&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == d)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS(handle_B(stream, pos)))&#123;</span><br><span class="line">      <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从外形上说，这就是把每一个非终结符写成一个函数，然后在这个函数里处理这个非终结符的内容，并返回成功或失败。</p>
<p>从本质上说，这是一个自顶向下解析器。它是一个下推自动机，具有一个栈，以如下方式运行：</p>
<ul>
<li>初始化：将初始符号压入栈中（调用handle_S）</li>
<li>从栈顶弹出一个符号<ul>
<li>如果是终结符就与当前字符串的第一个符号进行比较，如果成功则继续，失败返回错误</li>
<li>如果是非终结符就将这个非终结符的右手侧压入栈中（调用handle_X）</li>
</ul>
</li>
</ul>
<p>这个时候，读者应该隐隐约约地感到到了一些问题。</p>
<p>第一个问题是，一个非终结符可以生成不同的符号串，比如说：</p>
<p>$$ A \rightarrow aBc \tag{0}$$</p>
<p>$$ A \rightarrow cDf \tag{1}$$</p>
<p>如果现在的栈顶符号是$$A$$，你如何判断压入哪个符号串呢？</p>
<p>这就有了递归向下Parser内部的两个实质Parser：</p>
<ul>
<li>回退解析器。如果遇到这种问题，我们使用搜索广度优先或深度优先搜索算法，将两种路径都尝试一下，如果失败就回退。（非确定型）</li>
<li>LL(k)解析器。我们保证文法是LL(k)的，这样一来就可以根据当前输入符号串的前$$k$$个符号判断采取哪条路径。（确定型）</li>
</ul>
<p>第二个问题是，如果我们遇到的是左递归文法：</p>
<p>$$ A \Rightarrow Aa $$</p>
<p>这个规则会使得自动机不停地弹出A和压入A，是一个死循环。所以从本质上来说，执行最左推导的下推自动机极其实现，永远不可能处理原始的左递归文法。</p>
<p>而有时候我们又必须要求左递归，比如四则运算的减号。</p>
<p>有人可能会说，有一个算法可以把左递归强行化成右递归。确实是有，但是如果你把该算法作用于减号上，你会发现，强行化成右递归会导致语义不正确。这个问题是每一个使用递归向下的人不得不解决的。</p>
<h3 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h3><p>我们知道，所有的生成文法其实都可以写成连接的形式（当然，必须允许重复定义，或者允许选择符号）。而上面的递归向下解析器其实是在用代码定义这些东西：</p>
<ul>
<li>终结符–是否匹配的if判断语句</li>
<li>非终结符–是否匹配的if判断函数</li>
<li>连接–顺序执行</li>
<li>选择–判断进入哪条路径的if判断语句</li>
</ul>
<p>很多人会敏锐的认识到，这些东西都可以进行抽象。把代码的运行逻辑留下，作为一个高阶函数；把具体的代码封装成函数作为其参数。而这恰恰就是函数式编程的思想。</p>
<p>如此一来，我们就获得了一个新的工具–Parser Combinator.</p>
<p>我这里举<a target="_blank" rel="noopener" href="https://www.quanttec.com/fparsec/">FParsec</a>作为例子，看看它是如何构建解析器的：</p>
<p>FParsec把输入流进行封装。其中最重要的概念就是“position”，即当前要处理的符号串位置。<strong>这里需要特别注意，FParsec只支持将字符串作为输入，无法使用词法分析器，这是其美中不足之处。</strong></p>
<p>FParsec将解析器定义为一个函数，原型如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Parser&lt;&#39;Result, &#39;UserState&gt; &#x3D; CharStream&lt;&#39;UserState&gt; -&gt; Reply&lt;&#39;Result&gt;</span><br></pre></td></tr></table></figure>

<p>  这里的UserState是我们自己定义的State，一般设为unit（即空类型，没有内容）即可，暂时不去管他；这里的’Result是一个泛型类型，用户可以自己定义结果。</p>
<p>  这个函数的意义是，一个输入为CharStream型，输出为Reply的函数。</p>
<p>FParsec提供了一些用来从字符构建非终结符的函数，比如说:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let internal charReturnE (c: char) result error : Parser&lt;&#39;a,&#39;u&gt; &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      if stream.Skip(c) then Reply(result)</span><br><span class="line">      else Reply(Error, error)</span><br></pre></td></tr></table></figure>

<p>  我们使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D;  charReturnE &quot;a&quot; &quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>  即是定义了非终结符a，对应的字符也是”a”。</p>
<p>FParsec提供了一系列用于连接符号的函数。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let (.&gt;&gt;) (p: Parser&lt;&#39;a,&#39;u&gt;) (q: Parser&lt;&#39;b,&#39;u&gt;) &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      let mutable reply1 &#x3D; p stream</span><br><span class="line">      if reply1.Status &#x3D; Ok then</span><br><span class="line">          let stateTag1 &#x3D; stream.StateTag</span><br><span class="line">          let reply2 &#x3D; q stream</span><br><span class="line">          let error &#x3D; if isNull reply1.Error then reply2.Error</span><br><span class="line">                      elif stateTag1 &lt;&gt; stream.StateTag then reply2.Error</span><br><span class="line">                      else mergeErrors reply2.Error reply1.Error</span><br><span class="line">          reply1.Error  &lt;- error</span><br><span class="line">          reply1.Status &lt;- reply2.Status</span><br><span class="line">      reply1</span><br></pre></td></tr></table></figure>

<p>  这个符号是将两个非终结符连接起来，形成一个新的非终结符的函数。<br>  比如说：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let A &#x3D; charReturnE &quot;a&quot; &quot;a&quot;</span><br><span class="line">let B &#x3D; charReturnE &quot;a&quot; &quot;a&quot;</span><br><span class="line">let C &#x3D; A .&gt;&gt; B</span><br></pre></td></tr></table></figure>

<p>  实际上就是：</p>
<p>  $$ A \rightarrow a $$</p>
<p>  $$ B \rightarrow b $$</p>
<p>  $$ C \rightarrow AB $$</p>
<p>  的实现。</p>
<p>FParsec本质上是一个回退解析器，但它的性能却相当不错。这是因为它对选择符号(&lt;|&gt;)的实现：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let (&lt;|&gt;) (p1: Parser&lt;&#39;a,&#39;u&gt;) (p2: Parser&lt;&#39;a,&#39;u&gt;) : Parser&lt;&#39;a,&#39;u&gt; &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      let mutable stateTag &#x3D; stream.StateTag</span><br><span class="line">      let mutable reply &#x3D; p1 stream</span><br><span class="line">      if reply.Status &#x3D; Error &amp;&amp; stateTag &#x3D; stream.StateTag then</span><br><span class="line">          let error &#x3D; reply.Error</span><br><span class="line">          reply &lt;- p2 stream</span><br><span class="line">          if stateTag &#x3D; stream.StateTag then</span><br><span class="line">              reply.Error &lt;- mergeErrors reply.Error error</span><br><span class="line">      reply</span><br></pre></td></tr></table></figure>

<p>  我们看到，如果第一个Parser失败，<strong>当且仅当在stateTag没有改变时</strong>，才会进行用第二个Parser进行解析。</p>
<p>  这个stateTag，实际上就是position，也就是是当前解析到的位置。如此设计，保证了这个Parser<strong>仅仅会回退一个字符</strong>，因为如果第一个字符是匹配的，position就发生了变化。如此设计，使得它在某种意义上具有了$$LL(1)$$的特性。</p>
<p>  当然，我们也可以使用attempt强行使它回退。</p>
<p>针对下推自动机无法识别左递归的问题，FParsec引入了一个算符优先级解析器，帮助我们识别(1 + 1 - 2)一类的式子。</p>
<p>个人认为FParsec是一个不错的东西。但是F#和Haskell一样，本身语言设计有诸多麻烦之处，实际开发体验并没有特别舒服。</p>
<h3 id="Parser-Generator"><a href="#Parser-Generator" class="headerlink" title="Parser Generator"></a>Parser Generator</h3><p>这个东西应该是最为正统的方式了。Parser Generator可以做到由文法直接生成代码，我们不太需要关系内部是如何实现的。这个东西的集大成者是yacc，我们没什么好说的。</p>
<h3 id="算符优先级解析器"><a href="#算符优先级解析器" class="headerlink" title="算符优先级解析器"></a>算符优先级解析器</h3><p>我们并不陌生，大名鼎鼎的调度场算法即是这类解析器的一种，这里也不耗费笔墨了。</p>
<h2 id="从解析树到语法树"><a href="#从解析树到语法树" class="headerlink" title="从解析树到语法树"></a>从解析树到语法树</h2><p>解析树，顾名思义，就是解析器生成的树。这里有两个问题：</p>
<ul>
<li>逻辑上的解析树是唯一的，也就是生成文法生成句子的那棵生成树。</li>
<li>一个可以正确识别出输出符号串的解析器，一定是正确地构建出解析树了的，但是这颗解析树是逻辑上的，而非实现上的。实现上的解析树是什么样的，需要一一讨论。</li>
</ul>
<p>语法树则不同，语法树和解析树的关系是若即若离的：</p>
<ul>
<li>语法树的节点并不是解析器自动生成的，而是人为设计的。</li>
<li>即使没有Parser，我们也可以直接根据想法（<strong>而不是根据生成文法</strong>），构建出语法树。</li>
<li>一般来说，我们的Parser会在解析的同时，将解析时映射为语法树。</li>
</ul>
<p>我们考察两个有代表性的解析器–递归向下解析器与Yacc生成的解析器–是如何构建出解析树，并将其映射为语法树的。</p>
<h3 id="递归向下解析器的情况"><a href="#递归向下解析器的情况" class="headerlink" title="递归向下解析器的情况"></a>递归向下解析器的情况</h3><p>以如下文法为例：</p>
<p>$$ S \rightarrow A $$</p>
<p>$$ A \rightarrow M $$</p>
<p>$$ A \rightarrow M + A $$</p>
<p>$$ M \rightarrow D * M $$</p>
<p>$$ M \rightarrow D $$</p>
<p>$$ D \rightarrow int | (A) $$</p>
<p>这文法定义了一个支持加乘两种运算的式子。</p>
<p>我们用C#实现一下；</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RecursiveDesentParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Parser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Target &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> pointer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parser</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Target = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> success = (head = ParseA()) != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ParseEpsilon() &amp;&amp; success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Node now = ParseM();</span><br><span class="line">            <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseM</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Node now = ParseD();</span><br><span class="line">            <span class="keyword">if</span>(now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseM();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;*&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下代码略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来解析这样的式子:</p>
<p>$$ 1 + 2 * 3 $$</p>
<p>为了更好地展示解析的过程，我们需要把整个解析的所有调用都画出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ParseA</span><br><span class="line">  ParseM</span><br><span class="line">    ParseD : 1</span><br><span class="line">  ParseChar : +</span><br><span class="line">  ParseA</span><br><span class="line">    ParseM</span><br><span class="line">      ParseD : 2</span><br><span class="line">      ParseChar : *</span><br><span class="line">      ParseM</span><br><span class="line">        ParseD : 3</span><br></pre></td></tr></table></figure>

<p>我们发现：<strong>调用函数的过程，自然地形成了一颗解析树！</strong>，这也正是递归向下解析器的一大特性。</p>
<p>调用函数的过程本身就是解析树，将解析树映射为语法树的做法就呼之欲出了：将返回值作为语法树的节点，在每个函数内部实现解析树到语法树的节点的映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node now = ParseM();</span><br><span class="line">    <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">            nodes.Add(now);</span><br><span class="line">            <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">            nodes.Add(tail);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里，我们把自然形成的这个解析树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">  M</span><br><span class="line">  +</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>

<p>映射成了这样的语法树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">  M</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>

<h3 id="Yacc的情况"><a href="#Yacc的情况" class="headerlink" title="Yacc的情况"></a>Yacc的情况</h3><p>yacc是一个LALR(1)文法的Parser Generator. 它产生的分析器是一个自底向上的确定型分析器。</p>
<p>自底向上的意思是，它对应一个这样的自动机：</p>
<p>（在下面的示意中, .表示在.之前的位置已经被分析完了）</p>
<p>这个自动机的输入是一个字符串，它开始的状态是当然是:</p>
<p>$$ .a_{0}a_{1}a_{2}a_{3} $$</p>
<p>这个自动机还具有一个栈，在开始状态，栈中没有元素。</p>
<p>$$ S $$</p>
<p>这个自动机有两种操作：</p>
<ul>
<li>读入一个字符，把字符放到栈里。</li>
<li>把栈里的字符进行规约，化成别的符号。</li>
</ul>
<p>它不断地进行这两个操作，直至栈中得到开始符号为止。</p>
<p>以下面的语法和输入字符为例：</p>
<p>$$ S \Rightarrow A $$</p>
<p>$$ A \rightarrow Aa | a $$</p>
<p>$$ aaaa $$</p>
<p>首先，开始的状态是：</p>
<p>$$ 栈：$$</p>
<p>$$ .aaaa $$</p>
<p>移进一个a：</p>
<p>$$ 栈：a $$</p>
<p>$$ a.aaa $$</p>
<p>进行规约：</p>
<p>$$ 栈：A $$</p>
<p>$$ a.aaa $$</p>
<p>再移入一个a：</p>
<p>$$ 栈：Aa $$</p>
<p>$$ aa.aa $$</p>
<p>下面的操作就无需多言了。</p>
<p>这里我们会发现，自底向上的解析器的解析树，实际上体现在“规约”中，<strong>每一次的规约，实际上是以解析树的叶子节点替换解析树的根节点</strong>。</p>
<p>但这样一来，真正的解析树其实没有被留下，也就无法把解析树映射为语法树了。</p>
<p>为了解决这个问题，yacc引入了一个“内容栈”和“符号栈”的概念。</p>
<ul>
<li>内容栈：栈里是类型为YYSTYPE的值，它是保存结果用的栈。</li>
<li>符号栈：我们刚才说得用来分析的栈。</li>
</ul>
<p>这两个栈到底是怎么一回事呢？我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> typedef struct node</span><br><span class="line"> &#123;</span><br><span class="line"> struct node *left;</span><br><span class="line"> struct node *right;</span><br><span class="line"> char *token;</span><br><span class="line"> &#125; node;</span><br><span class="line"> node *mknode(node *left, node *right, char *token);</span><br><span class="line"> void printtree(node *tree);</span><br><span class="line">#define YYSTYPE struct node *</span><br><span class="line">%&#125; </span><br><span class="line"></span><br><span class="line">exp : term &#123;$$ &#x3D; $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; </span><br></pre></td></tr></table></figure>

<p>不难看出，node是语法树的节点类型，而那句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYSTYPE struct node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是将内容栈的元素类型定义为node*指针类型。</p>
<p>下面的那句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exp : term &#123;$$ &#x3D; $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果除去大括号，就是生成文法；而大括号里面的内容，则是对每条文法在<strong>内容栈</strong>上的操作，这个写法表示，在运用这条文法进行规约时，将内容栈上的对应元素拿出，并压入新构造的node*指针。</p>
<p>这样一来，我们又实现了从解析树映射到语法树的操作。</p>
<h2 id="需要注意的几个问题"><a href="#需要注意的几个问题" class="headerlink" title="需要注意的几个问题"></a>需要注意的几个问题</h2><h3 id="不要给Parser增加太多负担"><a href="#不要给Parser增加太多负担" class="headerlink" title="不要给Parser增加太多负担"></a>不要给Parser增加太多负担</h3><p>有些人想要在解析阶段就识别出来这种语法错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">0</span>;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>如果真的想做，这需要CSG解析。而CSG解析并没有一个很好的算法，所以，应该放弃这种不切实际的想法，在后面的阶段再检查这种错误。</p>
<h3 id="最好不要实现Parser"><a href="#最好不要实现Parser" class="headerlink" title="最好不要实现Parser"></a>最好不要实现Parser</h3><p>通过上面的描述，可以看到Parser是一个苦大仇深的行业。如果你实现一个复杂的语法，它的Parser会非常复杂，这会耗尽你对程序语言的热情。所以，让我们一起来实现Lisp吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/25/2020-4-25-parser2/" data-id="ckg4mhp39001x17sb4lxy5zod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          如何正确地烹制春笋
        
      </div>
    </a>
  
  
    <a href="/2020/04/21/2020-04-21-CLanguage/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">谈谈C语言的两个问题</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>