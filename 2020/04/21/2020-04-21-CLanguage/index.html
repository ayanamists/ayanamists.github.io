<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            谈谈C语言的两个问题
        </div>
        <div class="post-meta">
            2020-04-21
        </div>
    

    <div class="post-md">
        <h2 id="正确理解函数名"><a class="markdownIt-Anchor" href="#正确理解函数名"></a> 正确理解函数名</h2>
<p>只有正确理解函数名，才能正确使用函数指针。</p>
<p>函数指针是C语言里一个比较重要的特性。它实现了某种意义上的高阶函数，使得我们可以把函数作为参数和返回值。</p>
<p>我们知道，函数指针也就是一个变量，里面存储着指向的函数的地址。一个比较奇怪的问题是，以下两种写法在绝大多数编译器的眼里都是正确的：</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*p)</span><span class="hljs-params">()</span></span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;&#125;

p pointer = func; <span class="hljs-comment">//写法1</span>
p pointer = &amp;func; <span class="hljs-comment">//写法2</span>
</code></pre>
<p>有些人会这样解释：对一个函数取地址仍然得到函数本身。</p>
<p>用这个解释，我们可以解决&amp;&amp;func、&amp;&amp;&amp;func的问题，它们仍然会得到func本身。但我们很快就会觉得前一种写法本身与其他指针不太相容，比如说，你永远无法写出这样的代码：</p>
<pre class="highlight"><code class="c"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">int</span> p = a;
</code></pre>
<p>这么想来，我们不得不怀疑<em>对一个函数取地址仍然得到函数本身</em>这个说法的合理性。其实，问题的关键在于函数名究竟被处理为了什么。</p>
<p>答案很简单，<strong>函数名被处理为一个地址字面量值</strong>。</p>
<p>无论你对此有何评价，Clang、MSVC、GCC都是这样实现的。基于此，我们应该理解</p>
<pre class="highlight"><code class="c">p pointer = func;
</code></pre>
<p>的真正意思是，把func的地址赋给pointer。</p>
<p>所以，我们不能这样去写程序：</p>
<pre class="highlight"><code class="c">
<span class="hljs-comment">//main.c</span>
<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span><span class="hljs-params">(*p)</span><span class="hljs-params">()</span></span>;

<span class="hljs-keyword">extern</span> p func;

func2(p func)&#123;
  ...
&#125;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;
  func2(func);
&#125;

<span class="hljs-comment">//func.c</span>

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;
  ...
&#125;
</code></pre>
<p>如果这么写，你会惊喜地发现func2函数传入的是func函数编译后的二进制代码的前四位。这是因为编译器认为main.c中的func是一个变量，而对其取地址。但实际上func是一个字面量，本身就是要取的地址中的值了。</p>
<p>你可能会问了，这种不正确的写法为什么还可以正常编译链接呢？</p>
<p>这就要问问链接器了。</p>
<h2 id="正确理解链接过程"><a class="markdownIt-Anchor" href="#正确理解链接过程"></a> 正确理解链接过程</h2>
<p>链接器是石器时代的产物。由于C实际上是被编译为汇编后，再生成目标文件，最后被链接，实际上链接器是给汇编语言用的。</p>
<p>而这就带来了一大问题：链接的接口，即符号表（记录所有符号）与重定向表（记录要被重定向的符号），是没有C语言的类型信息的。</p>
<p>也就是说，每当你使用extern关键字声明外部引用时，<strong>你实际上是放弃了对该引用的静态类型检查</strong>。</p>
<p>而C<ins>则不会有这个问题。你可以将上面的代码改成C</ins>文件名或用C<ins>编译器编译，会发现链接器错误。因为C</ins>有名称修饰，它会将符号做处理，实际上附加了类型信息。但是，<strong>名称修饰不蕴含在C++的标准中，各家编译器厂商有自己的实现</strong>，所谓的<em>C++ ABI不兼容</em>，这个问题也占了一席之地。</p>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.highlightAll();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>