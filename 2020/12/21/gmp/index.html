<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#7350B9"><meta name="author" content="ayanamists"><meta name="copyright" content="ayanamists"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>栈式RAII不能取代GC：谈GMP的C++绑定 | aya ⊢ blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#7350B9"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ayanamists.xyz","root":"/","title":"云游君的小站","version":"1.6.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="GNU MP库的C++绑定 GNU MP库是一个大整数和多精度浮点数的运算库。它本身是用C语言写成的，但也提供了C++绑定。当用C++写程序时，如果你不是自虐狂或者狂热的手动编译器变换爱好者，那么用C++绑定毫无疑问是更好的选择。 这是因为，C语言版本的绑定把所有操作都封装成了类似于汇编语言中的指令。比如说，如果要算一个大整数版本的1+2，那么应该这么写： mpz_t a, b, c; mpz_">
<meta property="og:type" content="article">
<meta property="og:title" content="栈式RAII不能取代GC：谈GMP的C++绑定">
<meta property="og:url" content="https://ayanamists.xyz/2020/12/21/gmp/index.html">
<meta property="og:site_name" content="aya ⊢ blog">
<meta property="og:description" content="GNU MP库的C++绑定 GNU MP库是一个大整数和多精度浮点数的运算库。它本身是用C语言写成的，但也提供了C++绑定。当用C++写程序时，如果你不是自虐狂或者狂热的手动编译器变换爱好者，那么用C++绑定毫无疑问是更好的选择。 这是因为，C语言版本的绑定把所有操作都封装成了类似于汇编语言中的指令。比如说，如果要算一个大整数版本的1+2，那么应该这么写： mpz_t a, b, c; mpz_">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-12-21T19:31:00.000Z">
<meta property="article:modified_time" content="2021-11-25T15:34:56.321Z">
<meta property="article:author" content="ayanamists">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="GC">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="ayanamists"><img width="96" loading="lazy" src="/avatar.jpg" alt="ayanamists"></a><div class="site-author-name"><a href="/about/">ayanamists</a></div><span class="site-name">aya ⊢ blog</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">52</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">8</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">54</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="关于"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-information-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ayanamists" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:ayanamists@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191397140/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/woodwardchenxi" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/288120032" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="友情链接" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-heart-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#gnu-mp%E5%BA%93%E7%9A%84c%E7%BB%91%E5%AE%9A"><span class="toc-number">1.</span> <span class="toc-text"> GNU MP库的C++绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E8%AE%A9%E4%BA%BA%E5%A4%A7%E5%91%BC%E6%80%AA%E5%93%89%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text"> 一个让人大呼『怪哉』的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gnu-mp%E5%BA%93%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text"> GNU MP库的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text"> 解决问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gc%E4%B8%8Eraii"><span class="toc-number">5.</span> <span class="toc-text"> GC与RAII</span></a></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ayanamists.xyz/2020/12/21/gmp/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="ayanamists"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="aya ⊢ blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">栈式RAII不能取代GC：谈GMP的C++绑定</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2020-12-21 19:31:00" itemprop="dateCreated datePublished" datetime="2020-12-21T19:31:00+00:00">2020-12-21</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-11-25 15:34:56" itemprop="dateModified" datetime="2021-11-25T15:34:56+00:00">2021-11-25</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E5%AD%A6%E6%9C%AF/" style="--text-color:var(--hty-text-color)" itemprop="url" rel="index"><span itemprop="text">学术</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/C/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">C++</span></a><a class="tag-item" href="/tags/GC/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">GC</span></a></span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#7350B9;"><h2 id="gnu-mp库的c绑定"><a class="markdownIt-Anchor" href="#gnu-mp库的c绑定"></a> GNU MP库的C++绑定</h2>
<p>GNU MP库是一个大整数和多精度浮点数的运算库。它本身是用C语言写成的，但也提供了C++绑定。当用C++写程序时，如果你不是自虐狂或者狂热的手动编译器变换爱好者，那么用C++绑定毫无疑问是更好的选择。</p>
<p>这是因为，C语言版本的绑定把所有操作都封装成了类似于汇编语言中的指令。比如说，如果要算一个大整数版本的<code>1+2</code>，那么应该这么写：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token class-name">mpz_t</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
<span class="token function">mpz_init_set_ui</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mpz_init_set_ui</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mpz_add</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mpz_clear</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mpz_clear</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">mpz_clear</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>说实话，这还不如直接写汇编来的简洁：</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">mov $1, %eax
mov $2, %ebx
add %ebx, %eax
mov %ecx, %eax<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种情况的根本原因是，C语言中没有方便的手段来进行内存资源管理和快速结构构造（当然，新的标准也有了一些），导致C语言虽然可以实现<em>表达式求值模型</em>，但无法方便地实现<em>自定义类型的表达式求值模型</em>。</p>
<p>而表达式求值模型和寄存器机模型之间的变换就是编译的本质，用C语言这样写代码，相当于是在自己进行部分编译器进行的变换（比如ANF）。所以，喜欢这样写代码的人要么是喜欢写汇编，要么是喜欢自己进行手动编译器变换。</p>
<p>C++绑定这时堪称救世主，在不得不使用C/C++的场合（比如我校的《现代密码学实验》课程），用C++绑定可以避免这种尴尬：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const mpz_class a &#123;1&#125;, b &#123;2&#125;;
const auto c &#x3D; a + b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这段代码可以执行和上面C语言代码<strong>完全相同</strong>的行为。这是因为C++相比C有了几个优良特性，其中最优秀的的当属所谓的RAII，也就是<strong>R</strong>esource <strong>A</strong>cquisition <strong>I</strong>s <strong>I</strong>nitialization，获取资源即初始化。在这里和运行栈一起配合，简单来说说就是构造函数和析构函数的配合，使得栈上的对象在构造时（手动引入一个绑定时）获取资源，在析构时（退出当前作用域时自动析构）释放资源。对内存这种资源来说，这样一来我们好似在使用一种『有GC的语言』，无须关心任何内存问题一样。</p>
<p>自然而然的一个问题是，栈式RAII真的能够代替GC吗？通过下文对GMP的解说，想必读者能够给出自己的答案。</p>
<h2 id="一个让人大呼怪哉的问题"><a class="markdownIt-Anchor" href="#一个让人大呼怪哉的问题"></a> 一个让人大呼『怪哉』的问题</h2>
<p>已经说过，我使用GNU MP库的主要目的是为了进行密码学实验。我们的密码学实验中有一个计算DLP（离散对数）的问题，规模非常大，运行速度是比较重要的因素。由此我必须使用GNU MP这种速度有保证的库。然而，在实验中，我遇到了一个非常奇怪的问题，那就是有时候某些代码常常出现不正确的结果，而我反复检查代码也不能发现问题的由来。更严重的是，这些问题像幽灵一样，有时出现有时不出现，出现时的结果有时是<em>不相同</em>的。</p>
<p>对此，我第一反应是出了一些内存问题。可我立刻就否定了这种想法。GNU MP这种『身经百战』，『背负着GNU之名』的库，怎么会出现这种问题？可是我的代码中只有简单的计算，类似于：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
 * Pohlig-Hellman algorithm for Group of prime power order
 *&#x2F;
mpz_class
pohligHellmanP(const mpz_class&amp; g, const mpz_class&amp; h,
               const mpz_class&amp; pn, const mpz_class&amp; en,
               const mpz_class&amp; p) &#123;
    const auto y &#x3D; fastPow(g, Pow(pn, en - 1), p);
    assert (fastPow(y, pn, p) &#x3D;&#x3D; 1);
    mpz_class x&#123;0&#125;;
    for (auto i &#x3D; 0; i &lt; en; ++i) &#123;
        auto hi &#x3D; fastPow(Inverse(fastPow(g, x, p), p) * h,
                          Pow(pn, en - 1 - i), p);
        auto di &#x3D; pDlp(y, hi, pn, p);
        x &#x3D; x + Pow(pn, i) * di;
    &#125;
    return x;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>怎么想也不会出现问题。在经过了一番艰险的探索后，我确定了一个『最小问题结构』。『最小问题结构』时说，触发这个问题的最简单、行数最少的代码。它是：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mpz_class nothing() &#123;
  const auto a &#x3D; mpz_class &#123; 1 &#125; + mpz_class &#123; 2 &#125;;
  std::cout &lt;&lt; a &lt;&lt; std::endl;
  return a;
&#125;

int main() &#123;
  std::cout &lt;&lt; nothing();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在我的计算机上，这段代码会给出非常惊人的结果：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">➜  gmp_error git:(master) ✗ g++ test.cpp -o a -g -lgmp -O0 -lgmpxx
➜  gmp_error git:(master) ✗ .&#x2F;a                                   
94361021124304
94361021124336%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>94361021124304</mn></mrow><annotation encoding="application/x-tex">1+2=94361021124304</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mord">3</span><span class="mord">6</span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mord">4</span><span class="mord">3</span><span class="mord">0</span><span class="mord">4</span></span></span></span>，还是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>=</mo><mn>94361021124336</mn></mrow><annotation encoding="application/x-tex">1+2=94361021124336%</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">9</span><span class="mord">4</span><span class="mord">3</span><span class="mord">6</span><span class="mord">1</span><span class="mord">0</span><span class="mord">2</span><span class="mord">1</span><span class="mord">1</span><span class="mord">2</span><span class="mord">4</span><span class="mord">3</span><span class="mord">3</span><span class="mord">6</span></span></span></span>？</p>
<p>如此简单的代码却产生了如此诡异的错误，真是怪哉！</p>
<h2 id="gnu-mp库的设计"><a class="markdownIt-Anchor" href="#gnu-mp库的设计"></a> GNU MP库的设计</h2>
<p>要破解这个谜团，我们应该从另一个怪现象下手，那即是：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mpz_class nothing() &#123;
  const mpz_class a &#x3D; mpz_class &#123; 1 &#125; + mpz_class &#123; 2 &#125;;
  std::cout &lt;&lt; a &lt;&lt; std::endl;
  return a;
&#125;

int main() &#123;
  std::cout &lt;&lt; nothing();
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码竟然毫无问题？恐怕读者难以相信这个事实，然而它就是真正的现实：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">➜  gmp_error git:(master) ✗ g++ test.cpp -o a -g -lgmp -O0 -lgmpxx
➜  gmp_error git:(master) ✗ .&#x2F;a                                   
3
3%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来问题就很明朗了。<code>auto</code>这个关键字究竟会将<code>a</code>推导为什么类型？用IDE或者c++filt查看，答案更是让人一头雾水：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const __gmp_expr&lt;mpz_t, __gmp_binary_expr&lt;mpz_class, mpz_class, __gmp_binary_plus&gt;&gt; a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这类型是什么？看来必须到<code>gmpxx.h</code>这个文件里寻找答案了。</p>
<p>在<code>gmpxx.h</code>中，我们会看到，<code>mpz_class</code>实际上是<code>mpz_expr&lt;mpz_t, mpz_t&gt;</code>:</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;**************** mpz_class -- wrapper for mpz_t ****************&#x2F;

template &lt;&gt; &#x2F;&#x2F; line 1572
class __gmp_expr&lt;mpz_t, mpz_t&gt;&#123; ... &#125;; 

typedef __gmp_expr&lt;mpz_t, mpz_t&gt; mpz_class; &#x2F;&#x2F; line 1756<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么，这个<code>__gmp_expr</code>高阶类型（理论上来说这确实相当于高阶类型）恐怕还有一些其他的特化，果不其然，这个文件中还定义了很多<code>__gmp_expr</code>的特化，比如说，我们前面看到的<code>a</code>，实际上的类型是：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T, class Op&gt;
class __gmp_expr
&lt;T, __gmp_binary_expr&lt;__gmp_expr&lt;T, T&gt;, __gmp_expr&lt;T, T&gt;, Op&gt; &gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们观察一下这个类的构造函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__gmp_expr(const val1_type &amp;val1, const val2_type &amp;val2)
    : expr(val1, val2) &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>expr</code>是类的成员变量，它声明为：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__gmp_binary_expr&lt;val1_type, val2_type, Op&gt; expr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个<code>__gmp_binary_expr</code>又是何方神圣呢？它定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T, class U, class Op&gt;
struct __gmp_binary_expr
&#123;
  typename __gmp_resolve_ref&lt;T&gt;::ref_type val1;
  typename __gmp_resolve_ref&lt;U&gt;::ref_type val2;

  __gmp_binary_expr(const T &amp;v1, const U &amp;v2) : val1(v1), val2(v2) &#123; &#125;
private:
  __gmp_binary_expr();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这有点令人一头雾水，定义这样的一个只有构造函数的类似乎没有什么特别的意义，我们需要寻找到用到它的函数。之前提到过，如果右值的类型是<code>mpz_class</code>，那么就不会产生问题。从，<code>mpz_expr&lt;..&gt;</code>变成<code>mpz_class</code>，一定发生了一个类型转换。这个类型转换的函数在哪里呢？再回到<code>mpz_class</code>的定义当中：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt;
__gmp_expr(const __gmp_expr&lt;mpz_t, T&gt; &amp;expr)
&#123; mpz_init(mp); __gmp_set_expr(mp, expr); &#125;
template &lt;class T, class U&gt;
explicit __gmp_expr(const __gmp_expr&lt;T, U&gt; &amp;expr)
&#123; mpz_init(mp); __gmp_set_expr(mp, expr); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数毫无疑问是在将<code>__gmp_expr&lt;...&gt;</code>转换为<code>mpz_class</code>. 那么<code>__gmp_set_expr</code>又是在做什么呢？</p>
<p>查看其定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T&gt;
inline void __gmp_set_expr(mpz_ptr z, const __gmp_expr&lt;mpz_t, T&gt; &amp;expr)
&#123;
  expr.eval(z);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>嗯？这个<code>eval</code>函数看起来是<code>__gmp_expr&lt;T ...&gt;</code>中定义的，我们再查看一下刚才的定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void eval(typename __gmp_resolve_expr&lt;T&gt;::ptr_type p) const
&#123; Op::eval(p, expr.val1.__get_mp(), expr.val2.__get_mp()); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>转发到了<code>Op::eval</code>这个函数上。之前类型的<code>Op</code>是<code>__gmp_binary_plus</code>，它的<code>eval</code>函数是如何定义的呢？</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct __gmp_binary_plus
&#123;
  static void eval(mpz_ptr z, mpz_srcptr w, mpz_srcptr v)
  &#123; mpz_add(z, w, v); &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这实在是十分亲切，我们终于搞明白了这一套组合拳到底是在做些什么事情。</p>
<p>首先，<code>__gmp_expr&lt; ... &gt;</code>相当于一个语法树，它记录了所有的操作信息。当这个类型的值被转换为<code>mpz_class</code>时，进行求值，求完的值被放到了转换后的绑定中。</p>
<p>可是，这究竟有何意义？在我看来，这样的代码没有简化任何逻辑。C++编译器完全可以保证不产生多余的复制，实际上，如此复杂的构造和直白地写一个类并重载运算符的效果几乎是完全一致的。</p>
<p>唯一的好处，就是当变量使用<code>auto</code>而不是<code>mpz_class</code>时，变量本身是语法树而不是值，只有当需要这个表达式的值时（也就是进行类型转换时）才进行求值。这就是所谓的『惰性求值』。</p>
<p>我很难理解在数值计算任务上进行惰性求值究竟有什么好处。惰性求值最大的好处就是不会算出不必要的值，比如说：</p>
<pre class="line-numbers language-scheme" data-language="scheme"><code class="language-scheme"><span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token keyword">define</span> <span class="token punctuation">(</span><span class="token function">g</span> t1 t2<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">t2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token punctuation">(</span><span class="token function">g</span> <span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">;在scheme中，无限循环</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-haskell" data-language="haskell"><code class="language-haskell"><span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span>
<span class="token hvariable">g</span> <span class="token hvariable">t1</span> <span class="token hvariable">t2</span> <span class="token operator">=</span> <span class="token hvariable">t2</span>
<span class="token hvariable">g</span> <span class="token hvariable">f</span> <span class="token number">1</span> <span class="token comment">--在haskell中，这会得到 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>可是，在这样的数值计算任务中，我们一般不会进行任何多余的计算。惰性求值本身不能简化必要计算，从性能上来说，这毫无优势。</p>
<p>而且，这设计会产生刚才的严重错误。这是因为，每个<code>__gmp_binary_expr</code>保存的实际上是两个变量的<code>const</code>引用，而从根本上来说，<code>const</code>引用是无法捕获一个右值的。调用</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">__gmp_binary_expr(const T &amp;v1, const U &amp;v2) : val1(v1), val2(v2) &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>只会把指向<code>v1</code>的指针赋值给<code>val1</code>，把指向<code>v2</code>的指针赋值给<code>val2</code>。</p>
<p>回过头来再看这句代码：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const auto a &#x3D; mpz_class &#123; 1 &#125; + mpz_class &#123; 2 &#125;;
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>它实际上会变成：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">mpz_class temp1 &#123;1&#125;, temp2 &#123;2&#125;;
a &#x3D; temp1 + temp2;
~temp1(); ~temp2();
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>当析构函数执行之后，<code>a</code>这棵语法树中节点所指向的目标已经被完全析构，访问这些对象的代码全部是错误的。换句话说，<code>a</code>合法的时光仅存在于当前语句执行完、下一条语句还未执行的那一瞬间而已。</p>
<h2 id="解决问题"><a class="markdownIt-Anchor" href="#解决问题"></a> 解决问题</h2>
<p>要解决问题，有两个方法：</p>
<ul>
<li>修改<code>gmpxx.h</code>.</li>
<li>所有的声明全部使用<code>mpz_class</code>而不是<code>auto</code>.</li>
</ul>
<p>不过，即使修改这个文件，<code>const&amp;</code>不能捕获右值的问题仍然是无法解决的。</p>
<p>把<code>__gmp_binary_expr</code>改为值语义怎么样？换句话说，我们让<code>val1</code>，<code>val2</code>不再是<code>const &amp;T</code>和<code>const &amp;U</code>而是真正的<code>T</code>和<code>U</code>.</p>
<p>这可以无痛地解决<code>const auto a = mpz_class &#123; 1 &#125; + mpz_class &#123; 2 &#125;;</code>的问题。因为<code>mpz_class&#123;1&#125;</code>和<code>mpz_class&#123;2&#125;</code>都是『右值』，或者说是『X值』，有『右值引用』这个方法可以无痛地交接资源。实际上，如果只是解决加法的问题，我们只需要修改几个地方即可：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 修改这个宏，使得加法有右值引用的版本 *&#x2F;
#define __GMPP_DEFINE_BINARY_FUNCTION(fun, eval_fun)                   \
                                                                       \
template &lt;class T, class U, class V, class W&gt;                          \
inline __gmp_expr&lt;typename __gmp_resolve_expr&lt;T, V&gt;::value_type,       \
__gmp_binary_expr&lt;__gmp_expr&lt;T, U&gt;, __gmp_expr&lt;V, W&gt;, eval_fun&gt; &gt;      \
fun(const __gmp_expr&lt;T, U&gt; &amp;expr1, const __gmp_expr&lt;V, W&gt; &amp;expr2)      \
&#123;                                                                      \
  return __gmp_expr&lt;typename __gmp_resolve_expr&lt;T, V&gt;::value_type,     \
     __gmp_binary_expr&lt;__gmp_expr&lt;T, U&gt;, __gmp_expr&lt;V, W&gt;, eval_fun&gt; &gt; \
    (expr1, expr2);                                                    \
&#125;                                                                      \
template &lt;class T, class U, class V, class W&gt;                          \
inline __gmp_expr&lt;typename __gmp_resolve_expr&lt;T, V&gt;::value_type,       \
__gmp_binary_expr&lt;__gmp_expr&lt;T, U&gt;, __gmp_expr&lt;V, W&gt;, eval_fun&gt; &gt;      \
fun(__gmp_expr&lt;T, U&gt; &amp;&amp;expr1, __gmp_expr&lt;V, W&gt; &amp;&amp;expr2)                \
&#123;                                                                      \
  return __gmp_expr&lt;typename __gmp_resolve_expr&lt;T, V&gt;::value_type,     \
     __gmp_binary_expr&lt;__gmp_expr&lt;T, U&gt;, __gmp_expr&lt;V, W&gt;, eval_fun&gt; &gt; \
    (std::move(expr1), std::move(expr2));                              \
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* 修改这个类，使得构造函数有右值引用的版本 *&#x2F;
template &lt;class T, class Op&gt;
class __gmp_expr
&lt;T, __gmp_binary_expr&lt;__gmp_expr&lt;T, T&gt;, __gmp_expr&lt;T, T&gt;, Op&gt; &gt;
&#123;
private:
  typedef __gmp_expr&lt;T, T&gt; val1_type;
  typedef __gmp_expr&lt;T, T&gt; val2_type;

  __gmp_binary_expr&lt;val1_type, val2_type, Op&gt; expr;
public:
  __gmp_expr(const val1_type &amp;val1, const val2_type &amp;val2)
    : expr(val1, val2) &#123; &#125; 
  __gmp_expr(val1_type &amp;&amp;val1, val2_type &amp;&amp;val2) &#x2F;&#x2F; 新加入的构造函数
    : expr(std::move(val1), std::move(val2)) &#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class Op&gt;
struct __gmp_binary_expr&lt;mpz_class, mpz_class, Op&gt;
&#123;
  mpz_class val1;
  mpz_class val2;
  __gmp_binary_expr(const mpz_class &amp;v1, const mpz_class &amp;v2) 
    : val1(v1), val2(v2) &#123; &#125;
  __gmp_binary_expr(mpz_class &amp;&amp;v1, mpz_class &amp;&amp;v2) 
    : val1(std::move(v1)), val2(std::move(v2)) &#123; &#125;
private:
  __gmp_binary_expr();
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>自定义一个<code>__gmp_binary_expr</code>的特化，处理两个都是<code>mpz_class</code>的场合。</p>
<p>这样就可以使得上述代码得到正确的<code>3</code>.</p>
<p>然而，先不说都修正完的工作量，如此修正我们必然会遇到一个问题：<em>如果传入的是左值，则无法进行『无痛』的移动，要进行复制，这是不利于性能的</em>。</p>
<p>怎样解决这个问题呢？答案是（至少我）解决不了。</p>
<h2 id="gc与raii"><a class="markdownIt-Anchor" href="#gc与raii"></a> GC与RAII</h2>
<p>上面的问题在有GC的语言中，简单来说不算问题。即使是在python这样的语言中，不断地得到一个资源的绑定并不会产生任何复制：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>
b <span class="token operator">=</span> a
c <span class="token operator">=</span> b<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>当然，这是因为<code>a</code>、<code>b</code>、<code>c</code>实际上都是指向同一个对象的，类似于<code>const &amp;</code>.</p>
<p>可是，有GC语言里的<code>const &amp;</code>可以完美地解决『不能捕获右值』的问题：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">:</span>
    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">:</span>
        self<span class="token punctuation">.</span>arr <span class="token operator">=</span> arr
        
a <span class="token operator">=</span> A<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从根本上来说，RAII不能使得同一个栈上的对象被两个绑定所同时『拥有』，栈上的对象被消除的规则是严格的作用域规则，不能出现『从栈上借对象』这样的情况。而有GC语言由于『对象』和『对象所拥有的资源』都在堆上，甚至是一体的，所以不会出现这个问题。</p>
<p>这样来看，RAII是不能替代GC的。当然，Rust等语言可能可以通过一些别的办法来解决这个问题。不过，我们可以下这个结论：在C++中，RAII的能力终究是有限的。</p>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>ayanamists</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://ayanamists.xyz/2020/12/21/gmp/" title="栈式RAII不能取代GC：谈GMP的C++绑定">https://ayanamists.xyz/2020/12/21/gmp/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2020/12/26/pascal/" rel="prev" title="帕斯卡的恩惠"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">帕斯卡的恩惠</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2020/12/08/hc/" rel="next" title="看点什么（三）寒蝉鸣泣之时"><span class="post-nav-text">看点什么（三）寒蝉鸣泣之时</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div><style>.utterances {
  max-width: 100%;
}</style><script src="https://utteranc.es/client.js" repo="ayanamists/ayanamists.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> ayanamists</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.2</span></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="Total Visitors"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#7350B9" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>