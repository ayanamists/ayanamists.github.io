<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>让我们实现编程语言吧(六) 递归函数的养成方法 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="lambda表达式的递归我们知道，一般的lambda表达式会将let实现为： $$(let\ x\ &#x3D;\ expr1 \ in\ expr2) \equiv (\lambda x.expr2)expr1$$ 这样一来，在expr1中，x的绑定不是expr1. 【递归】似乎也就无从谈起了，因为在expr1中，无法得到一个绑定，使得x被绑定为expr1. 那么，难道用lambda表达式是无法实现递归的">
<meta property="og:type" content="article">
<meta property="og:title" content="让我们实现编程语言吧(六) 递归函数的养成方法">
<meta property="og:url" content="http://example.com/2020/08/30/2020-08-30-pl6/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="lambda表达式的递归我们知道，一般的lambda表达式会将let实现为： $$(let\ x\ &#x3D;\ expr1 \ in\ expr2) \equiv (\lambda x.expr2)expr1$$ 这样一来，在expr1中，x的绑定不是expr1. 【递归】似乎也就无从谈起了，因为在expr1中，无法得到一个绑定，使得x被绑定为expr1. 那么，难道用lambda表达式是无法实现递归的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pic.downk.cc/item/5f4b5350160a154a67667115.jpg">
<meta property="article:published_time" content="2020-08-30T00:00:00.000Z">
<meta property="article:modified_time" content="2020-10-11T04:43:47.184Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pic.downk.cc/item/5f4b5350160a154a67667115.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2020-08-30-pl6" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/30/2020-08-30-pl6/" class="article-date">
  <time datetime="2020-08-30T00:00:00.000Z" itemprop="datePublished">2020-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      让我们实现编程语言吧(六) 递归函数的养成方法
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="lambda表达式的递归"><a href="#lambda表达式的递归" class="headerlink" title="lambda表达式的递归"></a>lambda表达式的递归</h2><p>我们知道，一般的lambda表达式会将let实现为：</p>
<p>$$<br>(let\ x\ =\ expr1 \ in\ expr2) \equiv (\lambda x.expr2)expr1<br>$$</p>
<p>这样一来，在expr1中，x的绑定不是expr1. 【递归】似乎也就无从谈起了，因为在expr1中，无法得到一个绑定，使得x被绑定为expr1.</p>
<p>那么，难道用lambda表达式是无法实现递归的吗？当然不是，不过我们首先要明确一个事实 – <strong>一切递归都可以实现为循环</strong>。</p>
<p>如果我们可以实现循环，那么就可以实现递归。但不幸的是，如果你用过scheme一类语言的话，你会知道在scheme中，循环被实现为尾递归。在lambda表达式中也没有循环的概念，我们无法用这个方法来解决问题。</p>
<p>回到【实现递归】这个目标上来。如果我们想要在<code>expr1</code>中调用<code>expr1</code>自己，就必须在<code>expr1</code>中得到对<code>expr1</code>的一个绑定。</p>
<p>这个绑定是【绑定变量】还是【自由变量】呢？刚才我们已经用<code>let</code>的实现宣告了【自由变量】这个思路不太可行，我们要用【绑定变量】的思路。</p>
<p>也就是说，<code>expr1</code>的形式应该是</p>
<p>$$<br>expr1:\lambda f.\lambda x. expr<br>$$</p>
<p>其中<code>f</code>会被绑定为</p>
<p>$$<br>\lambda x.expr<br>$$</p>
<p>或者说</p>
<p>$$<br>(expr1\ f)<br>$$</p>
<p>这个时候我们惊奇地发现，<code>f</code>竟然会满足这个式子：</p>
<p>$$<br>f \equiv (expr1\ f)<br>$$</p>
<p>如果把<code>f</code>写作参数常用的<code>x</code>，把<code>expr1</code>写作函数常用的<code>f</code>，我们会发现上式变成了：</p>
<p>$$<br>x \equiv (f\ x)<br>$$</p>
<p>这就是所谓的【不动点】。比如说<code>cos</code>函数的不动点是：</p>
<p>$$<br>x = \cos(x)<br>$$</p>
<p>解方程，得到</p>
<p>$$<br>x = 0.739085<br>$$</p>
<p>那么，只要我们找到<br>$$<br>expr1<br>$$<br>这个函数的【不动点】<code>f</code>，$$(expr1\ f)$$就会是一个递归函数。</p>
<p>应该如何寻找这个不动点呢？这是一件非常困难的事。我们注意到一个事实：</p>
<p>$$<br>(\lambda x.xx)(\lambda x.xx)<br>$$</p>
<p>这个式子的$$\beta-reduction$$形式永远是它自己。</p>
<p>试着给前面的式子加一个<code>f</code>，我们会得到：</p>
<p>$$<br>(\lambda x.f (xx))(\lambda x.xx) \equiv f((\lambda x.xx)(\lambda x.xx))<br>$$</p>
<p>我们惊喜地发现，如果给后面的式子也如法炮制，那么就会有：</p>
<p>$$<br>(\lambda x.f(xx))(\lambda x.f(xx)) \equiv f((\lambda x.f(xx))(\lambda x.f(xx)))<br>$$</p>
<p>如果把</p>
<p>$$<br>(\lambda x.f(xx))(\lambda x.f(xx))<br>$$</p>
<p>记作<code>f</code>，</p>
<p>把<code>f</code>记作<code>expr1</code>，那么就会有：</p>
<p>$$<br>(\lambda x.expr1(xx))(\lambda x.expr1(xx)) \equiv expr1((\lambda x.expr1(xx))(\lambda x.expr1(xx))) \<br>f \equiv (expr1\ f) \<br>$$</p>
<p>看来，</p>
<p>$$<br>(\lambda x.expr1(xx))(\lambda x.expr1(xx))<br>$$</p>
<p>就是我们所要找到的式子了！</p>
<p>而且，因为</p>
<p>$$<br>f \equiv (expr1\ f)<br>$$</p>
<p>所以$$f$$本身就是递归函数，我们构造一个新的lambda表达式：</p>
<p>$$<br>\lambda f.(\lambda x.f(xx))(\lambda x.f(xx))<br>$$</p>
<p>$$<br>(\lambda f.(\lambda x.f(xx))(\lambda x.f(xx)))expr1<br>$$</p>
<p>就会是递归函数本身。上面的新表达式就是大名鼎鼎的y-combinator.</p>
<p>但问题还没有完全解决。如果你真的把这个东西输入到scheme中，会发现这个构造是不成功的。因为它会不断对$$f$$求值得到$$(expr1\ f)$$，从而陷入无限循环中。</p>
<p>如果语言是【惰性求值】的，那么上面的构造将会是成功的。根据这个思路，我们可以给出真正可用的y-combinator.</p>
<p>首先，上面的构造最应该【惰性】的地方，是</p>
<p>$$<br>(\lambda x.f(xx))(\lambda x.f(xx))<br>$$</p>
<p>中前一个式子的$$(xx)$$调用。如果能把它【惰性化】，那么问题就解决了。</p>
<p>如何把它【惰性化】呢？我们用老套路：</p>
<ol>
<li>一个调用被<code>(lambda () ...)</code>包住后，不会立刻求值，而是会得到一个函数对象<code>late</code></li>
<li><code>(late)</code>可以进行求值</li>
</ol>
<p>根据这个套路，我们写出：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">y-combinator1</span> f)</span><br><span class="line">  (<span class="name">λ</span> ()</span><br><span class="line">    ((<span class="name">λ</span> (<span class="name">x</span>) (<span class="name">f</span> (<span class="name">λ</span> () (<span class="name">x</span> x))))</span><br><span class="line">     (<span class="name">λ</span> (<span class="name">x</span>) (<span class="name">f</span> (<span class="name">λ</span> () (<span class="name">x</span> x)))))))</span><br></pre></td></tr></table></figure>

<p>不过这样一来，参数位置上的$$f$$就会被变成<code>(λ () ... )</code>，我们需要显式地对它求值：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factor-f</span> f)</span><br><span class="line">  (<span class="name">λ</span> (<span class="name">x</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> x ((<span class="name">f</span>) (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> factor</span><br><span class="line">  (<span class="name">y-combinator1</span> factor-f))</span><br><span class="line"></span><br><span class="line">((<span class="name">factor</span>) <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>有没有能【无损】地进行【惰性求值】的方法呢？</p>
<p>我在初学<code>scheme</code>时，曾经有过这样的疑问：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cos ;形式1</span><br><span class="line">(<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">cos</span></span> x)) <span class="comment">;形式2</span></span><br></pre></td></tr></table></figure>

<p>这两个形式究竟有什么区别呢？</p>
<p>在真正地思考过后，我们会发现，形式1是在【得到函数对象的值】，而形式2只有当【函数对象的参数给出后】才会【得到函数对象的值】.</p>
<p>简单地说，在形式2中，<code>cos</code>这个函数被【惰性化】了！</p>
<p>那么在</p>
<p>$$<br>(\lambda x.f(xx))(\lambda x.f(xx))<br>$$</p>
<p>中，有没有可以按照上面的策略进行【惰性化】的地方呢？</p>
<p>当然有，$$(f (xx))$$最终会得到一个有参数的函数，我们可以把这个参数写出来：</p>
<p>$$<br>(\lambda x\lambda a.f(xx)a)(\lambda x.f(xx))<br>$$</p>
<p>为了保持不动点的性质，实际上应该写出：</p>
<p>$$<br>\lambda a.f((\lambda x.\lambda a.f(xx)a)(\lambda x.\lambda a.f(xx)a))a<br>$$</p>
<p>而这，就是所谓的Z-combinator. 利用它，我们可以实现我们的真正目标：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">y-combinator2</span> f)</span><br><span class="line">  ((<span class="name">λ</span> (<span class="name">x</span>) (<span class="name">λ</span> (<span class="name">a</span>) ((<span class="name">f</span> (<span class="name">x</span> x)) a)))</span><br><span class="line">   (<span class="name">λ</span> (<span class="name">x</span>) (<span class="name">λ</span> (<span class="name">a</span>) ((<span class="name">f</span> (<span class="name">x</span> x)) a)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">y-combinator2-let</span> f)</span><br><span class="line">  (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">d</span> (<span class="name">λ</span> (<span class="name">x</span>)</span><br><span class="line">             (<span class="name">λ</span> (<span class="name">a</span>)</span><br><span class="line">               ((<span class="name">f</span> (<span class="name">x</span> x)) a)))])</span><br><span class="line">    (<span class="name">d</span> d))) </span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factor-f2</span> f)</span><br><span class="line">  (<span class="name">λ</span> (<span class="name">x</span>)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">f</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> factor2</span><br><span class="line">  (<span class="name">y-combinator2-let</span> factor-f2))</span><br><span class="line"></span><br><span class="line">(<span class="name">factor2</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>在<em>Essentials of Programming Languages</em>中，还有一种办法可以得到递归函数，而且更好理解一些：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">factor-f</span> f)</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> x ((<span class="name">f</span> f) (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> factor</span><br><span class="line">  (<span class="name">factor-f</span> factor-f))</span><br><span class="line"></span><br><span class="line">(<span class="name">factor</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<h2 id="在解释器中实现递归"><a href="#在解释器中实现递归" class="headerlink" title="在解释器中实现递归"></a>在解释器中实现递归</h2><p>虽说可以用y-combinator或者z-combinator构造递归，但是这样的东西在性能能不是最优解。最优解当然是在语言内支持递归。</p>
<p>其实，无论是scheme还是ML、Haskell，都是在语言层面上实现了递归的。 例如说</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">letrec</span></span> ((<span class="name">factor</span></span><br><span class="line">          (<span class="name"><span class="builtin-name">lambda</span></span> (x) </span><br><span class="line">            (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">                <span class="number">1</span></span><br><span class="line">                (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">factor</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>))))))</span><br><span class="line">  (<span class="name">factor</span> <span class="number">10</span>))</span><br></pre></td></tr></table></figure>

<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> factor x = <span class="keyword">if</span> x = <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * (factor x - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>那么，我们应该也可以在语言中实现递归。<em>Essentials of Programming Languages</em>里定义了<code>letrec</code>关键字：</p>
<p><img src="https://pic.downk.cc/item/5f4b5350160a154a67667115.jpg" alt="1"></p>
<p>我们如何对<code>letrec-exp</code>进行求值呢？方法当然是无限多的，这里给出两种方式。</p>
<h3 id="extend-environment-rec"><a href="#extend-environment-rec" class="headerlink" title="extend-environment-rec"></a>extend-environment-rec</h3><p>如果你也试着去实现了对此表达式的求值，那么你会发现，最麻烦的问题是，我们需要使得<code>env</code>中存在对这个函数的绑定，但是要构造这个函数的值却需要已经构造好的<code>env</code>，这成了一个【先有鸡还是先有蛋】的无限递归问题。</p>
<p>为了解决这个问题，我们考虑这样的一个事实：</p>
<p>假设</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">letrec f(x) = <span class="keyword">if</span> zero?(x) <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> x * f(x - <span class="number">1</span>) <span class="keyword">in</span> f(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>这里的<code>f</code>的<code>env</code>已经被构造好了，那么，我们一定有：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(apply-environment env f) = </span><br><span class="line">	(<span class="name">procedure</span> var exp env)</span><br></pre></td></tr></table></figure>

<p>根据这个分析，如果我们的函数</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">extend-environment-rec</span> env-old var body proc-name)</span><br></pre></td></tr></table></figure>

<p>会得到<code>env</code>的话，那么<code>f</code>一定可以被表示为：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">procedure</span> exp (<span class="name">extend-environment-rec</span> env-old var body proc-name) var)</span><br></pre></td></tr></table></figure>

<p>根据这个想法，我们直接可以写出<code>extend-environment-rec</code>的实现：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> extend-environment-rec</span><br><span class="line">  (<span class="name">λ</span> (<span class="name">env</span> var body proc-name)</span><br><span class="line">    (<span class="name">λ</span>(<span class="name">what</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">equal?</span></span> what proc-name)</span><br><span class="line">          (<span class="name">proc-val</span> (<span class="name">procedure</span> var body</span><br><span class="line">                               (<span class="name">extend-environment-rec</span> env var body proc-name)))</span><br><span class="line">          (<span class="name">apply-environment</span> env what)))))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，我们就直接实现了递归函数。</p>
<h3 id="改变procedure的定义"><a href="#改变procedure的定义" class="headerlink" title="改变procedure的定义"></a>改变procedure的定义</h3><p>我们原来是这样定义<code>procedure</code>的：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> procedure</span><br><span class="line">  (<span class="name">λ</span>(<span class="name">var</span> body env)</span><br><span class="line">    (<span class="name">λ</span>(<span class="name">val</span>)</span><br><span class="line">      (<span class="name">value-of</span> body</span><br><span class="line">                (<span class="name">extend-environment</span> env var val)))))</span><br></pre></td></tr></table></figure>

<p>这里，我们把它的函数名也加进去：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> procedure</span><br><span class="line">  (<span class="name">λ</span>(<span class="name">var</span> body env proc-name)</span><br><span class="line">    (<span class="name">λ</span>(<span class="name">val</span>)</span><br><span class="line">      (<span class="name"><span class="builtin-name">let</span></span> ([<span class="name">env1</span></span><br><span class="line">             (<span class="name">extend-environment</span> env</span><br><span class="line">                                 proc-name</span><br><span class="line">                                 (<span class="name">proc-val</span> (<span class="name">procedure</span> var body env proc-name)))])</span><br><span class="line">      (<span class="name">value-of</span> body</span><br><span class="line">                (<span class="name">extend-environment</span> env1 var val))))))</span><br></pre></td></tr></table></figure>

<p>每当要求值的时候，我们临时构造一个相同的函数即可。</p>
<h2 id="支持引用的语言"><a href="#支持引用的语言" class="headerlink" title="支持引用的语言"></a>支持引用的语言</h2><p>对于支持引用的语言来说，递归函数的实现就不这么麻烦了。例如说C语言：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x * factor(x - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的factor会被解释成一个函数指针，实际上是一个地址，编译出来会是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">factor:</span><br><span class="line">	...</span><br><span class="line">	call factor(0x...)</span><br><span class="line">	...</span><br></pre></td></tr></table></figure>

<p>通过引用，我们也可以在scheme中以另一种方式实现递归：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">solve3</span> n)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> temp <span class="number">10</span>)</span><br><span class="line">  (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">inner</span> x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">=</span></span> x <span class="number">0</span>)</span><br><span class="line">        <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="builtin-name">*</span></span> x (<span class="name">temp</span> (<span class="name"><span class="builtin-name">-</span></span> x <span class="number">1</span>)))))</span><br><span class="line">  (<span class="name"><span class="builtin-name">set!</span></span> temp inner)</span><br><span class="line">  (<span class="name">inner</span> n))</span><br><span class="line"></span><br><span class="line">(<span class="name">solve3</span> <span class="number">10</span>) <span class="comment">;3628800</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/08/30/2020-08-30-pl6/" data-id="ckg4mhp26001117sbhh1iguoo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/12/2020-09-12-number-theory/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          数论中的几个问题
        
      </div>
    </a>
  
  
    <a href="/2020/08/30/2020-08-30-pl5/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">让我们实现编程语言吧(五) 解释器模型</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>