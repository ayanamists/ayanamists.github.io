<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            谈谈【蹦床】技术
        </div>
        <div class="post-meta">
            2020-06-23
        </div>
    

    <div class="post-md">
        <h2 id="过程式语言中的尾调用"><a class="markdownIt-Anchor" href="#过程式语言中的尾调用"></a> 过程式语言中的尾调用</h2>
<p>在scheme中，尾调用完全是循环的：</p>
<pre class="highlight"><code class="scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> factor
  (<span class="hljs-name"><span class="hljs-builtin-name">lambda</span></span> (n result)
    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;</span></span> n <span class="hljs-number">2</span>)
      result
      (<span class="hljs-name">factor</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> result n)))))
</code></pre>
<p>这段代码和</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span></span>&#123;
  <span class="hljs-keyword">int</span> result = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">2</span>) &#123;
    result = n * result;
    n--;
  &#125;
  <span class="hljs-keyword">return</span> result;
&#125;
</code></pre>
<p>具有完全相同的时间和空间复杂度。这是由于scheme中使用的不是【栈】，而是【继续】(continuation)。如果读者不知道什么是【继续】，可以继续关注我的博客，我会写另外一篇文章来专门解释这个问题。</p>
<p>但在c语言那样的语言中，类似于上面的scheme的代码会产生多余的栈增长：</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rec_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> ret)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> rec_factor(n - <span class="hljs-number">1</span>, ret * n);
	&#125;
&#125;
</code></pre>
<p>这是因为，在调用rec_factor(n - 1, ret * n)时，这个rec_factor(n, ret)的局部变量、参数等等，都是没有用的。换言之，它应该【退出】之后再调用rec_factor()</p>
<h2 id="蹦床技术"><a class="markdownIt-Anchor" href="#蹦床技术"></a> 【蹦床】技术</h2>
<p>为了解决这个问题，编程语言专家们引入了【蹦床】技术。这个技术的核心是【先退出，再调用】，如果你把【退出函数】想象成落下，【调用函数】想象成弹起，那么C语言的尾调用就是【跳跳跳跳跳。。。落落落落落】，而再使用了蹦床技术之后，尾调用就像是【跳落跳落跳落。。。】，自然就像一个【蹦床】一样了。</p>
<p>怎么实现呢？我们再考察一下刚才的函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">rec_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> ret)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;
		<span class="hljs-keyword">return</span> ret;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> rec_factor(n - <span class="hljs-number">1</span>, ret * n);
	&#125;
&#125;
</code></pre>
<p>如果return的不是一个【函数调用】，而是一个【值】，那么，它就会在这里直接返回。而我们可以在外部用这个【值】来继续计算rec_factor(n - 1, ret * n)，或者说，调用rec_factor(n - 1, ret * n)。</p>
<p>我们先改写一下：</p>
<pre class="highlight"><code class="c"><span class="hljs-function">Bounce <span class="hljs-title">rec_factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n, <span class="hljs-keyword">int</span> ret)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;
		<span class="hljs-keyword">return</span> Bounce;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">return</span> Bounce;
	&#125;
&#125;
</code></pre>
<p>可见，这个Bounce需要既能包住一个【值】（也就是C中的值），又能包住一个【调用】。怎么设计呢？如果使用C++的话，我们有lambda()[]{}，std::function之类的匿名函数可以做到【包住调用】这点，但我们这里不用这些东西，而是使用自己定义的数据结构：</p>
<pre class="highlight"><code class="c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bounce</span> &#123;</span>
	<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">Bounce</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*, <span class="hljs-keyword">void</span>*)</span></span>;
	func f;
	<span class="hljs-keyword">void</span>* args;
	<span class="hljs-keyword">void</span>* return_value;
	<span class="hljs-keyword">bool</span> <span class="hljs-built_in">end</span>;
&#125;;
</code></pre>
<p>这里的func类型是为了方便而定义的，第一个参数是【参数的指针】，第二个参数是【返回值的指针】，而它在语法意义上的返回值则是一个Bounce。end用来区分它是一个【函数调用】还是一个【值】。</p>
<p>由于bounce包含了【要调用的函数指针、参数】，它自然可以用来保存调用。我们来看一下改写后的factor函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-function">Bounce <span class="hljs-title">factor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> * n, <span class="hljs-keyword">int</span>* ret)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (*n &lt; <span class="hljs-number">2</span>) &#123;
		Bounce b;
		b.return_value = ret;
		b.<span class="hljs-built_in">end</span> = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> b;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		*ret = (*n) * (*ret);
		*n = (*n) - <span class="hljs-number">1</span>;
		Bounce b;
		b.f = (Bounce::func)factor;
		b.args = n;
		b.return_value = ret;
		b.<span class="hljs-built_in">end</span> = <span class="hljs-literal">false</span>;
		<span class="hljs-keyword">return</span> b;
	&#125;
&#125;
</code></pre>
<p>自然，这样的【函数】是不能直接调用的，因为它返回一个Bounce，我们需要另一个函数来**不断地处理bounce，直至得到一个【被包住的值】，而不是【被包住的调用】为止：</p>
<pre class="highlight"><code class="c"><span class="hljs-function"><span class="hljs-keyword">void</span>* <span class="hljs-title">Tramp</span><span class="hljs-params">(Bounce b)</span> </span>&#123;
	<span class="hljs-keyword">if</span> (b.<span class="hljs-built_in">end</span> == <span class="hljs-literal">true</span>)
	&#123;
		<span class="hljs-keyword">return</span> b.return_value;
	&#125;
	<span class="hljs-keyword">else</span> &#123;
		<span class="hljs-keyword">auto</span> hot = b;
		<span class="hljs-keyword">while</span> (!hot.<span class="hljs-built_in">end</span>)
		&#123;
			hot = hot.f(hot.args, hot.return_value);
		&#125;
		<span class="hljs-keyword">return</span> b.return_value;
	&#125;
&#125;
</code></pre>
<p>在外部，我们会这样来调用它：</p>
<pre class="highlight"><code class="c++">
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>&#123;
	Bounce b;
	b.f = (Bounce::func)factor;
	b.args = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);
	*(<span class="hljs-keyword">int</span>*)b.args = <span class="hljs-number">100000</span>;
	b.return_value = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);
	*(<span class="hljs-keyword">int</span>*)(b.return_value) = <span class="hljs-number">1</span>;
	b.<span class="hljs-built_in">end</span> = <span class="hljs-literal">false</span>;
	Tramp(b);
<span class="hljs-comment">// 	rec_factor(100000, 1);</span>
	<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; *(<span class="hljs-keyword">int</span>*)b.return_value &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;
&#125;

</code></pre>
<p>下面那行被注释掉的代码，会爆栈；而我们用【蹦床】技术写的等效代码，则不会爆栈。这样一来，对于所有的尾调用，只要调用的函数满足func类型的函数声明，都可以这样调用而不会消耗额外的栈空间。</p>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>