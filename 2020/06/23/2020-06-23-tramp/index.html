<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            谈谈【蹦床】技术
        </div>
        <div class="post-meta">
            2020-06-23
        </div>
    

    <div class="post-md">
        <h2 id="过程式语言中的尾调用"><a class="markdownIt-Anchor" href="#过程式语言中的尾调用"></a> 过程式语言中的尾调用</h2>
<p>在scheme中，尾调用完全是循环的：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-built_in">define</span></span> factor<br>  (<span class="hljs-name"><span class="hljs-built_in">lambda</span></span> (n result)<br>    (<span class="hljs-name"><span class="hljs-built_in">if</span></span> (<span class="hljs-name"><span class="hljs-built_in">&lt;</span></span> n <span class="hljs-number">2</span>)<br>      result<br>      (<span class="hljs-name">factor</span> (<span class="hljs-name"><span class="hljs-built_in">-</span></span> n <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-built_in">*</span></span> result n)))))<br></code></pre></td></tr></table></figure>
<p>这段代码和</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span>&#123;<br>  <span class="hljs-type">int</span> result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span>(n &gt;= <span class="hljs-number">2</span>) &#123;<br>    result = n * result;<br>    n--;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>具有完全相同的时间和空间复杂度。这是由于scheme中使用的不是【栈】，而是【继续】(continuation)。如果读者不知道什么是【继续】，可以继续关注我的博客，我会写另外一篇文章来专门解释这个问题。</p>
<p>但在c语言那样的语言中，类似于上面的scheme的代码会产生多余的栈增长：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rec_factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> ret)</span> &#123;<br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> rec_factor(n - <span class="hljs-number">1</span>, ret * n);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这是因为，在调用rec_factor(n - 1, ret * n)时，这个rec_factor(n, ret)的局部变量、参数等等，都是没有用的。换言之，它应该【退出】之后再调用rec_factor()</p>
<h2 id="蹦床技术"><a class="markdownIt-Anchor" href="#蹦床技术"></a> 【蹦床】技术</h2>
<p>为了解决这个问题，编程语言专家们引入了【蹦床】技术。这个技术的核心是【先退出，再调用】，如果你把【退出函数】想象成落下，【调用函数】想象成弹起，那么C语言的尾调用就是【跳跳跳跳跳。。。落落落落落】，而再使用了蹦床技术之后，尾调用就像是【跳落跳落跳落。。。】，自然就像一个【蹦床】一样了。</p>
<p>怎么实现呢？我们再考察一下刚才的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">rec_factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> ret)</span> &#123;<br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span> ret;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> rec_factor(n - <span class="hljs-number">1</span>, ret * n);<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果return的不是一个【函数调用】，而是一个【值】，那么，它就会在这里直接返回。而我们可以在外部用这个【值】来继续计算rec_factor(n - 1, ret * n)，或者说，调用rec_factor(n - 1, ret * n)。</p>
<p>我们先改写一下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Bounce <span class="hljs-title function_">rec_factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> ret)</span> &#123;<br>	<span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) &#123;<br>		<span class="hljs-keyword">return</span> Bounce;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">return</span> Bounce;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可见，这个Bounce需要既能包住一个【值】（也就是C中的值），又能包住一个【调用】。怎么设计呢？如果使用C++的话，我们有lambda()[]{}，std::function之类的匿名函数可以做到【包住调用】这点，但我们这里不用这些东西，而是使用自己定义的数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Bounce</span> &#123;</span><br>	<span class="hljs-keyword">typedef</span> <span class="hljs-title function_">Bounce</span> <span class="hljs-params">(*func)</span><span class="hljs-params">(<span class="hljs-type">void</span>*, <span class="hljs-type">void</span>*)</span>;<br>	func f;<br>	<span class="hljs-type">void</span>* args;<br>	<span class="hljs-type">void</span>* return_value;<br>	<span class="hljs-type">bool</span> end;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>这里的func类型是为了方便而定义的，第一个参数是【参数的指针】，第二个参数是【返回值的指针】，而它在语法意义上的返回值则是一个Bounce。end用来区分它是一个【函数调用】还是一个【值】。</p>
<p>由于bounce包含了【要调用的函数指针、参数】，它自然可以用来保存调用。我们来看一下改写后的factor函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c">Bounce <span class="hljs-title function_">factor</span><span class="hljs-params">(<span class="hljs-type">int</span> * n, <span class="hljs-type">int</span>* ret)</span> &#123;<br>	<span class="hljs-keyword">if</span> (*n &lt; <span class="hljs-number">2</span>) &#123;<br>		Bounce b;<br>		b.return_value = ret;<br>		b.end = <span class="hljs-literal">true</span>;<br>		<span class="hljs-keyword">return</span> b;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		*ret = (*n) * (*ret);<br>		*n = (*n) - <span class="hljs-number">1</span>;<br>		Bounce b;<br>		b.f = (Bounce::func)factor;<br>		b.args = n;<br>		b.return_value = ret;<br>		b.end = <span class="hljs-literal">false</span>;<br>		<span class="hljs-keyword">return</span> b;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>自然，这样的【函数】是不能直接调用的，因为它返回一个Bounce，我们需要另一个函数来**不断地处理bounce，直至得到一个【被包住的值】，而不是【被包住的调用】为止：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span>* <span class="hljs-title function_">Tramp</span><span class="hljs-params">(Bounce b)</span> &#123;<br>	<span class="hljs-keyword">if</span> (b.end == <span class="hljs-literal">true</span>)<br>	&#123;<br>		<span class="hljs-keyword">return</span> b.return_value;<br>	&#125;<br>	<span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-keyword">auto</span> hot = b;<br>		<span class="hljs-keyword">while</span> (!hot.end)<br>		&#123;<br>			hot = hot.f(hot.args, hot.return_value);<br>		&#125;<br>		<span class="hljs-keyword">return</span> b.return_value;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外部，我们会这样来调用它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>	Bounce b;<br>	b.f = (Bounce::func)factor;<br>	b.args = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>	*(<span class="hljs-type">int</span>*)b.args = <span class="hljs-number">100000</span>;<br>	b.return_value = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">4</span>);<br>	*(<span class="hljs-type">int</span>*)(b.return_value) = <span class="hljs-number">1</span>;<br>	b.end = <span class="hljs-literal">false</span>;<br>	<span class="hljs-built_in">Tramp</span>(b);<br><span class="hljs-comment">// 	rec_factor(100000, 1);</span><br>	std::cout &lt;&lt; *(<span class="hljs-type">int</span>*)b.return_value &lt;&lt; std::endl;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>下面那行被注释掉的代码，会爆栈；而我们用【蹦床】技术写的等效代码，则不会爆栈。这样一来，对于所有的尾调用，只要调用的函数满足func类型的函数声明，都可以这样调用而不会消耗额外的栈空间。</p>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">

            </div>
        </div>
    </body>
</html>