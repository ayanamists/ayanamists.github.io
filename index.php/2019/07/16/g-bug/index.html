<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>消失的__free_hook=NULL:一个G++编译优化的BUG | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表： chxAlloc">
<meta property="og:type" content="article">
<meta property="og:title" content="消失的__free_hook&#x3D;NULL:一个G++编译优化的BUG">
<meta property="og:url" content="http://example.com/index.php/2019/07/16/g-bug/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表： chxAlloc">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-07-16T12:48:39.000Z">
<meta property="article:modified_time" content="2020-10-11T04:43:47.184Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019-07-16-g-bug" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/index.php/2019/07/16/g-bug/" class="article-date">
  <time datetime="2019-07-16T12:48:39.000Z" itemprop="datePublished">2019-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-C/">C/C++</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      消失的__free_hook=NULL:一个G++编译优化的BUG
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">chxAlloc::chxAlloc()
{
    //std::cout &lt;&lt; "invoke chxAlloc\n";
    void *begin =
        mmap(NULL, sizeof(allocChunk) * INIT_NUMBER + 0X10,
             PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if ((long long)begin == -1)
    {
        std::cout &lt;&lt; "error occur in mmap\n";
        exit(-1);
    }

    for (int i = 0; i &lt; INIT_NUMBER; ++i)
    {
        allocChunk *temp = (allocChunk *)begin;
        temp->nextPtr = fast_TARGET;
        fast_TARGET = temp;
        temp->sign = -TARGET;
        begin = ((char *)begin + sizeof(allocChunk));
    }
}</pre>

<p>对GLIBC有了解的读者应该知道，这样其实是手工建立了一个大小为0x1010的fast_chunk链表。由于我不太了解全局对象的构造和其他初始化阶段的顺序，为避免出现问题，我在第一次调用deque的函数时才将malloc和free钩住。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (__builtin_expect(count == 0, 0))
    {
        __malloc_hook = chx.chenxiAlloc;
        __free_hook = chx.chenxiFree;
        count++;
    }</pre>

<p>在这样钩住之后，调用malloc就会调用到chenxiAlloc，调用free就会调用到chenxiFree. 如果申请或释放的大小不是0x1010（这里我们将自己的chunk_size设为-0x1010，在free的时候就可以检测到），我们就调用GLIBC的malloc和free:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__malloc_hook = NULL;
void *ret = malloc(size);
if (ret == NULL)
{
    std::cout &lt;&lt; "error occur in glibc malloc\n";
    exit(0);
}
__malloc_hook = &chenxiAlloc;
return ret;</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (*((long long *)ptr - 1) &lt; 0)
 {
    *((void **)ptr - 2) = fast_TARGET;
    fast_TARGET = (allocChunk&lt;TARGET> *)((void **)ptr - 2);
}
else
{
    __free_hook = NULL;
    free(ptr);
    __free_hook = &chenxiFree;
}</pre>

<p>有趣的是，在使用O2编译优化的情况下，分配一个大小不为0x1010的块会出现意想不到的结果：free和chenxiFree反复相互调用，最终导致栈地址空间被用尽，产生segment fault.</p>
<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Program received signal SIGSEGV, Segmentation fault.
0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710) at malloc.c:3094
3094    malloc.c: No such file or directory.
(gdb) bt
#0  0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#2  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#3  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#4  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#5  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#6  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#7  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#8  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#9  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#10 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#11 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#12 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#13 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#14 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094</pre>

<p>更有趣的是，如果不开启编译优化，上述行为就不会出现错误。基于此，笔者想到了GCC内嵌汇编中的__volatile__关键字。</p>
<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__asm__ __volatile__ (...);</pre>

<p>这里的__volatile__表示后面的语句不作优化（可以理解为强制按指令顺序执行），但这个关键字并不是标准的C关键字，而是类似于__builtin__expected()的仅GCC实现的关键字。利用这个关键字是否可以实现不去优化呢？</p>
<p>遗憾的是，无论是查找中文还是英文资料，这个关键字都只用这一种用法。但令笔者眼前一亮的是，C/C++语言中有一个类似的标准关键字：volatile.</p>
<p>volatile是一个加在变量的声明前的关键字，类似于这样使用：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int volatile a = 0;</pre>

<p>这表示变量a是“易变的”，也就是说，每次访问a时，必须到内存中访问，不可以用寄存器中的值。它多用于多线程环境中。为什么必须访问内存呢？假设a可以被T1和T2两个线程访问，T1首先将a的值写入EAX寄存器，但在T1使用a之前，T2更新了a的值，那么现在T1现在要使用a，应该使用内存中的更新后的值，而非EAX中的值。</p>
<p>笔者立刻修改了__malloc_hook和\__free_hook的声明，都加入了volatile：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">typedef void *(*mallocType)(unsigned);
extern volatile mallocType __malloc_hook;

typedef void (*freeType)(void *);
extern volatile freeType __free_hook;</pre>

<p>问题果然解决了。可是为什么不加volatile会产生那么滑稽的错误呢？笔者进行了反汇编分析：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) f 1
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
   0x000055555555df80 &lt;+0>:    cmpq   $0x0,-0x8(%rdi)
   0x000055555555df85 &lt;+5>:    js     0x55555555dfa8 &lt;_ZN8chxAlloc10chenxiFreeEPv+40>
   0x000055555555df87 &lt;+7>:    sub    $0x8,%rsp
   0x000055555555df8b &lt;+11>:    callq  0x55555555b450 &lt;free@plt>
=> 0x000055555555df90 &lt;+16>:    lea    -0x17(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv>
   0x000055555555df97 &lt;+23>:    mov    %rax,0x28e5f2(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5>
   0x000055555555df9e &lt;+30>:    add    $0x8,%rsp
   0x000055555555dfa2 &lt;+34>:    retq   
   0x000055555555dfa3 &lt;+35>:    nopl   0x0(%rax,%rax,1)
   0x000055555555dfa8 &lt;+40>:    mov    0x28e871(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE>
   0x000055555555dfaf &lt;+47>:    sub    $0x10,%rdi
   0x000055555555dfb3 &lt;+51>:    mov    %rax,(%rdi)
   0x000055555555dfb6 &lt;+54>:    mov    %rdi,0x28e863(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE>
   0x000055555555dfbd &lt;+61>:    retq   
End of assembler dump.
</pre>

<p>注意那句callq的上方，反汇编给出的语句是sub $8, %rsp, 也就是将rsp-8h，这语句的作用肯定不是将__free_hook置空，它其实应该在开头执行，是函数常有的抬高栈顶的操作。只是编译器检测出，另外的一条分支不需要抬高栈顶。所以只需要在这个分支做（这是一种编译优化策略，读者可自行查找相关资料）。那么我的那句\__free_hook = NULL去了哪里呢？正是因为这里没有置空，所以才导致了free调用chenxiFree，chenxiFree调用free的死锁。保险起见，我们再用IDA反编译一下：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">else
  {
    free((void *)this);
    result = chxAlloc::chenxiFree;
    _free_hook = (__int64)chxAlloc::chenxiFree;
  }</pre>

<p>果然如此，将__free_hook置NULL的操作竟然被编译器无视了。为什么会这样？笔者对编译原理了解很肤浅，难以解答这个问题。但是，这个问题确实可以通过加入volatile关键字来解决。很自然地，我们用加入后的反汇编代码做个对比：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
=> 0x000055555555df80 &lt;+0>:    hlt    
   0x000055555555df81 &lt;+1>:    cmpq   $0x0,-0x8(%rdi)
   0x000055555555df86 &lt;+6>:    js     0x55555555dfb0 &lt;_ZN8chxAlloc10chenxiFreeEPv+48>
   0x000055555555df88 &lt;+8>:    sub    $0x8,%rsp
   0x000055555555df8c &lt;+12>:    movq   $0x0,0x28e5f9(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5>
   0x000055555555df97 &lt;+23>:    callq  0x55555555b450 &lt;free@plt>
   0x000055555555df9c &lt;+28>:    lea    -0x23(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv>
   0x000055555555dfa3 &lt;+35>:    mov    %rax,0x28e5e6(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5>
   0x000055555555dfaa &lt;+42>:    add    $0x8,%rsp
   0x000055555555dfae &lt;+46>:    retq   
   0x000055555555dfaf &lt;+47>:    nop
   0x000055555555dfb0 &lt;+48>:    mov    0x28e869(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE>
   0x000055555555dfb7 &lt;+55>:    sub    $0x10,%rdi
   0x000055555555dfbb &lt;+59>:    mov    %rax,(%rdi)
   0x000055555555dfbe &lt;+62>:    mov    %rdi,0x28e85b(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE>
   0x000055555555dfc5 &lt;+69>:    retq   
End of assembler dump.
</pre>

<p>注意eip+12的位置，这一句话执行了__free_hook = NULL.</p>
<p>最后，用贝木泥舟式的话来说，从这次的事件中我应该得到的教训是：编译优化会产生BUG.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/index.php/2019/07/16/g-bug/" data-id="ckg4mhp15000017sb8c3i6pwd" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/index.php/2019/07/17/maxituan/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          魔偶马戏团：不幸的动画与伟大的原作
        
      </div>
    </a>
  
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>