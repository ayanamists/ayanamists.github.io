<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            c++模板与参数多态的根本区别
        </div>
        <div class="post-meta">
            2021-09-14
        </div>
    

    <div class="post-md">
        <h2 id="c模板与参数多态"><a class="markdownIt-Anchor" href="#c模板与参数多态"></a> c++模板与参数多态</h2>
<p>模板(template)是一种c++语言特性，类似于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">id</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的<code>T</code>可以是任意类型。很多人都注意到了这与参数多态(parametric polymorphism)的相似性，更有甚者直接把模板机制看作是一种参数多态。比如这份<a target="_blank" rel="noopener" href="https://www.cs.bham.ac.uk/~hxt/2015/c-plus-plus/templates-slides.pdf">ppt</a>和这个<a target="_blank" rel="noopener" href="https://catonmat.net/cpp-polymorphism">网页</a>。</p>
<p>然而这篇博客中，我将会说明，<strong>无论c++模板到底是不是一个好的语言特性，它都和参数多态有根本性的区别</strong>。</p>
<h2 id="到底什么是参数多态"><a class="markdownIt-Anchor" href="#到底什么是参数多态"></a> 到底什么是参数多态</h2>
<p>参数多态的历史要追溯一份讲义(<a target="_blank" rel="noopener" href="https://link.springer.com/article/10.1023%2FA%3A1010000313106">Fundamental Concepts in Programming Languages</a>)，讲义虽然主要描述的是CPL语言，但是实际上这一段应该描述的是LISP的MAP函数：</p>
<blockquote>
<p>Parametric polymorphism is more regular and may be illustrated by an example. Suppose f is a function whose argument is of type α and whose results is of β (so that the type of f might be written α ⇒ β), and that L is a list whose elements are all of type α (so that the type of L is α list). We can imagine a function, say Map, which applies f in turn to each member of L and makes a list of the results. Thus Map[f,L] will produce a β list. We would like Map to work on all types of list provided f was a suitable function, so that Map would have to be polymorphic. However its polymorphism is of a particularly simple parametric type which could be written</p>
</blockquote>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi>α</mi><mo>→</mo><mi>β</mi><mo separator="true">,</mo><mi>α</mi><mtext> </mtext><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi><mo stretchy="false">)</mo><mo>→</mo><mi>β</mi><mtext> </mtext><mi>l</mi><mi>i</mi><mi>s</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">(α → β , α\ list) → β \ list
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>虽然有了构想，但是直到1970年代的Jean-Yves Girard的二阶直觉主义命题逻辑（second order propositional logic，注意不要和二阶逻辑⁽second order logic⁾搞混）和John C. Reynolds的系统F（System F），这种特性才得到了理论阐释。最终在1975年的ML语言中得到实现。</p>
<p>在ML类语言中，一个函数的类型中可以含有类型变量，例如如下的<code>id</code>函数：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><code class="hljs ocaml"><span class="hljs-keyword">let</span> id (x:<span class="hljs-symbol">&#x27;a</span>) = x<br></code></pre></td></tr></table></figure>
<p><code>id</code>函数的类型是<code>'a -&gt; 'a</code>，其中<code>'a</code>就是一个类型变量，它可以与<strong>任意</strong>类型相匹配，所以得到</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><code class="hljs ocaml">id <span class="hljs-number">1</span><br>id <span class="hljs-string">&quot;ssdfs&quot;</span><br>id <span class="hljs-number">1.23</span><br></code></pre></td></tr></table></figure>
<p>都是合法的表达式。ML类语言的类型系统可以看作是对System F进行限制和扩展后的系统。System F可以看作对λ表达式的扩展，在system F中，λ表达式的每个绑定变量都必须给定一个类型，而这个类型则是通过<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">Λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span>（大写的λ）引入的。</p>
<p>具体来说，最基本的λ表达式<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi><mi>x</mi><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">λx.x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span><span class="mord mathdefault">x</span><span class="mord">.</span><span class="mord mathdefault">x</span></span></span></span>在System F中应该写作：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Λ</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>x</mi></mrow><annotation encoding="application/x-tex">Λt.λ (x:t).x
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Λ</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">λ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault">x</span></span></span></span></span></p>
<p>而这个表达式的类型是</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>t</mi><mo>→</mo><mi>t</mi></mrow><annotation encoding="application/x-tex">∀t.t → t
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span></span></p>
<p>这个大<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">Λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span>引入的类型变量在使用时需要得到显式apply（就像对小<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>的apply一样）。在System F中，类似于λ表达式，没有除了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>λ</mi></mrow><annotation encoding="application/x-tex">λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">λ</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">Λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∀</mi></mrow><annotation encoding="application/x-tex">∀</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">∀</span></span></span></span>以外的东西，如果给它暂时加入整数类型（例如<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mo>:</mo><mtext>Int</mtext></mrow><annotation encoding="application/x-tex">1: \text{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Int</span></span></span></span></span>），那么就可以给出这样的求值实例:</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mtable rowspacing="0.24999999999999992em" columnalign="right left" columnspacing="0em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mi>t</mi><mi mathvariant="normal">.</mi><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>t</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext>Int</mtext><mo stretchy="false">)</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≡</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mtext>Int</mtext><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="true"><mrow><mrow></mrow><mo>≡</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{aligned}
((Λ t. λ (x:t). x) \text{Int})1 &amp; ≡ \\
(λ (x:\text{Int}). x) 1 &amp; ≡ 1
\end{aligned}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.0000000000000004em;vertical-align:-1.2500000000000002em;"></span><span class="mord"><span class="mtable"><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mopen">(</span><span class="mord">Λ</span><span class="mord mathdefault">t</span><span class="mord">.</span><span class="mord mathdefault">λ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord text"><span class="mord">Int</span></span><span class="mclose">)</span><span class="mord">1</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord text"><span class="mord">Int</span></span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7500000000000002em;"><span style="top:-3.91em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span></span></span><span style="top:-2.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≡</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2500000000000002em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>由于Hindey-Milner类型推理算法的存在，ML类语言中无须手动给出这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mtext>Int</mtext></mrow><annotation encoding="application/x-tex">\text{Int}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord">Int</span></span></span></span></span>，函数的类型也会自动推导为带有全称量词的形式。虽然为了进行推理，某些在System F中合法的式子不能在ML中被构造，但搞清楚System F的类型规则对接下来的讨论是大有裨益的。</p>
<p>System F的类型规则分为四个规则：</p>
<ol>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>t</mi><mi mathvariant="normal">₁</mi><mo stretchy="false">)</mo><mo>⊢</mo><mi>y</mi><mo>:</mo><mi>t</mi><mi mathvariant="normal">₂</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>λ</mi><mo stretchy="false">(</mo><mi>x</mi><mo>:</mo><mi>t</mi><mi mathvariant="normal">₁</mi><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>t</mi><mi mathvariant="normal">₁</mi><mo>→</mo><mi>t</mi><mi mathvariant="normal">₂</mi></mrow></mfrac><mrow></mrow></msub></mrow><annotation encoding="application/x-tex">{\frac{Γ , (x:t₁) ⊢ y:t₂}{Γ ⊢ (λ(x:t₁).y):t₁ → t₂}}_{}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.4127em;vertical-align:-0.9857em;"></span><span class="mord"><span class="mord"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">λ</span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₂</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₂</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:-0.9857em;"><span style="top:-1.0143em;margin-right:0.05em;"><span class="pstrut" style="height:2em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9857em;"><span></span></span></span></span></span></span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>A</mi><mo>:</mo><mrow><mi mathvariant="bold">t</mi><mi mathvariant="bold">y</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">e</mi></mrow><mo>⊢</mo><mi>x</mi><mo>:</mo><mi>t</mi><mi mathvariant="normal">₁</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mi>A</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mo>:</mo><mi mathvariant="normal">∀</mi><mi>A</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi mathvariant="normal">₁</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{Γ , A:\bold{type} ⊢ x:t₁ }{ Γ ⊢ (Λ A.x): ∀ A. t₁}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.3074399999999997em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">Λ</span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">∀</span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord">₁</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathbf">t</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mord mathbf">p</span><span class="mord mathbf">e</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mo stretchy="false">(</mo><mi>t</mi><mi mathvariant="normal">₁</mi><mo>→</mo><mi>t</mi><mi mathvariant="normal">₂</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi>y</mi><mo>:</mo><mi>t</mi><mi mathvariant="normal">₁</mi></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mi>y</mi><mo stretchy="false">)</mo><mo>:</mo><mi>t</mi><mi mathvariant="normal">₂</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{Γ ⊢ x:(t₁ → t₂), y:t₁}{Γ ⊢ (x\ y): t₂}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₂</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord">₁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₂</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
<li>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi>x</mi><mo>:</mo><mo stretchy="false">(</mo><mi mathvariant="normal">∀</mi><mi>A</mi><mi mathvariant="normal">.</mi><mi>t</mi><mi mathvariant="normal">₁</mi><mo stretchy="false">)</mo><mtext>    </mtext><mo stretchy="false">(</mo><mi>B</mi><mo>:</mo><mrow><mi mathvariant="bold">t</mi><mi mathvariant="bold">y</mi><mi mathvariant="bold">p</mi><mi mathvariant="bold">e</mi></mrow><mo stretchy="false">)</mo></mrow><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mo stretchy="false">(</mo><mi>x</mi><mtext> </mtext><mi>B</mi><mo stretchy="false">)</mo><mo>:</mo><mo stretchy="false">[</mo><mi>B</mi><mi mathvariant="normal">/</mi><mi>A</mi><mo stretchy="false">]</mo><mi>t</mi><mi mathvariant="normal">₁</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{Γ ⊢ x:(∀A.t₁)\  \ \ \ (B:\bold{type})}{ Γ ⊢ (x\ B):[B/A]t₁}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace"> </span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mord">/</span><span class="mord mathdefault">A</span><span class="mclose">]</span><span class="mord mathdefault">t</span><span class="mord">₁</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mopen">(</span><span class="mord">∀</span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">t</span><span class="mord">₁</span><span class="mclose">)</span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mspace"> </span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord"><span class="mord mathbf">t</span><span class="mord mathbf" style="margin-right:0.01597em;">y</span><span class="mord mathbf">p</span><span class="mord mathbf">e</span></span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
</li>
</ol>
<p>从规则2.中可以看到，这里的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>是<strong>任意</strong>的类型，引入这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Λ</mi></mrow><annotation encoding="application/x-tex">Λ</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Λ</span></span></span></span>的条件是无论<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">A</span></span></span></span>到底是什么类型，它都可以推出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi><mi mathvariant="normal">₁</mi></mrow><annotation encoding="application/x-tex">t₁</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord">₁</span></span></span></span>类型。这样一来，在规则4.中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span>也是一个<strong>任意</strong>的类型。可以不加证明地得到：</p>
<p><strong>命题1.</strong> 如果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mi>A</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(ΛA.x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">Λ</span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mclose">)</span></span></span></span>是一个系统F中的封闭项，那么对于任意的类型<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>t</mi></mrow><annotation encoding="application/x-tex">t</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span></span></span></span>，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">(</mo><mo stretchy="false">(</mo><mi mathvariant="normal">Λ</mi><mi>A</mi><mi mathvariant="normal">.</mi><mi>x</mi><mo stretchy="false">)</mo><mtext> </mtext><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">((ΛA.x)\ t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mopen">(</span><span class="mord">Λ</span><span class="mord mathdefault">A</span><span class="mord">.</span><span class="mord mathdefault">x</span><span class="mclose">)</span><span class="mspace"> </span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>是一个系统F中的封闭项。</p>
<p>命题1.是任何声称自己实现了参数多态的系统所必须满足的命题。在ML类语言中，它表现为，一个类型为<code>'a -&gt; b</code>（这里的<code>b</code>没有加引号，表示任何可能的类型，比如<code>'a</code>，这样一来就是<code>'a -&gt; 'a</code>）的函数<code>f</code>，对于任何类型为<code>t</code>的合法ML表达式<code>x</code>，<code>f x</code>的类型都是<code>[t/'a]b</code>.</p>
<p>例如之前的<code>id</code>函数，<code>id 10</code>的类型就是<code>[int/'a]'a</code>，即<code>int</code>.</p>
<p>事实上，参数多态满足更强的条件–parametricity，鉴于比较复杂，这里暂不解释其含义。</p>
<h2 id="c模板满足命题1吗"><a class="markdownIt-Anchor" href="#c模板满足命题1吗"></a> C++模板满足命题1.吗？</h2>
<p>答案是很显然的：<strong>不满足</strong>。这也就是为什么C++模板不是参数多态的一个原因。</p>
<p>例如说，<code>id</code>函数可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function">T <span class="hljs-title">id</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果之前没有写过，你可能会惊讶地发现，这竟然是<strong>不会报错</strong>的！事实上，无论怎么写，它都不会报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">id</span><span class="hljs-params">(T x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>它真正报错的位置，是在对<code>id</code>函数进行使用的时候：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> x = <span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;sdfsdf&quot;</span>);<br><br>------------------------<br>.\test.cpp:<span class="hljs-number">5</span>:<span class="hljs-number">10</span>: error: cannot initialize <span class="hljs-keyword">return</span> object of type <span class="hljs-string">&#x27;const char *&#x27;</span><br>      with an rvalue of type <span class="hljs-string">&#x27;int&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>         ^~<br>.\test.cpp:<span class="hljs-number">9</span>:<span class="hljs-number">14</span>: note: in instantiation of function <span class="hljs-keyword">template</span> specialization       <br>      <span class="hljs-string">&#x27;id&lt;const char *&gt;&#x27;</span> requested here<br>    <span class="hljs-keyword">auto</span> y = <span class="hljs-built_in">id</span>(<span class="hljs-string">&quot;s&quot;</span>);<br>             ^<br><span class="hljs-number">1</span> error generated.<br></code></pre></td></tr></table></figure>
<p>这诉说了一个无情的真相：C++编译器不会对模板函数进行类型检查，只会在<strong>特化</strong>的时候进行类型检查。而这使得命题1.无法成立，因为我们根本没有保证在<code>T</code>是一个类型，<code>x</code>是<code>T</code>类型的情况下，可以推出<code>id</code>函数体（也就是<code>return x</code>）的类型是<code>T</code>.</p>
<p>相反，ocaml会无视泛型参数：</p>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><code class="hljs ocaml"># <span class="hljs-keyword">let</span> id (x: <span class="hljs-symbol">&#x27;a</span>) : <span class="hljs-built_in">int</span> = x ;;<br><span class="hljs-keyword">val</span> id : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = &lt;<span class="hljs-keyword">fun</span>&gt;<br></code></pre></td></tr></table></figure>
<figure class="highlight ocaml"><table><tr><td class="code"><pre><code class="hljs ocaml"># <span class="hljs-keyword">let</span> id (x: <span class="hljs-symbol">&#x27;a</span>) : <span class="hljs-symbol">&#x27;a</span> = <span class="hljs-number">10</span> ;;<br><span class="hljs-keyword">val</span> id : <span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = &lt;<span class="hljs-keyword">fun</span>&gt;<br></code></pre></td></tr></table></figure>
<p>Haskell会报错：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; :&#123;<br><span class="hljs-type">Prelude</span>| id :: a -&gt; a<br><span class="hljs-type">Prelude</span>| id x = <span class="hljs-number">10</span><br><span class="hljs-type">Prelude</span>| :&#125;<br><br>&lt;interactive&gt;:<span class="hljs-number">6</span>:<span class="hljs-number">8</span>: error:<br>    • <span class="hljs-type">No</span> <span class="hljs-keyword">instance</span> for (<span class="hljs-type">Num</span> a) arising from the literal ‘<span class="hljs-number">10</span>’<br>      <span class="hljs-type">Possible</span> fix:<br>        add (<span class="hljs-type">Num</span> a) to the context <span class="hljs-keyword">of</span><br>          the <span class="hljs-class"><span class="hljs-keyword">type</span> signature for:</span><br>            id :: <span class="hljs-keyword">forall</span> a. a -&gt; a<br>    • <span class="hljs-type">In</span> the expression: <span class="hljs-number">10</span><br>      <span class="hljs-type">In</span> an equation for ‘id’: id x = <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-type">Prelude</span>&gt; :&#123;<br><span class="hljs-type">Prelude</span>| id :: a -&gt; <span class="hljs-type">Int</span><br><span class="hljs-type">Prelude</span>| id x = x<br><span class="hljs-type">Prelude</span>| :&#125;<br><br>&lt;interactive&gt;:<span class="hljs-number">12</span>:<span class="hljs-number">8</span>: error:<br>    • <span class="hljs-type">Couldn&#x27;t</span> match expected <span class="hljs-class"><span class="hljs-keyword">type</span> ‘<span class="hljs-type">Int</span>’ with actual <span class="hljs-keyword">type</span> ‘a’</span><br>      ‘a’ is a rigid <span class="hljs-class"><span class="hljs-keyword">type</span> variable bound by</span><br>        the <span class="hljs-class"><span class="hljs-keyword">type</span> signature for:</span><br>          id :: <span class="hljs-keyword">forall</span> a. a -&gt; <span class="hljs-type">Int</span><br>        at &lt;interactive&gt;:<span class="hljs-number">11</span>:<span class="hljs-number">1</span>-<span class="hljs-number">14</span><br>    • <span class="hljs-type">In</span> the expression: x<br>      <span class="hljs-type">In</span> an equation for ‘id’: id x = x<br>    • <span class="hljs-type">Relevant</span> bindings include<br>        x :: a (bound at &lt;interactive&gt;:<span class="hljs-number">12</span>:<span class="hljs-number">4</span>)<br>        id :: a -&gt; <span class="hljs-type">Int</span> (bound at &lt;interactive&gt;:<span class="hljs-number">12</span>:<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<p>可见，c++并不是参数多态，它的模板系统和ML类语言中的泛型系统完全不在一个层次上。</p>
<h2 id="类型类影响问题吗"><a class="markdownIt-Anchor" href="#类型类影响问题吗"></a> 类型类影响问题吗？</h2>
<p>有人可能会说了，Haskell的类型类不是也会出现“在使用的时候才报错”这一现象吗？比如说</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">max</span> :: <span class="hljs-type">Ord</span> p =&gt; p -&gt; p -&gt; p<br><span class="hljs-title">max</span> x y = <span class="hljs-keyword">if</span> y &gt; x <span class="hljs-keyword">then</span> y <span class="hljs-keyword">else</span> x<br><br><span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-type">X</span> = <span class="hljs-type">I</span> | <span class="hljs-type">J</span></span><br><br><span class="hljs-title">max</span> <span class="hljs-type">I</span> <span class="hljs-type">J</span> <span class="hljs-comment">-- 这里报错</span><br><span class="hljs-comment">-- error:</span><br><span class="hljs-comment">--    • No instance for (Ord X) arising from a use of ‘max’</span><br><span class="hljs-comment">--    • In the expression: max I J</span><br><span class="hljs-comment">--      In an equation for ‘it’: it = max I J</span><br></code></pre></td></tr></table></figure>
<p>这个错误简单来说，就是自定义类型<code>X</code>没有实现<code>Ord</code>类型类，而<code>max</code>的<strong>类型签名</strong>中需要类型类<code>Ord</code>，所以报错。这和c++模板仍然很不一样。根本性的区别是，在对<code>max I J</code>进行类型检查的时候，只需要<code>max :: Ord p =&gt; p -&gt; p -&gt; p</code>这一个信息就够了，不需要知道<code>max</code>的函数体是什么，更不需要“特化”这个函数，这仍是在类型系统中的推导。</p>
<h2 id="真假泛型性能更好"><a class="markdownIt-Anchor" href="#真假泛型性能更好"></a> 真假泛型？性能更好？</h2>
<p>虽然我很不喜欢java语言，但是java语言的泛型系统（在一般情况下）满足命题1.，它是真正的参数多态。这是因为java泛型的前身–Generic Java（GJ）是由Philip Wadler等真正的编程语言专家设计的。</p>
<p><img src="https://homepages.inf.ed.ac.uk/wadler/gj/gj-front-full.jpg" alt="GJ作者的合照" /></p>
<p>有人说Java泛型采用了类型擦除，是“假泛型”，这显然是被c++模板的设计影响了。事实上显然参数多态对应的参数类型更有资格把自己叫做“泛型”。c++才是“假泛型”的例子。</p>
<p>c++模板的设计使得module系统变成了一个困难的问题，到了2021年，99.9%的c++程序仍然在使用上古时代的头文件–这一彻头彻尾的垃圾–模拟module系统。</p>
<p>至于性能，所谓的“特化”在编程语言中有两个更强的概念可以替代。</p>
<ul>
<li>部分求值(partial evaluation)</li>
<li>内联(inlining)</li>
</ul>
<p>特化可以看作是一个部分求值的例子。ocaml和Haskell的IR很难打印出来，而F#则可以通过字节码反编译回C#，在<a target="_blank" rel="noopener" href="https://sharplab.io">sharplab</a>中，可以发现</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">let</span> select x y <span class="hljs-operator">=</span> x<br><br><span class="hljs-keyword">let</span> select2 (x<span class="hljs-operator">:</span><span class="hljs-type">int</span>) (y<span class="hljs-operator">:</span><span class="hljs-type">int</span>) <span class="hljs-operator">=</span> select x y<br></code></pre></td></tr></table></figure>
<p>这样的例子会得到：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">using</span> System.Reflection;<br><span class="hljs-keyword">using</span> Microsoft.FSharp.Core;<br><br>[<span class="hljs-meta">assembly: FSharpInterfaceDataVersion(2, 0, 0)</span>]<br>[<span class="hljs-meta">assembly: AssemblyVersion(<span class="hljs-string">&quot;0.0.0.0&quot;</span>)</span>]<br>[<span class="hljs-meta">CompilationMapping(SourceConstructFlags.Module)</span>]<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> @_<br>&#123;<br>    [<span class="hljs-meta">CompilationArgumentCounts(new int[</span>] &#123;<br>        <span class="hljs-number">1</span>,<br>        <span class="hljs-number">1</span><br>    &#125;)]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> a <span class="hljs-title">select</span>&lt;<span class="hljs-title">a</span>, <span class="hljs-title">b</span>&gt;(<span class="hljs-params">a x, b y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br><br>    [<span class="hljs-meta">CompilationArgumentCounts(new int[</span>] &#123;<br>        <span class="hljs-number">1</span>,<br>        <span class="hljs-number">1</span><br>    &#125;)]<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">int</span> <span class="hljs-title">select2</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> x, <span class="hljs-built_in">int</span> y</span>)</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">namespace</span> &lt;<span class="hljs-title">StartupCode</span>$_&gt;<br>&#123;<br>    <span class="hljs-keyword">internal</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> $_<br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>select2</code>难道不是对<code>select</code>的“特化”吗？由此看来，c++模板的“性能更好”也是很难说清楚的问题。</p>
<h2 id="concept-能解决问题吗"><a class="markdownIt-Anchor" href="#concept-能解决问题吗"></a> concept: 能解决问题吗？</h2>
<p>是否是参数多态，似乎只是一个学术问题。不是参数多态，主要导致的是使用一个参数化类型（parametric type，也就是含有∀的类型）时的潜在错误，pararmetricity不成立，某些定理（比如<code>map f . map g = map (f . g)</code>）也不成立。</p>
<p>之前已经提到了，Haskell也有会出错的问题。其他ML家族的语言，如果不算上类似F#的object系统的扩展，则基本没有出错的问题，但是需要传递更多参数。比如<code>List.sortWith</code>的类型就是<code>(('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list)</code>，对于任何<code>'a</code>都不会出错，但是需要显式地传递一个comparer. 所以不是参数多态，可能也不是特别大的问题。</p>
<p>但说到c++，不是参数多态确实带来了一个相当严重的问题，那就是模板系统给出的报错信息常常令人无从下手。</p>
<p>例如这样的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;A&gt; v;<br>    std::<span class="hljs-built_in">sort</span>(v.<span class="hljs-built_in">begin</span>(), v.<span class="hljs-built_in">end</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>会产生200行，19kb的报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">In file included from .\test.cpp:3:<br>C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.28.29910\include\algorithm:7361:32: error: no matching function for call to object of type &#x27;std::less&lt;&gt;&#x27;<br>            if (_DEBUG_LT_PRED(_Pred, _Val, *_First)) &#123; // found new earliest element, move to front<br>...<br></code></pre></td></tr></table></figure>
<p>为了解决这个问题，c++20引入了concept，concept借鉴了类型类和java泛型的设计，可以使得我们能写出类似于之前Haskell的<code>max</code>那样的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;concepts&gt;</span></span><br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt; <span class="hljs-function"><span class="hljs-keyword">requires</span> std::equality_comparable&lt;T&gt;</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">max</span><span class="hljs-params">(T x, T y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果这时写出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">max</span>(<span class="hljs-built_in">A</span>(), <span class="hljs-built_in">A</span>());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>编译器会报错：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">source&gt;: In function &#x27;int main()&#x27;:<br>&lt;source&gt;:17:8: error: no matching function for call to &#x27;max(A, A)&#x27;<br>   17 |     max(A(), A());<br>      |     ~~~^~~~~~~~~~<br>&lt;source&gt;:6:6: note: candidate: &#x27;template&lt;class T&gt;  requires  equality_comparable&lt;T&gt; bool max(T, T)&#x27;<br>    6 | bool max(T x, T y) &#123;<br>      |      ^~~<br>&lt;source&gt;:6:6: note:   template argument deduction/substitution failed:<br>&lt;source&gt;:6:6: note: constraints not satisfied<br>In file included from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/compare:39,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_pair.h:65,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algobase.h:64,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/char_traits.h:39,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/ios:40,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/ostream:38,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/iostream:39,<br>                 from &lt;source&gt;:1:<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts: In substitution of &#x27;template&lt;class T&gt;  requires  equality_comparable&lt;T&gt; bool max(T, T) [with T = A]&#x27;:<br>&lt;source&gt;:17:8:   required from here<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:280:15:   required for the satisfaction of &#x27;__weakly_eq_cmp_with&lt;_Tp, _Tp&gt;&#x27; [with _Tp = A]<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:290:13:   required for the satisfaction of &#x27;equality_comparable&lt;T&gt;&#x27; [with T = A]<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:281:4:   in requirements with &#x27;std::remove_reference_t&lt;_Tp&gt;&amp; __t&#x27;, &#x27;std::remove_reference_t&lt;_Up&gt;&amp; __u&#x27; [with _Up = A; _Tp = A]<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:282:17: note: the required expression &#x27;(__t == __u)&#x27; is invalid<br>  282 |           &#123; __t == __u &#125; -&gt; __boolean_testable;<br>      |             ~~~~^~~~~~<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:283:17: note: the required expression &#x27;(__t != __u)&#x27; is invalid<br>  283 |           &#123; __t != __u &#125; -&gt; __boolean_testable;<br>      |             ~~~~^~~~~~<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:284:17: note: the required expression &#x27;(__u == __t)&#x27; is invalid<br>  284 |           &#123; __u == __t &#125; -&gt; __boolean_testable;<br>      |             ~~~~^~~~~~<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/concepts:285:17: note: the required expression &#x27;(__u != __t)&#x27; is invalid<br>  285 |           &#123; __u != __t &#125; -&gt; __boolean_testable;<br>      |             ~~~~^~~~~~<br>cc1plus: note: set &#x27;-fconcepts-diagnostics-depth=&#x27; to at least 2 for more detail<br>Compiler returned: 1<br></code></pre></td></tr></table></figure>
<p>这里会直接表明A不满足<code>std::equality_comparable</code>的约束。虽然如此，噪音还是非常的多。更重要的是，对于库函数–这种我们不想研究源码的函数，效果还是一般：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">n file included from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algobase.h:71,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/char_traits.h:39,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/ios:40,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/ostream:38,<br>                 from /opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/iostream:39,<br>                 from &lt;source&gt;:1:<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/predefined_ops.h: In instantiation of &#x27;constexpr bool __gnu_cxx::__ops::_Iter_less_iter::operator()(_Iterator1, _Iterator2) const [with _Iterator1 = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;; _Iterator2 = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;]&#x27;:<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algo.h:1826:14:   required from &#x27;constexpr void std::__insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]&#x27;<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algo.h:1866:25:   required from &#x27;constexpr void std::__final_insertion_sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]&#x27;<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algo.h:1957:31:   required from &#x27;constexpr void std::__sort(_RandomAccessIterator, _RandomAccessIterator, _Compare) [with _RandomAccessIterator = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;; _Compare = __gnu_cxx::__ops::_Iter_less_iter]&#x27;<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/stl_algo.h:4842:18:   required from &#x27;constexpr void std::sort(_RAIter, _RAIter) [with _RAIter = __gnu_cxx::__normal_iterator&lt;A*, std::vector&lt;A&gt; &gt;]&#x27;<br>&lt;source&gt;:10:14:   required from here<br>/opt/compiler-explorer/gcc-11.2.0/include/c++/11.2.0/bits/predefined_ops.h:45:23: error: no match for &#x27;operator&lt;&#x27; (operand types are &#x27;A&#x27; and &#x27;A&#x27;)<br>   45 |       &#123; return *__it1 &lt; *__it2; &#125;<br>      |                ~~~~~~~^~~~~~~~<br><br>剩下还有80多行<br></code></pre></td></tr></table></figure>
<p>事实上，当c++引入模板机制而不进行类型检查的那一刻，这种修修补补也很难解决问题的情形已经被决定了。希望c++模板的引起的种种问题，能够给后世的语言设计者以警醒和教训。</p>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">

            </div>
        </div>
    </body>
</html>