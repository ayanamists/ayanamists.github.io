<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2020-3-27-reg" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/2020-3-27-reg/" class="article-date">
  <time datetime="2020-03-27T00:00:00.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/2020-3-27-reg/">让我们实现编程语言吧（三）正则文法与实现正则表达式解析引擎</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是正则文法"><a href="#什么是正则文法" class="headerlink" title="什么是正则文法"></a>什么是正则文法</h2><p>正则文法是比较靠谱的文法。它在CFG的基础上继续进行限制：</p>
<p>每一个正则文法的规则只能是以下两个规则之一：</p>
<ul>
<li>形如$$A \rightarrow a$$的规则。</li>
<li>形如$$A \rightarrow aB$$的规则。</li>
</ul>
<p>可以看到这文法是很简单的，过于简单会引起不好用，所以我们也有“增强版”的正则文法，它多了一条规则：</p>
<ul>
<li>如果$$A, B, C…$$是正则文法左端的符号，那么$$X = ABC…$$也是正则文法。</li>
</ul>
<p>这个“增强”实际上是允许正则文法进行连接，我们在后面会看到，它和原来的正则文法是完全等价的。</p>
<h2 id="正则文法对应的自动机"><a href="#正则文法对应的自动机" class="headerlink" title="正则文法对应的自动机"></a>正则文法对应的自动机</h2><p>自动机的使用是比较广泛的，我们在数字电路和网络协议中都看到过它的身影。在这里，我们使用的是“有限状态自动机”，它简单地说就是一张表或者一幅有向图，这张表或者这幅图记录着状态如何变化（以及什么是起始状态，什么是终止状态等等）。那么，它和正则文法是怎么联系起来的呢？</p>
<p>先不讨论“增强”型的正则文法，只讨论一般的正则文法。一个非常关键的想法是：<strong>把非终结符当作一种“状态”</strong></p>
<p>这样抽象地说可能有点难以理解，我们来说一个具体的文法：</p>
<p>$$ S \rightarrow aA $$</p>
<p>$$ A \rightarrow bB $$</p>
<p>$$ B \rightarrow cC $$</p>
<p>$$ C \rightarrow d $$</p>
<p>很容易可以看出来，这定义的是$$abcd$$这个字符串。</p>
<p>我们可以构想，有这样的一台机器，它输入一个字符串，输出一个布尔值，也就是说，如果这个字符串是“abcd”，那就输出真，否则输出假。</p>
<p>使用“把非终结符当作一种状态”的思想，可以让我们制造出来这种机器。</p>
<p>这机器的开始状态是$$S$$，然后读入一个字符，如果为”a”，就进入$$A$$状态，在$$A$$状态，也读入一个字符，如果为”b”，就进入$$B$$状态，直至在$$C$$状态读入”d”后进入成功状态。</p>
<p>用图片来表示，就是这样：</p>
<p><img src="https://pic.downk.cc/item/5e7e12a4504f4bcb0492dd16.png" alt="1"></p>
<p>（由于是自动生成的，符号可能不太一样）</p>
<p>如果没能执行刚才的操作，这机器就进入“失败”状态。这就解决了我们的判断问题。</p>
<p>你可能会问，这究竟有什么用呢？不就是匹配个字符串吗，需要这么麻烦？</p>
<p>我们经常研究一个问题“如何组合简单的东西来完成复杂的任务”。一个经久不衰的答案是“封闭性”。而正则文法和自动机恰恰是封闭的。</p>
<p>什么意思呢？如果你把一个非终结符和其对应的自动机看作一种“运算单元”，你就会发现，一个或多个“运算单元”可以通过以下的运算生成另一个更复杂的运算单元：</p>
<ol>
<li>$$ A = aB $$ 将一个终结符和一个非终结符连接，会生成一个可以匹配更长语言的非终结符</li>
<li>$$ A = BC $$ 把两个终结符连接起来，会生成一个匹配更长语言的非终结符</li>
<li>$$ A = B | C $$ 将一个终结符和一个终结符用 “|” 连接， 可以生成一个匹配它们两个所对应的语言的终结符</li>
</ol>
<p>另外的几个操作暂时不引入了，我们需要思考的是，刚才我们说<strong>把非终结符当作一种“状态</strong>，而这里，我们实际上做的是<strong>把非终结符当作一个状态机</strong>。</p>
<p>通过非终结符之间的运算，状态机可以进行组合，以形成更复杂的状态机。这样一来，我们就可以用这种结构构造相当复杂的匹配方法。</p>
<h2 id="把正则文法改写为非确定型自动机"><a href="#把正则文法改写为非确定型自动机" class="headerlink" title="把正则文法改写为非确定型自动机"></a>把正则文法改写为非确定型自动机</h2><p>我们前面已经说了，我们实际上是<strong>把非终结符当作一个状态机</strong>，所以，我们只要研究各种文法组合如何改写成状态机的组合就好。</p>
<p>首先来看最简单的</p>
<p>$$ A = aB $$</p>
<p>$$B$$ 是一个状态机，那么$$A$$就应该是一个新的状态机，它的开始状态由a变成B的开始状态，类似于这样：</p>
<p>由</p>
<p><img src="https://pic.downk.cc/item/5e7e9fc0504f4bcb04f889d0.png" alt="2"></p>
<p>变为</p>
<p><img src="https://pic.downk.cc/item/5e7ea014504f4bcb04f8bf3e.png" alt="3"></p>
<p>注意我画的状态机的尾部指向的是$$\epsilon$$，而不是成功状态$$&lt;&gt;$$，这是为什么呢？</p>
<p>因为在状态机没有构造好的时候，状态机的尾部相当于是“游离”的，我们有两种情况：</p>
<ul>
<li>要么在最后的构造中，将尾部指向$$&lt;&gt;$$状态</li>
<li>要么在某一次构造中，将尾部指向其他状态</li>
</ul>
<p>然后我们来看看两个非终结符之间的连接：</p>
<p>$$ A = BC $$</p>
<p>这应该如何处理呢？答案很简单，就是将$$B$$状态机的尾部，指向$$C$$状态机的开始状态，然后把新状态机的尾部设置为$$C$$状态机的尾部就好。</p>
<p>例如，$$B$$状态机还是上次的B状态机，而$$C$$状态机为：</p>
<p><img src="https://pic.downk.cc/item/5e7ea222504f4bcb04fa18ea.png" alt="4"></p>
<p>那么，$$A$$状态机就会是：</p>
<p><img src="https://pic.downk.cc/item/5e7ea27b504f4bcb04fa564d.png" alt="5"></p>
<p>其他的操作符也大抵类似，不过要注意的是我们这里保证<strong>每一次操作产生的自动机开始状态都有且仅有一个</strong></p>
<h2 id="把NFA改写成DFA"><a href="#把NFA改写成DFA" class="headerlink" title="把NFA改写成DFA"></a>把NFA改写成DFA</h2><p>NFA最大的特点是允许“不确定性”，也就是说，对于一个给定的状态转移因子（比如说”a”），有可能有两种不同的状态转移方法。</p>
<p>例如下图：</p>
<p><img src="https://pic.downk.cc/item/5e7eabbb504f4bcb040036dd.png" alt="6"></p>
<p>第“6”号状态如果遇到了“a”，那么它有两种可能，一种是转移到自己本身，另一种是转移到第”7”号状态。</p>
<p>有编程经验的人立刻会想到，如果要解决这个问题，恐怕需要使用一些图的搜索技术，比如深度优先搜索–先转移到自己，如果后面的转移失败就转移到第”7”号状态。</p>
<p>而这样的方法，效率是不佳的。有没有一种方法，可以使得我们不是“搜索”，而是线性地“匹配”呢？</p>
<p>这就是把NFA改写为DFA的原始动力。</p>
<p>至于如何改写呢？我懒得写了，请自行查询相关资料吧。</p>
<h2 id="实现一个正则表达式引擎"><a href="#实现一个正则表达式引擎" class="headerlink" title="实现一个正则表达式引擎"></a>实现一个正则表达式引擎</h2><p>有了上面的思考，我们就可以来实现一个正则表达式解析引擎了。具体的实现，见<a target="_blank" rel="noopener" href="https://github.com/ayanamists/MyRegEngine">此处</a></p>
<h3 id="第一步-解析正则表达式"><a href="#第一步-解析正则表达式" class="headerlink" title="第一步 解析正则表达式"></a>第一步 解析正则表达式</h3><p>必须指出，正则表达式本身不是正则语法。因为<strong>正则语法不可能匹配一个可以无穷地嵌套括号的语言</strong>，而正则表达式允许括号的无穷嵌套。</p>
<p>所以，要解析正则表达式，必须利用解析CFG的一些办法。</p>
<p>不过，一个比较好的消息是，可以利用解析数学表达式的算法–调度场算法解析正则表达式。</p>
<p>解析的结果并不是一颗树，而是对应树的后序遍历结果–后缀正则表达式</p>
<h3 id="第二步-由正则表达式生成NFA"><a href="#第二步-由正则表达式生成NFA" class="headerlink" title="第二步 由正则表达式生成NFA"></a>第二步 由正则表达式生成NFA</h3><p>我们使用了自左向右扫描后缀正则表达式的办法来生成NFA。</p>
<p>具体的做法和求一个数学表达式没有太大区别，就是如果是一个字符，就压栈，如果是一个运算符，就弹出对应的元素，运算后放入栈里。</p>
<p>不过这里有一个问题，那就是栈里放些什么呢？</p>
<p>仔细思考一下会发现，栈里有两种元素</p>
<ul>
<li>一个字符</li>
<li>一个自动机</li>
</ul>
<p>我们这样来表示栈里的元素</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">BeginState</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">int</span> internalState &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BeginState</span>(<span class="params"></span>)</span> &#123; internalState = <span class="number">0</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">BeginState</span>(<span class="params"><span class="keyword">int</span> state</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          internalState = state;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">EndState</span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">StateInStack</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> BeginState Begin &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="keyword">public</span> EndState End &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PointEndTo</span>(<span class="params"><span class="keyword">int</span> state, <span class="keyword">in</span> Nfa&lt;CharWithEmpty&gt; nfa</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          PointEndToWithout(state, nfa);</span><br><span class="line">          End.internalList.Clear();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PointEndToWithout</span>(<span class="params"><span class="keyword">int</span> state, <span class="keyword">in</span> Nfa&lt;CharWithEmpty&gt; nfa</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          <span class="keyword">foreach</span> (<span class="keyword">var</span> (estate, how) <span class="keyword">in</span> End)</span><br><span class="line">          &#123;</span><br><span class="line">              nfa.SetStateTransition(estate, state, how);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">StackElement</span></span><br><span class="line">  &#123;</span><br><span class="line">      <span class="keyword">public</span> StateInStack State &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">public</span> CharWithEmpty symbol &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125; = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">StackElement</span>(<span class="params"><span class="keyword">in</span> BeginState begin, <span class="keyword">in</span> EndState end</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          State = <span class="keyword">new</span> StateInStack();</span><br><span class="line">          State.Begin = begin;</span><br><span class="line">          State.End = end;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">StackElement</span>(<span class="params"><span class="keyword">char</span> sym</span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">          symbol = <span class="keyword">new</span> CharWithEmpty( sym);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">StackElement</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">          State = <span class="keyword">new</span> StateInStack();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这样一来就可以优雅地实践刚才所描述的组合算法了。</p>
<h3 id="第三步-由NFA生成DFA"><a href="#第三步-由NFA生成DFA" class="headerlink" title="第三步 由NFA生成DFA"></a>第三步 由NFA生成DFA</h3><p>这里我们使用广度优先搜索的方法，从BeginState开始，搜索出它的$$\epsilon$$闭包，然后分析可能的状态转移。对每一个可能的状态转移都求其$$\epsilon$$闭包，之后将它压入队列中，直至队列为空。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/27/2020-3-27-reg/" data-id="ckg4mhp2e001c17sb8k1i5cop" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-3-27-grammar" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/2020-3-27-grammar/" class="article-date">
  <time datetime="2020-03-27T00:00:00.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/2020-3-27-grammar/">让我们实现编程语言吧（二）生成文法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%94%9F%E6%88%90%E6%96%87%E6%B3%95">什么是生成文法</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E6%96%87%E6%B3%95%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">生成文法的注意事项</a><ul>
<li><a href="#%E7%94%9F%E6%88%90%E6%96%87%E6%B3%95%E7%A9%B6%E7%AB%9F%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88">生成文法究竟代表什么</a></li>
<li><a href="#%E7%94%9F%E6%88%90%E5%9B%BE">生成图</a></li>
<li><a href="#parse%E7%9A%84%E7%9C%9F%E6%AD%A3%E6%84%8F%E4%B9%89">Parse的真正意义</a></li>
</ul>
</li>
<li><a href="#%E5%9B%9B%E7%A7%8D%E7%94%9F%E6%88%90%E6%96%87%E6%B3%95">四种生成文法</a><ul>
<li><a href="#type-0">Type 0</a></li>
<li><a href="#type-1-context-sensitive-grammar">Type 1 Context-Sensitive Grammar</a></li>
<li><a href="#type-2-context-free-grammar">Type 2 Context Free Grammar</a><ul>
<li><a href="#uvwxy%E5%AE%9A%E7%90%86">uvwxy定理</a><ul>
<li><a href="#uvwxy%E5%AE%9A%E7%90%86%E7%9A%84%E8%AF%81%E6%98%8E%E5%92%8C%E6%84%8F%E4%B9%89">uvwxy定理的证明和意义</a></li>
<li><a href="#%E8%AF%81%E6%98%8Eanbncn%E4%B8%8D%E8%83%BD%E8%A2%ABcfg%E7%94%9F%E6%88%90">证明$$a^{n}b^{n}c^{n}$$不能被CFG生成</a></li>
<li><a href="#python%E4%B8%8D%E6%98%AFcfg">Python不是CFG</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#type-3-regular-grammar">Type 3 Regular Grammar</a></li>
<li><a href="#type-4">Type 4</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="什么是生成文法"><a href="#什么是生成文法" class="headerlink" title="什么是生成文法"></a>什么是生成文法</h2><p>在谈生成文法之前，我们首先要解释一下什么叫做“文法”(grammar)。</p>
<blockquote>
<p>语法（英语：Grammar），也称文法，在语言学中指任意自然语言中句子、短语以及词等语法单位的语法结构与语法意义的规律</p>
</blockquote>
<p>可见，文法这东西本身的意义是很宽泛的，我们这里研究的是“生成语法”，也就是说，用来产生语言的文法。</p>
<p>这里的“语言”，指的是由所有合法的句子组成的集合。</p>
<p>考虑这样的语言：</p>
<p>$${a}$$</p>
<p>我们如何生成它呢？</p>
<p>答案很简单：</p>
<p>$$S\rightarrow a$$</p>
<p>可以看到，生成文法是类似于$$\lambda$$演算的替换规则。这些替换规则有两种元素：</p>
<ul>
<li>Terminal</li>
<li>Non-Terminal</li>
</ul>
<p>其中Terminal，也就是所谓的“终结符”是<strong>不能被继续替换的符号</strong>，Non-Termianl是<strong>可以被继续替换的符号</strong></p>
<p>用生成文法生成句子，其实就是不断地替换非终结符，直至句子中全部为终结符，就产生了一个句子。</p>
<p>我们再看一个例子：形如$$a^{n}b^{n}$$的语言，也就是有相同数量的a和b的语言：</p>
<p>$${\epsilon, ab, aabb, aaabbb, … }$$</p>
<p>它可以被以下文法生成：</p>
<p>$$ S \rightarrow A $$</p>
<p>$$ A \rightarrow aAb $$</p>
<p>$$ A \rightarrow ab $$</p>
<p>比如我们要生成$$aabb$$，就进行以下替换就可以：</p>
<p>$$ S \rightarrow A $$</p>
<p>$$ A \rightarrow aAb $$</p>
<p>$$ aAb \rightarrow aabb $$</p>
<h2 id="生成文法的注意事项"><a href="#生成文法的注意事项" class="headerlink" title="生成文法的注意事项"></a>生成文法的注意事项</h2><h3 id="生成文法究竟代表什么"><a href="#生成文法究竟代表什么" class="headerlink" title="生成文法究竟代表什么"></a>生成文法究竟代表什么</h3><p>生成文法代表了一个语言，也就是一个<strong>集合</strong>，它由所有合法（可被生成语法生成的）的句子组成。</p>
<h3 id="生成图"><a href="#生成图" class="headerlink" title="生成图"></a>生成图</h3><p>很容易看出来，生成句子的过程是一个有向图。如果我们把刚才的生成过程画出来的话，会是这样的：</p>
<p><img src="https://pic.downk.cc/item/5e7d6dec504f4bcb041ce470.png" alt="1"></p>
<p>实际上，这是一棵树。但，为什么还是用“图”来称呼它呢？下面会讨论这个问题。</p>
<h3 id="Parse的真正意义"><a href="#Parse的真正意义" class="headerlink" title="Parse的真正意义"></a>Parse的真正意义</h3><p>Parse的过程，就是由给定的句子还原生成图的过程，比如说，给定了aabb，我们要还原出来上面的图。</p>
<h2 id="四种生成文法"><a href="#四种生成文法" class="headerlink" title="四种生成文法"></a>四种生成文法</h2><h3 id="Type-0"><a href="#Type-0" class="headerlink" title="Type 0"></a>Type 0</h3><p>这种文法没有任何限制，最为自由，所以也最没用。</p>
<h3 id="Type-1-Context-Sensitive-Grammar"><a href="#Type-1-Context-Sensitive-Grammar" class="headerlink" title="Type 1 Context-Sensitive Grammar"></a>Type 1 Context-Sensitive Grammar</h3><p>我们对Type 0语法加以一些限制，就得到了Type1型语法–上下文有关语法（CSG）。加上什么限制呢？</p>
<p>在Type 0类语法中，有一些规则我们特别不喜欢：</p>
<p>$$ aBc \rightarrow a $$</p>
<p>这种规则是反直觉的，因为如果我们输入了$$a$$，会重建出一颗比$$a$$元素更多的生成图，这在一般情况下都是没有道理的。</p>
<p>所以，我们作以下限制：</p>
<ul>
<li>所有的规则必须满足<em>箭头左侧的符号数小于等于右侧的符号数</em></li>
</ul>
<p>这也叫做“单调性”。有了这个性质，我们就保证了生成的过程是符号数不减的，Parse的过程是符号数不增的。</p>
<p>但这也有一个副作用：空规则被禁止了。</p>
<p>所谓的空规则，也即是类似于</p>
<p>$$ A \rightarrow \epsilon $$</p>
<p>的规则，这明显是不满足“单调性”的，所以它被禁止了。实际上，如果不禁止空规则，单调性的引入是没有意义的：</p>
<p>$$ aBc \rightarrow AaC $$</p>
<p>$$ A \rightarrow \epsilon $$</p>
<p>$$ C \rightarrow \epsilon $$</p>
<p>但我们一般允许语言本身是空的，也即是$$S \rightarrow \epsilon$$</p>
<p>一个比较好的消息是，如果文法中的空规则只有</p>
<p>$$ A \rightarrow \epsilon $$</p>
<p>而不存在</p>
<p>$$ \alpha A \beta \rightarrow \epsilon $$</p>
<p>那么这是可以被消除成没有空规则的形式的。只要消除以后仍然是单调的，这文法也应该被视作CSG，因为<strong>文法最终定义的是集合</strong></p>
<p>上下文有关语法还有另外一种定义，这里就不介绍了。</p>
<p>我们来看这样的一个例子：</p>
<p>具有连续相同数目abc的字符串，也就是说: $$a^{n}b^{n}c^{n}$$</p>
<p>$${abc, aabbcc, aaabbbccc …}$$</p>
<p>如何用CSG生成它呢？</p>
<p>这规则是不太好理解和写出的：</p>
<p>$$ S \rightarrow abc | aSQ $$</p>
<p>$$ bQc \rightarrow bbcc $$</p>
<p>$$ cQ \rightarrow Qc $$</p>
<p>这也就是CSG不太好用的地方–人类难以理解这种语法，所以很难构造它。</p>
<h3 id="Type-2-Context-Free-Grammar"><a href="#Type-2-Context-Free-Grammar" class="headerlink" title="Type 2 Context Free Grammar"></a>Type 2 Context Free Grammar</h3><p>我们喜欢树。树的各种性质都很美妙，对树的操作天生比对图的操作舒服。</p>
<p>那么，可以把Parse图变为Parse树吗？答案是可以。</p>
<p>生成的过程为什么是图？我们看看用上面的语法生成$$aabbcc$$的过程：</p>
<p><img src="https://pic.downk.cc/item/5e7d790f504f4bcb04234274.jpg" alt="2"></p>
<p>可以看到，有两个点的入边和出边都有好几条，如果把它变成无向图会产生回路，所以是图而非树。</p>
<p>这两个点的产生是因为语法规则</p>
<p>$$ bQc \rightarrow bbcc $$</p>
<p>$$ cQ \rightarrow Qc $$</p>
<p>左边的符号是复数个。只要我们令左边的符号只能有一个，生成图就会变成生成树！</p>
<p>这也就是CFG的限制：</p>
<ul>
<li>箭头左边有且只有一个非终结符。</li>
</ul>
<h4 id="uvwxy定理"><a href="#uvwxy定理" class="headerlink" title="uvwxy定理"></a>uvwxy定理</h4><p>这个限制对语言的表现力有什么影响吗，或者说，CFG相比于CSG，在表现力上有什么区别吗？请再次回想我们一直强调的一点：<strong>文法最终定义的是集合</strong></p>
<p>要看有没有影响，就要比较CSG和CFG所<strong>能</strong>生成的集合的区别。</p>
<p>再来看看$$a^{n}b^{n}c^{n}$$这个集合，我们可以用以下CFG生成它的超集：</p>
<p>$$ S \rightarrow A $$</p>
<p>$$ A \rightarrow aAc $$</p>
<p>$$ A \rightarrow bA $$</p>
<p>$$ A \rightarrow b $$</p>
<p>这个文法生成的是形如$$a^{n}b^{m}c^{n}$$的句子，这$$a^{b}b^{n}c^{n}$$构成的集合当然是这些句子构成的集合的子集。</p>
<p>但是，我们能不能找到一个文法，其对应的集合是$$a^{n}b^{n}c^{n}$$所构成的集合呢？</p>
<p><strong>uvwxy</strong>定理告诉我们，这是不可能的。</p>
<h5 id="uvwxy定理的证明和意义"><a href="#uvwxy定理的证明和意义" class="headerlink" title="uvwxy定理的证明和意义"></a>uvwxy定理的证明和意义</h5><p>故事要从生成树或者Parse树的构造讲起。</p>
<p>我们将每个规则标号，再将每个规则右侧的符号标号，就像下面这样：</p>
<p>$$ S \rightarrow A^{0} \tag{0} $$</p>
<p>$$ A \rightarrow a^{0}A^{1}b^{2}  \tag{1} $$</p>
<p>$$ A \rightarrow a^{0}b^{1}  \tag{2} $$</p>
<p>研究生成树，我们会发现<strong>句子中的每个终结符，都存在一条由终结符起，经历一些非终结符至根的路径</strong>，而<strong>这条路径，可以被一个二元组的列表定义</strong></p>
<p>如何构造该二元组列表呢？我们可以把生成树中除根以外的每个符号都打上标记，标记的内容是$${规则编号，位置编号}$$，这样一来每个非终结符就唯一地对应一个标记，而把标记串联起来，就得到了这个列表。</p>
<p>例如，对$$aabb$$这个句子，我们可以作以下标记：</p>
<p><img src="https://pic.downk.cc/item/5e7dea04504f4bcb047702c0.png" alt="3"></p>
<p>这样一来，最左侧的a，它的列表为：</p>
<p>$${1, 0}, {0, 0}$$</p>
<p>第二个a的列表为：</p>
<p>$${2, 0}, {1, 1}, {0, 0}$$</p>
<p>我们立刻可以发现一个问题：</p>
<ul>
<li>显然地，给定一个合法列表，有且仅有一个终结符与之对应</li>
</ul>
<p>这个时候我们立刻会思考一个问题：列表中的二元组，其数量显然是有限的。</p>
<p>什么意思呢？就是说，对一个给定的语法来说，不同二元组的数量就是</p>
<p>$$C = \sum{Symbols_{rule}}$$</p>
<p>那么，如果这个列表的长度大于$$C$$，这个列表就一定会有两个相同的元素！</p>
<p>如果长度有最大值，那么所有列表组成的集合的大小实际上也有最大值。</p>
<p>又由于一个列表要么是非法的，要么只有一个终结符与之对应，这样的集合所对应的句子，长度也是有限的。</p>
<p>换言之，只要长度超过了这个上限$$n$$，那一个列表中就必然有两个相同的二元组。而如果一个终结符的列表中有两个相同的二元组，那就说明一个问题：<strong>有同一个规则被运用了两次</strong>。</p>
<p>我们用图片展示一下，就是这样：</p>
<p><img src="https://pic.downk.cc/item/5e7deee7504f4bcb047a6de5.jpg" alt="4"></p>
<p>所以，一个足够长的句子必然可以被分解为$$uvwxy$$五个部分，且$$v$$和$$x$$不同时为空。为什么不能同时为空呢？我们可以继续使用反证法，由于列表集是离散的且有上界$$n$$，必然可以找到句子长度的真正上界$$n_{real}$$。假设一个句子的长度超过了$$n_{real}$$，且可以被分解为$$uwy$$。这也就是说必然存在一个单元规则$$A \rightarrow A$$，而单元规则是可以被消除的，即，移除对应的生成树节点，该生成树仍然是合法的。我们移除这个节点以后，就有两种情况：</p>
<ul>
<li>这个句子还可以用别的方式被分解为$$uvwxy$$</li>
<li>这个句子没有重复的规则。</li>
</ul>
<p>第二种情况和长度超过$$n_{real}$$矛盾，所以不存在“一个长度超过$$n_{real}$$，可以被分解为$$uwy$$而不能被分解为$$uvwxy$$的句子”。为了下面证明的方便，这里直接规定$$x$$和$$y$$不同时为空。</p>
<p>这个时候，如果把第二个A代换成第一个A会怎么样呢？这个代换显然也是成立的，因为这个上下文<strong>无关</strong>文法：</p>
<p><img src="https://pic.downk.cc/item/5e7df0fc504f4bcb047c54f3.jpg" alt="5"></p>
<p>我们发现，这句子是$$uvvwxxy$$，或者$$uv^{2}wx^{2}y$$。</p>
<p>也就是说，如果$$uvwxy$$是一个合法的句子，那么，$$uv^{2}wx^{2}y$$也一定是个合法的句子！</p>
<h5 id="证明-a-n-b-n-c-n-不能被CFG生成"><a href="#证明-a-n-b-n-c-n-不能被CFG生成" class="headerlink" title="证明$$a^{n}b^{n}c^{n}$$不能被CFG生成"></a>证明$$a^{n}b^{n}c^{n}$$不能被CFG生成</h5><p>用这个性质，我们立刻可以证明$$a^{n}b^{n}c^{n}$$不能被CFG所生成：</p>
<p>考虑一个句子$$a^{k}b^{k}c^{k}$$：</p>
<ul>
<li>如果$$v$$或$$x$$中含有$$b$$，那么，$$v$$中就不得含有$$a$$或$$x$$中就不得含有$$c$$，因为这会使得$$v^{2}$$或$$x^{2}$$中出现$$a…b…a$$或$$b…c…b$$的序列，而这显然不是$$a^{n}b^{n}c^{n}$$型的句子。所以$$u$$只能为$$a^{k}$$或$$y$$只能为$$c^{k}$$，而原本$$v, w, x$$中的$$b$$数量之和为$$k$$，$$v^{2}, w, x^{2}$$中$$b$$的数量必然大于$$k$$，所以这会使得$$uv^{2}wx^{2}y$$也不是$$a^{n}b^{n}c^{n}$$型的句子。所以这种情况不成立。</li>
<li>如果$$v$$和$$x$$中均不含$$b$$，那么，$$b^{k}$$一定被分解到了$$w$$中。由于$$x$$和$$v$$非空，必然存在一部分$$a$$被分解到$$x$$中，一部分$$b$$被分解到$$y$$中。同上，这会使得$$uv^{2}wx^{2}y$$中含有的$$a, b, c$$数不相等。故也不成立。</li>
</ul>
<p>所以，$$a^{n}b^{n}c^{n}$$不能被CFG生成。</p>
<h5 id="Python不是CFG"><a href="#Python不是CFG" class="headerlink" title="Python不是CFG"></a>Python不是CFG</h5><p>可以证明，一切类似于Python那样的<strong>用多层缩进表示块</strong>的语法，都不能用CFG生成。</p>
<h3 id="Type-3-Regular-Grammar"><a href="#Type-3-Regular-Grammar" class="headerlink" title="Type 3 Regular Grammar"></a>Type 3 Regular Grammar</h3><p>正则文法，就是“正则表达式”的那个文法，我们在下期讨论。</p>
<h3 id="Type-4"><a href="#Type-4" class="headerlink" title="Type 4"></a>Type 4</h3><p>这类型没什么用，不做讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>四种语法中，比较有用的是CFG和正则文法。下一篇文章我们将重点讨论正则文法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/27/2020-3-27-grammar/" data-id="ckg4mhp2d001b17sbauaybruj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-3-12-parser" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/14/2020-3-12-parser/" class="article-date">
  <time datetime="2020-03-14T00:00:00.000Z" itemprop="datePublished">2020-03-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/14/2020-3-12-parser/">让我们实现编程语言吧（一）序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要实现编程语言"><a href="#为什么要实现编程语言" class="headerlink" title="为什么要实现编程语言"></a>为什么要实现编程语言</h2><ul>
<li>好玩</li>
<li>深入理解程序的执行过程</li>
<li>为以后的逆向工程研究打下一些基础</li>
</ul>
<h2 id="实现什么编程语言"><a href="#实现什么编程语言" class="headerlink" title="实现什么编程语言"></a>实现什么编程语言</h2><p>这里我们实现了类似于ruby的编程语言。它具有以下特性：</p>
<ul>
<li>纯面向对象，即所有的字面量与值都是对象</li>
<li>值驱动，任何表达式都具有值，且其值是一个对象</li>
<li>支持块</li>
<li>大部分操作都可以归结为调用某个类的成员方法/类方法</li>
</ul>
<p>相比于ruby，我们做出的主要调整有：</p>
<ul>
<li>只支持部分ruby语法</li>
<li>彻底推翻了ruby的单件类设计，个人认为单件类是ruby设计中问题最大的一部分</li>
<li>继承结构简单，所有对象都默认继承object类</li>
</ul>
<h2 id="如何实现编程语言"><a href="#如何实现编程语言" class="headerlink" title="如何实现编程语言"></a>如何实现编程语言</h2><p>简单来说有三步：</p>
<ul>
<li>实现前端：将输入的字符串变为一棵树（AST）</li>
<li>实现内部数据结构</li>
<li>实现eval函数</li>
</ul>
<p>今天（2020年3月14日）我们已经完成了第一个阶段的任务</p>
<h2 id="第一步：Parser"><a href="#第一步：Parser" class="headerlink" title="第一步：Parser"></a>第一步：Parser</h2><h3 id="谈谈Parser"><a href="#谈谈Parser" class="headerlink" title="谈谈Parser"></a>谈谈Parser</h3><p>Parser是“语法解析器”的意思。一般来说它输入一串Token流，解析出一颗Ast。其实也不一定就是这样，比如说我们实现的产品就没有用词法解析器，直接通过源代码产AST。</p>
<p>如何做到这件事呢？这是有点麻烦的。由于我没有学过编译原理，对LR、LALR的parser generator不太了解，这里只说一说递归下降解析器的原理和我们使用的Parser Generator库。</p>
<p>在此之前，我们先要说一说所谓的“文法”，而这，就留给下面的文章吧。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/14/2020-3-12-parser/" data-id="ckg4mhp2c001917sbe73d5f24" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-02-16-white_album-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/16/2020-02-16-white_album-1/" class="article-date">
  <time datetime="2020-02-16T00:00:00.000Z" itemprop="datePublished">2020-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/16/2020-02-16-white_album-1/">WA2的逆向与外挂（一） 序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="WA2简介"><a href="#WA2简介" class="headerlink" title="WA2简介"></a>WA2简介</h2><p>WA2，也就是White Album2，是日本leaf公司推出的美少女文字冒险游戏。其感情真实细腻，剧情丝丝入扣，是GALGAME业界天花板级别的作品。</p>
<p>我们这里分析的WA2是国内汉化组汉化过的版本，其所有PE文件罗列如下：</p>
<ul>
<li>可执行文件<ul>
<li>WA2.exe，似乎是原本的可执行文件<ul>
<li>大小：1,220,608 字节</li>
<li>SHA1：DBF3BF1688159CC287ACA81BEE10C41DB0CAE74D</li>
</ul>
</li>
<li>WA2_chs.exe，似乎是汉化版的运行文件<ul>
<li>大小：1,220,096 字节</li>
<li>SHA1：58FEDD7A10BF4EDB41E44FF1FCC365087AA6E880</li>
</ul>
</li>
</ul>
</li>
<li>动态链接库<ul>
<li>未发现</li>
</ul>
</li>
</ul>
<h2 id="为什么要研究WA2"><a href="#为什么要研究WA2" class="headerlink" title="为什么要研究WA2"></a>为什么要研究WA2</h2><p>动机最初来源于网上的<a target="_blank" rel="noopener" href="https://blog.csdn.net/applebananac123/article/details/59253642">一篇文章</a>：</p>
<p>在这篇文章中，作者通过别人总结的好感度上升流程图，结合编程模拟，认为在随便选择的情况下：</p>
<blockquote>
<p>最后贴出结果：<br>雪菜TE概率：39.3%<br>雪菜NE概率：30.3%<br>冬马NE概率：30.4%<br>冬马TE概率：0.024%</p>
</blockquote>
<p>这个结果是准确的吗？我十分想搞清楚。</p>
<h2 id="主要的研究目标与方法"><a href="#主要的研究目标与方法" class="headerlink" title="主要的研究目标与方法"></a>主要的研究目标与方法</h2><ul>
<li>通过实验来验证coda的各结局概率<ul>
<li>自动化地进行游戏和记录结果 – 外挂技术</li>
<li>通过逆向工程研究WA2的结局判断方法 – 逆向工程技术</li>
</ul>
</li>
<li>解包，研究WA2文件夹里的资源文件 – 逆向工程技术</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/16/2020-02-16-white_album-1/" data-id="ckg4mhp1v000f17sbeln5euz6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-02-16-white_album-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/16/2020-02-16-white_album-2/" class="article-date">
  <time datetime="2020-02-16T00:00:00.000Z" itemprop="datePublished">2020-02-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/16/2020-02-16-white_album-2/">WA2的逆向与外挂（二） 实现鼠标自动化操作</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实现自动操作的几个想法"><a href="#实现自动操作的几个想法" class="headerlink" title="实现自动操作的几个想法"></a>实现自动操作的几个想法</h2><p>实现自动操作，大概有几个方法：</p>
<ul>
<li>直接调用某些WA2的函数，强行推进</li>
<li>使用鼠标自动化方法，模拟人的行为</li>
</ul>
<p>这里，我们选择了第二个方案。因为在一番逆向过后，我并没有完全理解WA2剧情推进的机制，只能等日后逆向能力更强后再实践。</p>
<h2 id="Windows平台下鼠标自动化的方法"><a href="#Windows平台下鼠标自动化的方法" class="headerlink" title="Windows平台下鼠标自动化的方法"></a>Windows平台下鼠标自动化的方法</h2><p>据我所知，要实现UI的自动化，大概有几个方法：</p>
<ul>
<li>使用win32 api，直接根据windows的消息机制进行注入。</li>
<li>使用vbs脚本</li>
<li>使用微软官方的<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/windows/win32/winauto/uiauto-uiautomationoverview">UI Automation</a>库</li>
<li>使用python的某些库</li>
<li>使用自己写的驱动，实现硬件级别模拟</li>
<li>…</li>
</ul>
<p>这里，我们选择了第一种使用WIN API的方法，原因有两个：</p>
<ul>
<li>相对比较简单直接，不需要进行内核编程，开发效率高</li>
<li>能力相对较强，能够处理绝大多数场景</li>
</ul>
<h2 id="初次尝试的折戟沉沙"><a href="#初次尝试的折戟沉沙" class="headerlink" title="初次尝试的折戟沉沙"></a>初次尝试的折戟沉沙</h2><p>我们知道，Windows的应用程序基于的是消息机制。什么是消息机制呢？MSDN上有一段令我印象深刻的解说：</p>
<blockquote>
<p>Unlike MS-DOS-based applications, Windows-based applications are event-driven. They do not make explicit function calls (such as C run-time library calls) to obtain input. Instead, they wait for the system to pass input to them.</p>
</blockquote>
<p>每个Windows App的<strong>GUI线程</strong>都有一个<strong>消息队列</strong>，至于<strong>GUI线程</strong>是什么，我没有再MSDN上查到明确说法，个人认为是调用了<strong>CreateWindow</strong>的线程。</p>
<p>应用程序使用<strong>GetMessage</strong>函数从自己的消息队列中取出消息，使用<strong>DispatchMessage</strong>将消息传给对应的WindowProc，使用<strong>WaitMessage</strong>函数等待外部传入消息。</p>
<p>外部向应用程序发送消息，有两个办法：</p>
<ol>
<li><p>使用PostMessage()函数，将一个消息压入某个窗口对应线程的消息队列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">PostMessageA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND   hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">UINT   Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用SendMessage()函数，直接调用某个窗口的WindowProc。</p>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT <span class="title">SendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">HWND   hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">UINT   Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>我们一向是实践第一，马上在写代码的时候发现了盲点：如何得到那个<strong>HWND</strong>类型的窗口句柄呢？这就要救助于FindWindow()函数了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HWND <span class="title">FindWindowA</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpClassName,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPCSTR lpWindowName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>就差一点点了！可是又如何得到主窗口的ClassName和WindowName呢？</p>
<p>这里介绍一个工具，就是大名鼎鼎的spy++.</p>
<p>我们可以在vs2019的工具里直接使用它：</p>
<p><img src="https://pic.downk.cc/item/5e49095348b86553eed809e1.png" alt="1"></p>
<p>通过这个工具，我们就可以得到WA2主窗口的ClassName和WindowName了：</p>
<p><img src="https://pic.downk.cc/item/5e490a0748b86553eed82f5f.png" alt="2"></p>
<p><img src="https://pic.downk.cc/item/5e490a0748b86553eed82f61.png" alt="3"></p>
<p>使用Spy++工具，我们还可以得知这个窗口所有的消息，进而得知鼠标点击的坐标：</p>
<p><img src="https://pic.downk.cc/item/5e490b2348b86553eed86a17.png" alt="4"></p>
<p>注：这里的坐标是窗口坐标，也就是相对于这个窗口左上角的坐标。</p>
<p>那么，我们只要向这个窗口发送LBUTTONDOWN和LBUTTONUP消息，不就可以模拟鼠标的行为了吗？</p>
<p>写出以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !PostMessage(main_window, WM_LBUTTONDOWN, wparam, lparam) ) &#123;</span><br><span class="line">   OnCriticalError(<span class="string">&quot;Post Down fail&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Sleep(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">wparam = <span class="number">0</span>;</span><br><span class="line">lparam = MAKELPARAM(<span class="number">600</span>, <span class="number">376</span>);</span><br><span class="line"><span class="keyword">if</span> ( !PostMessage(main_window, WM_LBUTTONUP, wparam, lparam) ) &#123;</span><br><span class="line">	OnCriticalError(<span class="string">&quot;Post Up fail&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实验发现，完全没啥用。第一回合，我败下阵来。</p>
<h2 id="分析原因，重整旗鼓"><a href="#分析原因，重整旗鼓" class="headerlink" title="分析原因，重整旗鼓"></a>分析原因，重整旗鼓</h2><p>为什么刚才的尝试失败了呢？我想，这个问题只能向逆向工程里要答案了。</p>
<p>我们研究一下White AlbumCN这个窗口类的WindowProcess。它处理WM_LBUTTONDOWN或者WM_LBUTTONUP消息的代码在哪里呢？</p>
<p><img src="https://pic.downk.cc/item/5e4925c948b86553eede746f.png" alt="6"></p>
<p>呵呵！原来如此！这个函数直接Return 0，根本不处理这个消息！</p>
<p>我感到很迷惑，既然如此，它是如何接收输入的呢？</p>
<p>我们先来看看主消息循环：</p>
<p><img src="https://pic.downk.cc/item/5e4926ba48b86553eedeae70.png" alt="7"></p>
<p>注意被我标红的一条执行路径。被我命名为maybe_handle_click的函数，是这样的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// line 37</span></span><br><span class="line">  GetCursorPos(&amp;Point);</span><br><span class="line">  ScreenToClient(hWnd, &amp;Point);</span><br><span class="line"></span><br><span class="line"><span class="comment">//line 105 - 129</span></span><br><span class="line">    <span class="keyword">if</span> ( !byte_B601DF )</span><br><span class="line">    &#123;</span><br><span class="line">      v21 = GetAsyncKeyState;</span><br><span class="line">      if_leftButtonPress = (GetAsyncKeyState(<span class="number">1</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">      if_rightButtonPress = (GetAsyncKeyState(<span class="number">2</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">LABEL_47:</span><br><span class="line">      byte_B601AB = (v21(<span class="number">4</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">goto</span> LABEL_48;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( if_leftButtonPress )</span><br><span class="line">    &#123;</span><br><span class="line">      v22 = GetAsyncKeyState;</span><br><span class="line">      if_leftButtonPress = (GetAsyncKeyState(<span class="number">1</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !if_rightButtonPress &amp;&amp; !byte_B601AB )</span><br><span class="line">      &#123;</span><br><span class="line">        v21 = GetAsyncKeyState;</span><br><span class="line">        if_leftButtonPress = (GetAsyncKeyState(<span class="number">1</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( !if_leftButtonPress )</span><br><span class="line">        &#123;</span><br><span class="line">          if_rightButtonPress = (GetAsyncKeyState(<span class="number">2</span>) &amp; <span class="number">0x8001</span>) != <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span> ( !if_rightButtonPress )</span><br><span class="line">            <span class="keyword">goto</span> LABEL_47;</span><br></pre></td></tr></table></figure>

<p>这个函数里反复调用了一个叫做GetAsyncKeyState的函数，查MSDN，描述如下：</p>
<blockquote>
<p>Determines whether a key is up or down at the time the function is called, and whether the key was pressed after a previous call to GetAsyncKeyState.</p>
</blockquote>
<p>当这个函数的参数为1时，检测的就是鼠标左键。网上的资料还说，这个函数相当底层，基本是检测硬件的。</p>
<p>几乎可以确定，这个函数就是检测输入的。</p>
<p>那么，我们手里还有什么函数，可以在底层注入鼠标消息呢？</p>
<p>有，就是SendInput()，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UINT <span class="title">SendInput</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT    cInputs,</span></span></span><br><span class="line"><span class="function"><span class="params">  LPINPUT pInputs,</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="keyword">int</span>     cbSize</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个函数也工作在底层，相当于直接用键盘/鼠标进行操作。</p>
<h2 id="再次尝试，再次失败"><a href="#再次尝试，再次失败" class="headerlink" title="再次尝试，再次失败"></a>再次尝试，再次失败</h2><p>我们写出以下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (IsIconic(main_window))</span><br><span class="line">&#123;</span><br><span class="line">	ShowWindow(main_window, SW_RESTORE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SetForegroundWindow(main_window)) &#123;</span><br><span class="line">	OnCriticalError(<span class="string">&quot;Set window fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!Inject::EnablePrivilege()) &#123;</span><br><span class="line">	OnCriticalError(<span class="string">&quot;Privilege promt fail&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BeginEvent::SendBeginEvent(main_window);</span><br></pre></td></tr></table></figure>

<p>其中SendBeginEvent()函数定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BeginEvent &#123;</span><br><span class="line">	<span class="keyword">const</span> DWORD beginX = <span class="number">600</span>;</span><br><span class="line">	<span class="keyword">const</span> DWORD beginY = <span class="number">376</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SendBeginEvent</span><span class="params">(HWND main_window)</span> </span>&#123;</span><br><span class="line">		InputInjecter::SendMouseEvent(main_window, beginX, beginY);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> InputInjecter &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SendMouseEvent</span><span class="params">(HWND main_window, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">		POINT p;</span><br><span class="line">		p.x = x;</span><br><span class="line">		p.y = y;</span><br><span class="line"></span><br><span class="line">		ClientToScreen(main_window, &amp;p);</span><br><span class="line">		SetCursorPos(p.x, p.y);</span><br><span class="line"></span><br><span class="line">		LPMOUSEINPUT input = <span class="keyword">new</span> MOUSEINPUT;</span><br><span class="line">		input-&gt;dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTDOWN | MOUSEEVENT_LEFTUP;</span><br><span class="line">		input-&gt;dx = Helper::CalculateAbsoluteCoordinateX(p.x);</span><br><span class="line">		input-&gt;dy = Helper::CalculateAbsoluteCoordinateY(p.y);</span><br><span class="line">		input-&gt;mouseData = <span class="number">0</span>;</span><br><span class="line">		input-&gt;dwExtraInfo = <span class="number">0</span>;</span><br><span class="line">		input-&gt;time = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		INPUT input_seal[<span class="number">1</span>];</span><br><span class="line">		input_seal[<span class="number">0</span>].type = INPUT_MOUSE;</span><br><span class="line">		input_seal[<span class="number">0</span>].mi = *input;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!SendInput(<span class="number">1</span>, input_seal, <span class="keyword">sizeof</span>(INPUT))) &#123;</span><br><span class="line">			OnCriticalError(<span class="string">&quot;Send Down fail&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Sleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结果很诡异，用spy++可以看到消息是正确的，但桌面上的WA2就是纹丝不动。</p>
<p>为啥又失败了？我百思不得其解。</p>
<h2 id="猜测和成功"><a href="#猜测和成功" class="headerlink" title="猜测和成功"></a>猜测和成功</h2><p>我们观察到了两个现象：</p>
<ul>
<li>那个may_be_handle_click函数有很多反复横跳的地方，检测变量更是变来变去，强行分析似乎很麻烦。</li>
<li>玩游戏的实际体验是，按下左键就会触发，而不是抬起时才触发。</li>
</ul>
<p>我们猜想，是不是只注入DOWN的消息，不注入UP的消息，我们就会成功呢？</p>
<p>修改代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input-&gt;dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTDOWN | MOUSEEVENT_LEFTUP;</span><br></pre></td></tr></table></figure>

<p>修改为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">input-&gt;dwFlags = MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_MOVE | MOUSEEVENTF_LEFTDOWN;</span><br></pre></td></tr></table></figure>

<p>结果成功。现在想到这件事，我的脸上仍然会浮现开心的笑容。这就是逆向的魅力所在吧！</p>
<p>现在，我们获得了自动化的“手”，下面，我们要获得自动化的“眼睛”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/16/2020-02-16-white_album-2/" data-id="ckg4mhp1w000h17sbhgvnfc77" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-02-15-speed-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/2020-02-15-speed-2/" class="article-date">
  <time datetime="2020-02-15T00:00:00.000Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/network-speed/">network_speed</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/2020-02-15-speed-2/">谈谈网速（二）不得不首先研究清楚的问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="信号传播的物理学理论"><a href="#信号传播的物理学理论" class="headerlink" title="信号传播的物理学理论"></a>信号传播的物理学理论</h2><p>就我个人来说，我的物理学得很不好，我也懒得处理很多物理上的内容，但是，要理解网速相关的众多内容，对物理中的波至少要有一点感性认识。</p>
<p>我们就说以太网好了。以太网不涉及什么调制的内容，在以太网上传播的就是数字信号，只不过经过了曼彻斯特编码（就是将源信号和时钟异或一下）</p>
<p><img src="https://pic.downk.cc/item/5e48162d48b86553ee92ff32.png" alt="1"></p>
<p>那么，这个信号的传播，究竟是一个什么过程呢？</p>
<p>电信号就是高低变化的电压，以太网的介质(media)就是导线（准确地说，同轴电缆、双绞线等）。那么这样看起来，这个信号的传播似乎是不需要时间的。</p>
<p>何出此言呢？我们考虑一下高中学过的物理或者大学物理课中关于电压的部分，导线的一端电压发生变化，另一端的电压是不是马上就作出与之相符的变化呢？</p>
<p>准确地来说，我个人以前所学过的物理知识，似乎没有处理过这类问题。但前人已经将这件事研究得很清楚了，这就是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Transmission_line">传输线理论</a>。</p>
<blockquote>
<p>In radio-frequency engineering, a transmission line is a specialized cable or other structure designed to conduct alternating current of radio frequency, that is, currents with a frequency high enough that their wave nature must be taken into account.</p>
</blockquote>
<p>这个理论是从麦克斯韦方程推导出来的，我们不需要了解其具体内容，只需要知道一个结论：在传输线上传输的信号，本质是一种电磁波，其波速是一个定值，且等于频率与波长的乘积。</p>
<h2 id="Transmission-Delay-与-Propagation-Delay"><a href="#Transmission-Delay-与-Propagation-Delay" class="headerlink" title="Transmission Delay 与 Propagation Delay"></a>Transmission Delay 与 Propagation Delay</h2><p>稍微知道了一点物理学理论，我们就可以研究一下延迟中的<strong>发送时延（Transmission Delay）</strong>和<strong>传播时延（Propagation Delay）</strong>了。</p>
<p>一般在谈到网卡的作用时，网卡将操作系统的网络buffer中的网络包编码为串行的曼彻斯特码信号，然后发送出去。其实，这个过程的图景并不完全是这样。</p>
<p>网卡连接着传输介质，它做的事情主要就是在接口的INPUT部分“观测”电压，在接口的OUTPUT部分“改变”电压。所谓的“发送”，就是不断地改变OUTPUT口的电压，其改变的频率就是时钟频率，而这正是它发送的电磁波的频率。</p>
<p>电磁波的波速，在同一介质中是一定的。所以传播时延只和介质的种类和长度有关，而发送时延实际上与以太网的速率有关。</p>
<p>如果静下心来认真思考的话，我们不难想到，以太网的速率就是时钟频率的倒数。为什么呢？因为一个时钟发送一个bit。在802.3-1985这份最早的ieee以太网标准中，以太网的速率是10 Mbit/s，而标准也很清晰地说明了标准时钟频率应该为</p>
<p>$$100ns = 1 \times 10 ^ {-7}s = \frac{1}{10000000}$$</p>
<p><img src="https://pic.downk.cc/item/5e489e5448b86553eebc3896.png" alt="2"></p>
<p>所谓的发送时延，其实就是将网络包按照速率发送出去的时间。</p>
<p>这时可能会有一个问题，为什么要把总时延的计算里，为什么要把发送时延和传输时延加起来呢？我们可以这样去想：自第一个bit被一方发送至第一个bit被对方接收的时间($$t_{1}$$)，是<strong>传播时延</strong>；自一个bit被发送至最后一个bit被发送的时间($$ t_{2} $$)，是<strong>发送时延</strong>，总时延应该包括自第一个bit被发送至最后一个bit被接收的时间($$ t_{3} $$)，而显然有：</p>
<p>$$t_{3} = t_{1} + t_{2}$$</p>
<h2 id="以太网的速率"><a href="#以太网的速率" class="headerlink" title="以太网的速率"></a>以太网的速率</h2><p>经过上面的讨论，我们可以知道，以太网的速率，应该是一个定值，与网卡的时钟频率成正比。但是这并不是绝对的。</p>
<ul>
<li>如果一个以太网是使用集线器或总线连接的共享网络，那么它有CMSA/CD机制避免冲突，实际上的速率是标注值除以共享网络的人数。</li>
<li>如果一个以太网不是共享的（比如用交换机连接），那么它的速率和标注值一致。</li>
</ul>
<p>现在的以太网基本都不是共享的，所以，可以认为现在使用的以太网速率都是确定的、是由时钟频率决定的，我们其实并没有什么提高速率的办法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/15/2020-02-15-speed-2/" data-id="ckg4mhp1u000e17sb7hjy0kjt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-02-15-speed-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/15/2020-02-15-speed-1/" class="article-date">
  <time datetime="2020-02-15T00:00:00.000Z" itemprop="datePublished">2020-02-15</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/network-speed/">network_speed</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/15/2020-02-15-speed-1/">谈谈网速（一）序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么要研究网速"><a href="#为什么要研究网速" class="headerlink" title="为什么要研究网速"></a>为什么要研究网速</h2><p>在日常生活中，你有没有遇到过以下情况呢？</p>
<ul>
<li>想看盗版漫画，辛辛苦苦不辞辛劳地找到资源，却发现加载速度奇慢无比，阅读体验极差</li>
<li>想在github上clone一个几MB的项目，输入一行<strong>git clone xxx.git</strong>，喝杯咖啡回来后，git居然仍在以挤牙膏般的速度传输</li>
<li>想用ssh连接到境外远程主机，兴高采烈地在键盘上按下键，却迟迟不出现输出</li>
<li>…</li>
</ul>
<p>以上情况都是我的亲身体验。我这个人有一点不好，那就是遇到不懂的事情，就一定要搞明白其中的道理。这些问题背后的道理是什么？恐怕和“网速”有着千丝万缕的联系。</p>
<h2 id="什么是“网速”"><a href="#什么是“网速”" class="headerlink" title="什么是“网速”"></a>什么是“网速”</h2><p>“网速”这个词，似乎应该是 Network Speed 或者说 Network Rate. 但是，和这些术语不同，这里说的“网速”，其实是一个比较复杂和综合的概念，它描述的我们使用网络服务时的综合速度体验，包含这两个内容：</p>
<ul>
<li>比特率，考虑A主机的一个程序向B主机的一个程序发送一段连续信息。这里的比特率指这段信息的长度（以bit计）除以A程序发送信息到B程序收到信息的时间。</li>
<li>网络延迟，一个包从源站发送到目的站接收需要的时间。</li>
</ul>
<p>必须指出，这两个内容并不是正交的，而是有一定联系的。</p>
<p>我们将上节中所说的问题用这两个内容来规约一下，就是：</p>
<ul>
<li>看漫画问题 – 比特率太低</li>
<li>clone问题 – 比特率太低</li>
<li>ssh问题 – 延迟太高</li>
</ul>
<p>很显然，这两个话题不是很好讨论的，它涉及到计算机网络的方方面面，我们也不打算一一讨论，现在确定了以下的内容：</p>
<ul>
<li>传输延迟与比特率的关系</li>
<li>应用层对比特率的直观认识</li>
<li>以太网的比特率</li>
<li>ISP接入的比特率与限速</li>
<li>丢包与TCP</li>
<li>linux对TCP的实现</li>
<li>TCP性能调优</li>
<li>实现自己的TCP</li>
<li>BBR</li>
</ul>
<p>自问自答一下吧：</p>
<ul>
<li>为啥网络延迟不怎么研究？<ul>
<li>因为这主要和运营商有关，个人搞不出来太大名堂。</li>
</ul>
</li>
<li>这么多话题，要写多长时间呢？<ul>
<li>或许会写很长时间吧！但愿我能把这些坑都填上。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/15/2020-02-15-speed-1/" data-id="ckg4mhp1r000c17sb52cb912p" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-02-14-eap" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/02/14/2020-02-14-eap/" class="article-date">
  <time datetime="2020-02-14T00:00:00.000Z" itemprop="datePublished">2020-02-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/802-11i/">802.11i</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/02/14/2020-02-14-eap/">802.11i 无线网络安全（二）-- 802.1x eap认证</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81eap%E8%AE%A4%E8%AF%81">为什么需要EAP认证</a></li>
<li><a href="#%E6%9C%AC%E6%96%87%E8%A6%81%E6%90%9E%E6%B8%85%E6%A5%9A%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98">本文要搞清楚的主要问题</a></li>
<li><a href="#%E5%AF%B9%E6%95%B4%E4%B8%AA8021x-eap%E8%AE%A4%E8%AF%81%E6%9E%B6%E6%9E%84%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D">对整个802.1x EAP认证架构的简单介绍</a></li>
<li><a href="#%E6%90%AD%E5%BB%BA%E4%BD%BF%E7%94%A8eap%E7%9A%8480211%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C">搭建使用EAP的802.11无线网络</a><ul>
<li><a href="#%E6%90%AD%E5%BB%BAsupplicant">搭建supplicant</a></li>
<li><a href="#%E6%90%AD%E5%BB%BAradius-server">搭建Radius Server</a></li>
<li><a href="#%E6%90%AD%E5%BB%BAap">搭建AP</a></li>
<li><a href="#%E8%AF%B4%E6%98%8E">说明</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%99%E4%B8%AA%E6%97%A0%E7%BA%BF%E7%BD%91%E8%B7%AF">连接到这个无线网路</a><ul>
<li><a href="#%E4%BD%BF%E7%94%A8peap%E6%96%B9%E6%B3%95">使用PEAP方法</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8eap%EF%BC%8Dtls%E6%96%B9%E6%B3%95">使用EAP－TLS方法</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90eap%EF%BC%8Dtls%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B">分析EAP－TLS方法的全过程</a><ul>
<li><a href="#clinet-certificate%E4%B8%8Etls12%E4%B8%AD%E7%9A%84client-certificatecertificate-verify%E5%B8%A7">Clinet Certificate与tls1.2中的Client Certificate、Certificate Verify帧</a></li>
<li><a href="#eap-tls%E6%96%B9%E6%B3%95%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81">EAP-TLS方法如何进行双向认证</a></li>
<li><a href="#eap-tls%E6%96%B9%E6%B3%95%E7%9A%84%E5%8D%8F%E8%AE%AE%E6%A0%88">EAP-TLS方法的协议栈</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5-%E5%8F%91%E9%80%81%E8%BA%AB%E4%BB%BD%E4%BF%A1%E6%81%AF">第一阶段 ：发送身份信息</a></li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5-%E5%8D%8F%E5%95%86eap%E6%96%B9%E6%B3%95">第二阶段 ：协商EAP方法</a></li>
<li><a href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5-eap-tls%E8%BF%87%E7%A8%8B">第三阶段 ：EAP-TLS过程</a></li>
<li><a href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5-eap%E6%88%90%E5%8A%9F%EF%BC%8F%E5%A4%B1%E8%B4%A5">第四阶段 ：EAP成功／失败</a></li>
</ul>
</li>
<li><a href="#eap-tls%E5%A6%82%E4%BD%95%E4%B8%BA80211i%E7%9A%84key-hierarchy%E8%BF%87%E7%A8%8B%E6%8F%90%E4%BE%9Bpmk">EAP-TLS如何为802.11i的Key Hierarchy过程提供PMK</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<h2 id="为什么需要EAP认证"><a href="#为什么需要EAP认证" class="headerlink" title="为什么需要EAP认证"></a>为什么需要EAP认证</h2><p>我们在<a href="!--swig%EF%BF%BC7--">无线网络安全（1）</a>中说过，所谓的“认证”，在802.11i的RSN（或者说，WPA）中有两种方式，一种是<strong>802.1x EAP</strong>认证，一种是<strong>pre-shared-key</strong>认证，而<strong>pre-shared-key</strong>认证直接跳过认证过程，通过“四次握手”(密钥生成与分发)过程，验证<strong>AP</strong>和<strong>STA</strong>对于<strong>PSK</strong>的所有权，是一种相互认证。</p>
<p>但<strong>pre-shared-key</strong>认证有一些缺陷。以我们的无线校园网<strong>SYSU_SECURE</strong>为例，如果采取<strong>pre-shared-key</strong>认证，那么就会遇到很多问题：</p>
<ul>
<li>向一个人分发一份<strong>pre-shared-key</strong>，本意是让一个人使用。但由于密钥生成与分发过程只验证AP和STA对<strong>PSK</strong>的所有权，如果这个人（A）将<strong>PSK</strong>送给了另一个人(B)，那么B也可以用这个<strong>PSK</strong>连接校园网。</li>
<li>更新<strong>PSK</strong>时如何安全地通知全校同学？</li>
</ul>
<p>实际上，如果范围很大的话，我们很难控制<strong>PSK</strong>的传播。在802.11i中引入EAP，就是为了解决大规模无线网络的认证问题。</p>
<h2 id="本文要搞清楚的主要问题"><a href="#本文要搞清楚的主要问题" class="headerlink" title="本文要搞清楚的主要问题"></a>本文要搞清楚的主要问题</h2><ul>
<li>什么是EAP？</li>
<li>使用802.1x EAP认证方法如何产生802.11i需要的PMK?</li>
<li>如何搭建一个WPA2-Enterprise或者说使用802.1x EAP认证方法的无线网络？</li>
<li>EAP-TLS如何进行双向验证？</li>
</ul>
<h2 id="对整个802-1x-EAP认证架构的简单介绍"><a href="#对整个802-1x-EAP认证架构的简单介绍" class="headerlink" title="对整个802.1x EAP认证架构的简单介绍"></a>对整个802.1x EAP认证架构的简单介绍</h2><p>EAP这个东西，是古董。在PPP链路大行其道的时代，EAP就出现了。它最初就是为了解决PPP的认证问题而引入的。对它的具体描述，参见<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3748">rfc3748</a>。EAP叫做“可扩展认证协议”，它只规定了一个壳子，我们可以通过各种方法改造它以适应我们的要求。</p>
<p>而802.1x，是所谓的“基于端口的介质访问控制”ieee标准。什么意思呢？就是说，在客户端没有认证之前，客户端只能通过“被控制的端口”（controlled port）和网络接入点（比如AP、交换机、路由器等等）进行通信。这就说是，在没有认证之前，网络接入点只接受客户端发来的802.1x帧（在以太网里，TYPE字段值为0x888e），其他的一律扔掉。这样一来，客户端虽然在物理上可以和网络接入点进行通信，但是只能进行认证而不能和别的终端进行通信。如果客户端进行了认证，那么，客户端就可以从不被控制的端口（uncontrolled port）通信，简单地来说就是可以上网了。这样一来，802.1x就提供了一种在以太网上进行访问控制的方法。</p>
<p>那么，802.1x和EAP的关系是怎么样的呢？这是一个略复杂的问题。我们说，在以太网上，TYPE字段设置为0x888e就代表上层协议是802.1x。而它上层的协议包，被称为EAPOL（EAP over LAN），也就是EAP在Lan上的实现。它的包格式被802.1x规定如下：</p>
<p><img src="https://i.loli.net/2020/02/14/qM7h4IWTSYptlAC.png" alt="1.PNG"></p>
<p>可是令人迷惑的是，EAP协议有自己的包格式：</p>
<p><img src="https://i.loli.net/2020/02/14/5XSJcP9bneWv7LQ.png" alt="2.PNG"></p>
<p>那么，在以太网或者802.11无线网中，使用的包格式究竟是哪一套呢？</p>
<p>答案很简单，这两套都使用。而且这两套包的层次是不同的。简单地说，802.1x的作用是“访问控制”，EAP的作用是“认证”。我们先按下不表，看看这个认证体系的拓扑架构：</p>
<p><img src="https://i.loli.net/2020/02/14/TJhdktbIyjoqQuz.png" alt="3.PNG"></p>
<p>我们发现，在这个架构里，有三个角色：</p>
<ul>
<li>host – 客户</li>
<li>Network Access Server – <strong>NAS</strong>网络接入服务器</li>
<li>Authentication Server – 认证服务器</li>
</ul>
<p>这三个角色的作用和它的名字基本一样。那么，我们发现，在这个体系中，“认证”是委托给认证服务器做的。但认证服务器和客户的通信必须借助<strong>NAS</strong>的转发。而<strong>NAS</strong>转发的包，就是EAP包；客户和<strong>NAS</strong>的通信，是802.1x,或者说是EAPOL包, EAP包被封装在EAPOL包中；<strong>NAS</strong>和认证服务器的通信，是RADIUS包。实际上，整个协议栈可以如下示意：</p>
<p><img src="https://slideplayer.com/slide/4802754/15/images/19/Through+the+protocol+stack.jpg" alt="4.PNG"></p>
<p>实际上，如果仔细看802.1x-2010的话, 当EAPOL包的TYPE字段被设置为0时, 这个包的PacketBody字段就会是一个EAP包:</p>
<p><img src="https://i.loli.net/2020/02/14/GN7PgKzLWIib3fZ.png" alt="5.PNG"></p>
<p>我们用wireshark抓包也会看到这一点:</p>
<p><img src="https://i.loli.net/2020/02/14/IcFwZpj9BxTDl3b.png" alt="6.PNG"></p>
<p>为什么说EAP是用来认证的?因为EAP包是客户和认证服务器用来作认证通信的。理解了这一点，让我们暂时放下理论，先搭建一套使用EAP的802.11无线网络吧。</p>
<h2 id="搭建使用EAP的802-11无线网络"><a href="#搭建使用EAP的802-11无线网络" class="headerlink" title="搭建使用EAP的802.11无线网络"></a>搭建使用EAP的802.11无线网络</h2><p>根据802.1x认证的构成要件，这里的无线网络至少要由三个部分：</p>
<ul>
<li>suplicant – 客户</li>
<li>Access Point – 无线接入点<strong>AP</strong></li>
<li>Radius Server – Radius 服务器</li>
</ul>
<p>需要指出的是，这里的<strong>AP</strong>是“胖AP”，也就是说，它既担任接入点，又担任DHCP Server和Radius client，如果将AP换做所谓的“瘦AP”，那么，这里会有四个部分。</p>
<h3 id="搭建supplicant"><a href="#搭建supplicant" class="headerlink" title="搭建supplicant"></a>搭建supplicant</h3><p>现在的各种操作系统都有直接连接EAP方法的无线网的组件，这一步不用自己做什么。</p>
<h3 id="搭建Radius-Server"><a href="#搭建Radius-Server" class="headerlink" title="搭建Radius Server"></a>搭建Radius Server</h3><p>这里我们使用了<a target="_blank" rel="noopener" href="https://freeradius.org/">FreeRadius</a>这个开源的Radius服务器，在ubuntu18.04 LTS上搭建了Radius服务器。</p>
<p>配置步骤如下：</p>
<ol>
<li><p>在终端中输入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install freeradius</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装完成后，打开服务器，修改/etc/freeradius/users，添加一个用户，并使用radtest进行测试：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo bob Cleartext-Password := &quot;hello&quot; &gt;&gt; /etc/users</span><br><span class="line">sudo freeradus -X</span><br><span class="line">radtest bob hello 127.0.0.1 0 testing123</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试成功后，切换到/etc/freeradius/3.0/certs目录，修改client.cnf，填写自己在users中的用户相关信息（比如CN = bob），并使用make工具产生证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim client.cnf</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改/etc/freeradius/3.0/mods-enabled/eap文件，将ca证书改成刚刚修改好的证书：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ca_file = /etc/freeradius/3.0/certs/ca.pem</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改/etc/freeradius/3.0/client.conf文件，新建一个clinet，准备与ap连接</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client 192.168.1.1 &#123;</span><br><span class="line">  ipaddr = 192.168.1.1</span><br><span class="line">  proto = *</span><br><span class="line">  secret = testing123</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将此服务器和AP连接到同一个网络，这里我使用的是虚拟机，所以新建了一块桥接网卡。</p>
</li>
</ol>
<p>至此，Radius服务器就建好了，下面搭建AP。</p>
<h3 id="搭建AP"><a href="#搭建AP" class="headerlink" title="搭建AP"></a>搭建AP</h3><p>这里我们采用了我家的家用路由器。</p>
<ul>
<li>型号：ASUS RT-AC87R</li>
<li>固件版本：华硕原生固件 3.0.0.4.376_2769-g1bb5fac</li>
</ul>
<p>配置步骤如下：</p>
<ol>
<li>在<strong>无线网络-一般设置</strong>中将2.4G的验证方式设置为WPA-Enterprise。</li>
<li>在<strong>无线网络-Radius设置</strong>中，填写Radius服务器地址、端口、密码等信息。</li>
</ol>
<p>至此，AP配置完成。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>freeradius是一个很强的服务器，如果搭建到了这里，它的默认设置就几乎可以支持市面上常见的所有EAP方法，包括EAP-MD5、EAP-TLS、EAP-TTLS、EAP-PEAP等。</p>
<h2 id="连接到这个无线网路"><a href="#连接到这个无线网路" class="headerlink" title="连接到这个无线网路"></a>连接到这个无线网路</h2><h3 id="使用PEAP方法"><a href="#使用PEAP方法" class="headerlink" title="使用PEAP方法"></a>使用PEAP方法</h3><p>在Windows平台和ios平台下，直接连接上面的无线网络，操作系统会默认使用PEAP方法。在GUI中输入用户名和密码即可。</p>
<h3 id="使用EAP－TLS方法"><a href="#使用EAP－TLS方法" class="headerlink" title="使用EAP－TLS方法"></a>使用EAP－TLS方法</h3><p>为什么要使用EAP－TLS方法呢？因为PEAP方法会第一阶段会创造tls信道，第二阶段分析起来不太方便。我们对TLS也相当熟悉，所以决定使用EAP-TLS方法进行分析整个连接过程。如果要分析，就必须先连接上。这里使用Windows平台进行连接。</p>
<p>在上一步的配置中，freeradius会产生一堆证书：</p>
<p><img src="https://i.loli.net/2020/02/14/h2xVkQqc7KiEOUT.png" alt="7.PNG"></p>
<p>将clinet.p12复制一份到windows平台下，双击，进行安装。注意选择“标记为可导出的证书”选项。</p>
<p><img src="https://i.loli.net/2020/02/14/brgWiSUOe2FK6nX.png" alt="8.PNG"></p>
<p>然后在控制面版中新建一个无线连接：</p>
<p><img src="https://pic.downk.cc/item/5e46481848b86553ee0f20df.png"></p>
<p>填写相关参数，并选择<strong>下一步</strong>：</p>
<p><img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e2.png"></p>
<p>选择<strong>更改连接设置</strong>：</p>
<p><img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e4.png"></p>
<p>在这个界面需要更改两个内容：</p>
<p><img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e6.png"></p>
<ol>
<li><p>在<strong>高级设置</strong>中将<strong>指定身份验证模式</strong>改为<strong>用户身份验证</strong></p>
<p> <img src="https://pic.downk.cc/item/5e4647ff48b86553ee0f1597.png" alt="14.png"></p>
</li>
<li><p>在<strong>选择网络身份验证方法</strong>中选择<strong>Microsoft智能卡或其他证书</strong>，并点击<strong>设置</strong></p>
<p> 在<strong>设置</strong>页面取消对<strong>通过验证证书验证服务器的身份</strong>的选择：</p>
<p> <img src="https://pic.downk.cc/item/5e46481848b86553ee0f20e8.png"></p>
</li>
</ol>
<p>然后，在GUI中直接连接。</p>
<h2 id="分析EAP－TLS方法的全过程"><a href="#分析EAP－TLS方法的全过程" class="headerlink" title="分析EAP－TLS方法的全过程"></a>分析EAP－TLS方法的全过程</h2><p>在刚才的连接过程中，我们可以看到，整个设置很繁琐。这是因为EAP-TLS使用了<strong>Client Certificate</strong>来验证客户端的有效性。</p>
<h3 id="Clinet-Certificate与tls1-2中的Client-Certificate、Certificate-Verify帧"><a href="#Clinet-Certificate与tls1-2中的Client-Certificate、Certificate-Verify帧" class="headerlink" title="Clinet Certificate与tls1.2中的Client Certificate、Certificate Verify帧"></a>Clinet Certificate与tls1.2中的Client Certificate、Certificate Verify帧</h3><p>在<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3748">rfc5246</a>中，定义了一个我们在TLS系列中没有分析过的帧 – <strong>clinet certificate</strong>. 这一帧是在收到服务器发来的<strong>Certificate Request</strong>帧后，客户端必须发送的帧。服务端通过这一帧来验证客户端的的身份。然而，在https的世界里，我们很少使用这个东西。因为http对应的主要是web应用，web应用一般不会要求验证用户的身份，即使真的要求，基于https的身份验证也会让使用http的用户无法登录，还有部署麻烦等劣势，所以用的很少，我们在之前的TLS文章中也没有研究。</p>
<p>这一帧的结构如下：</p>
<blockquote>
<p>Client certificates are sent using the Certificate structure defined in Section 7.4.2.</p>
</blockquote>
<p>7.4.2是Server Certificate的定义，所以这里也和Server Certificate一样，是直接<strong>明文</strong>发过去的。</p>
<p>回忆TLS中对于Server Certificate的验证，我们会发现，如果只发送Client Certificate帧，是不能验证客户端对于这个证书的所有权的，验证所有权的关键，应该是私钥。客户端对证书的所有权，是Certificate Verify帧验证的。</p>
<p>这一帧的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    digitally-<span class="keyword">signed</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        opaque handshake_messages[handshake_messages_length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; CertificateVerify;</span><br></pre></td></tr></table></figure>

<p>handshake_messages指的是从握手开始到握手结束的所有消息的连接，而digitally-signed正是指客户端需要用私钥加密这些消息。这样一来，服务端端用证书中的公钥解密，判断一下是否和自己存储/打的哈希一致，就可以验证客户端对证书的所有权了。</p>
<h3 id="EAP-TLS方法如何进行双向认证"><a href="#EAP-TLS方法如何进行双向认证" class="headerlink" title="EAP-TLS方法如何进行双向认证"></a>EAP-TLS方法如何进行双向认证</h3><ul>
<li>客户端认证服务端：通过tls的密钥交换，是标准的tls方法，和一般使用的tls一致。</li>
<li>服务端认证客户端：通过Client Certificate和Certificate Verify消息，是标准的tls方法，但不常用。</li>
</ul>
<h3 id="EAP-TLS方法的协议栈"><a href="#EAP-TLS方法的协议栈" class="headerlink" title="EAP-TLS方法的协议栈"></a>EAP-TLS方法的协议栈</h3><p>既然这个方法名字叫做EAP-TLS，那么就是使用TLS来进行双向认证的。这里有个问题，那就是我们现在无法使用IP协议和TCP协议，如何使用TLS呢？这里采取的方法是，将TLS的帧封装在EAP协议中。</p>
<p>用wireshark抓包，可以很清晰地看出这个情况：</p>
<p><img src="https://pic.downk.cc/item/5e4650f348b86553ee1226df.png"></p>
<p>下面我们来分析认证的全过程。</p>
<h3 id="第一阶段-：发送身份信息"><a href="#第一阶段-：发送身份信息" class="headerlink" title="第一阶段 ：发送身份信息"></a>第一阶段 ：发送身份信息</h3><p>首先需要说明，以下所有的通信都是发生于Radius Server（认证服务器）和STA之间的，AP只是起转发作用。</p>
<p>在做完<strong>NULL　Authentication</strong>之后，STA发送EAPOL_Start帧，表明开始进行802.1x认证：</p>
<p><img src="https://pic.downk.cc/item/5e4684c748b86553ee250255.png"></p>
<p>之后，STA回应AP的Request Identity消息，发送自己的身份信息：</p>
<p><img src="https://pic.downk.cc/item/5e46850f48b86553ee2521c4.png"><br><img src="https://pic.downk.cc/item/5e46850f48b86553ee2521c6.png"></p>
<p>如果身份信息合法，进入下一阶段</p>
<h3 id="第二阶段-：协商EAP方法"><a href="#第二阶段-：协商EAP方法" class="headerlink" title="第二阶段 ：协商EAP方法"></a>第二阶段 ：协商EAP方法</h3><p>AP发送Request-MD5-Challenge消息，要求使用EAP-MD5-Challenge方法：</p>
<p><img src="https://pic.downk.cc/item/5e46859d48b86553ee2562c3.png"></p>
<p>客户端不同意，发送NAK消息，并指出自己想使用EAP-TLS方法：</p>
<p><img src="https://pic.downk.cc/item/5e4685cf48b86553ee257d24.png"></p>
<p><img src="https://pic.downk.cc/item/5e4685cf48b86553ee257d27.png"></p>
<p>AP换用EAP-tls方法，发送Request-eap-tls消息：</p>
<p><img src="https://pic.downk.cc/item/5e4685f548b86553ee25ad82.png"></p>
<p>下面的消息就全部是tls协议帧了。</p>
<h3 id="第三阶段-：EAP-TLS过程"><a href="#第三阶段-：EAP-TLS过程" class="headerlink" title="第三阶段 ：EAP-TLS过程"></a>第三阶段 ：EAP-TLS过程</h3><p>eap-tls由rfc2716定义，现在通行的是<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2548">rfc5216</a>。</p>
<p>成功的eap-tls整个过程大概有三种情况，一种是标准的tls握手过程，另一种是标准的tls快速恢复握手过程，还有一种是支持privacy的两次握手。这里只观察到了第一种，故只讨论第一种。</p>
<p>此过程和一般的tls握手过程主要有以下区别：</p>
<ul>
<li>服务端发送Certificate Request消息，客户端回应client Certificate 和 Certificate Verify消息。</li>
<li>同时进行EAP-TLS Key Hierarchy过程。注意，这并不是说TLS的Key Hierarchy过程就不进行了，而是说另外地进行其他的Key Hierarchy过程。由于握手过程的最后一帧finished是加密的，所以标准的TLS的Key Hierarchy也是必须的。</li>
</ul>
<p>抓包结果如下：</p>
<p><img src="https://pic.downk.cc/item/5e46865748b86553ee260de9.png"></p>
<h3 id="第四阶段-：EAP成功／失败"><a href="#第四阶段-：EAP成功／失败" class="headerlink" title="第四阶段 ：EAP成功／失败"></a>第四阶段 ：EAP成功／失败</h3><p>如果成功，AP向STA发送EAP　Success消息，如果失败，AP向STA发送EAP Failure消息。</p>
<p><img src="https://pic.downk.cc/item/5e46868248b86553ee262794.png"></p>
<h2 id="EAP-TLS如何为802-11i的Key-Hierarchy过程提供PMK"><a href="#EAP-TLS如何为802-11i的Key-Hierarchy过程提供PMK" class="headerlink" title="EAP-TLS如何为802.11i的Key Hierarchy过程提供PMK"></a>EAP-TLS如何为802.11i的Key Hierarchy过程提供PMK</h2><p>我们知道，在802.11i无线网络中，Key Hierachy的起点是<strong>PMK</strong>(Pairwise Master Key)。如果使用<strong>PSK</strong>方法，那么<strong>PMK</strong>就是<strong>PSK</strong>。如果使用EAP方法呢？802.11-2007并没有说得很明白，而是使用了May这样的词，但从“密码”到<strong>PSK</strong>所使用的哈希函数也是may，所以还是很有参考价值的。它指向了一个很奇怪的记号：<strong>MS-MPPE-Recv-Key</strong>。这个<strong>MS</strong>恐怕指的就是<strong>Microsoft</strong>了，而这个符号实际上来源于PEAP，是PEAP第一阶段（也是用TLS，只不过没有用Cilent Certificate校验客户端）通过Key Hierarchy产生的密钥。</p>
<p>EAP-TLS提供了一种和标准TLS不同的方法，来生成PMK，在rfc-5216的2.3节中被这样定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Key_Material = TLS-PRF<span class="number">-128</span>(master_secret, <span class="string">&quot;client EAP encryption&quot;</span>, client.random || server.random)</span><br><span class="line">MSK = Key_Material(<span class="number">0</span>,<span class="number">63</span>)</span><br><span class="line">EMSK = Key_Material(<span class="number">64</span>,<span class="number">127</span>)</span><br><span class="line">IV = TLS-PRF<span class="number">-64</span>(<span class="string">&quot;&quot;</span>, <span class="string">&quot;client EAP encryption&quot;</span>, client.random || server.random)</span><br><span class="line">Enc-RECV-Key = MSK(<span class="number">0</span>,<span class="number">31</span>) </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Peer to Authenticator Encryption Key</span></span><br><span class="line"><span class="comment">   (MS-MPPE-Recv-Key in [RFC2548]). Also known as the</span></span><br><span class="line"><span class="comment">   PMK in [IEEE-802.11].</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">Enc-SEND-Key = MSK(<span class="number">32</span>,<span class="number">63</span>) </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   Authenticator to Peer Encryption Key</span></span><br><span class="line"><span class="comment">   (MS-MPPE-Send-Key in [RFC2548])</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

<p>为什么<strong>MS-MPPE-Recv-Key</strong>成了事实上的<strong>PMK</strong>呢？这似乎有历史原因，我并没有找到一个解释或是说明。但事实就是这样，我们的好奇心也不必过于旺盛。</p>
<p>这时，所有的问题都解决了吗？确实解决了。但是我们又有了新的问题：tls握手是在Authentication Server和Client之间发生的，AP是如何得到Enc-RECV-Key的呢？下一阶段的Key Hierarchy是AP进行的，它必须得到PMK。</p>
<p>我们仔细研究一下Radius Server发给AP的最后一帧：</p>
<p><img src="https://pic.downk.cc/item/5e4686bc48b86553ee264917.png"></p>
<p>图中确实看到了MS-MPPE-RECV-KEY字段，但为什么长度不是0x22(32byte的Key, 1byte的Id，1byte的length)，而是0x34（52）呢？这是因为它不是明文传的，而是加密+padding后的结果。具体是如何加密的，可以参考<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2548">rfc2548</a>，此处就不赘述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>研究EAP是一件不那么轻松的事，主要原因一是资料少，二是资料基本都是英文的，中文搜索几乎没有什么有用结果。通过写这篇文章、研究这些内容，我已经基本搞清楚了802.11i认证过程的所有过程，不过还有很多坑待填，譬如最后产生的GTK究竟有什么用、如何处理漫游等等问题。不过，相信在不远的将来，我会完全研究清楚这些问题。</p>
<p>最后来谈一谈我在部署过程中所踩的坑。</p>
<ul>
<li>我们必须安装PKCS格式的证书，而不是.crt .pem那样的base64编码的证书（不然私钥无法安装）。</li>
<li>我们必须勾选“允许导出”选项，不然不会使用这张证书。</li>
<li>我们必须设置“用户认证”，不然windows会将我们计算机的主机名在eap identity里传过去。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/02/14/2020-02-14-eap/" data-id="ckg4mhp36001u17sb28fh63tp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2019-12-10-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/2019-12-10-find/" class="article-date">
  <time datetime="2019-12-10T00:00:00.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/12/10/2019-12-10-find/">数据结构 -- 查找 -- 笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">查找的基本定义</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">查找算法的分析和设计</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">顺序查找算法</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二分查找算法与二叉查找树</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">分块查找</a></li>
<li><a href="#%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">堆/优先队列</a><ul>
<li><a href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0">堆的概念与实现</a></li>
<li><a href="#%E5%A0%86%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88">堆可以用来做什么？</a></li>
</ul>
</li>
<li><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">哈希表的定义</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></li>
<li><a href="#%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86">碰撞处理</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0----%E6%88%91%E5%AE%9E%E7%8E%B0%E7%9A%84c%E7%89%88%E6%9C%AC">哈希表的实现 – 我实现的c++版本</a></li>
<li><a href="#ruby%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0">Ruby中的哈希表实现</a><ul>
<li><a href="#sttable-%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">st_table 的哈希函数</a></li>
<li><a href="#sttable%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86">st_table的碰撞处理</a></li>
<li><a href="#sttable%E7%9A%84%E6%89%A9%E5%AE%B9">st_table的扩容</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一章，我们学习了查找这种基本操作和堆、散列表这两种非常重要的数据结构。<br>本笔记主要完成了以下工作：</p>
<ul>
<li>总结了关于查找的各种知识点</li>
<li>用ruby语言实现了一个简单的堆模块(这里的模块指module，是ruby中MIX_IN思想的主要实现模式，下面会做简短介绍)，并进行了简单测试</li>
<li>用C++语言实现了一个简单的哈希表，并进行了简单测试</li>
<li>讨论了ruby中哈希表的实现</li>
<li>讨论了stl中std::find, std::binary_search等函数的实现</li>
</ul>
<h2 id="查找的基本定义"><a href="#查找的基本定义" class="headerlink" title="查找的基本定义"></a>查找的基本定义</h2><p>查找也可以视为搜索，wikipedia对搜索的定义是：</p>
<blockquote>
<p>在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题域的搜索空间中计算的信息。<br>其实简单来说，查找就是“找东西”。</p>
</blockquote>
<p>而我们要找的“东西”，严格来说应该叫做“关键字”，或者更学术一些，叫做“键”。找到“键”之后，如果存在一个“键-值映射”，就可以得到其“值”。</p>
<h2 id="查找算法的分析和设计"><a href="#查找算法的分析和设计" class="headerlink" title="查找算法的分析和设计"></a>查找算法的分析和设计</h2><p>查找算法实际上包含三个层次的问题：</p>
<ol>
<li>在什么数据结构上查找</li>
<li>如何查找</li>
<li>查找的效率如何</li>
</ol>
<h2 id="顺序查找算法"><a href="#顺序查找算法" class="headerlink" title="顺序查找算法"></a>顺序查找算法</h2><p>顺序查找是最朴素的查找，可以用在各种线性表上。在MSVC的stl中，我们有std::find函数实现这个算法：</p>
<p><em>以下代码来自&lt;algorithm&gt;</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> _<span class="title">InIt</span> <span class="title">find</span>(_<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span> <span class="comment">// find first matching _Val</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));</span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_Adl_verify_range是检查参数范围是否有效，_Seek_wrapped函数简单来说是把后一个参数的值赋给前一个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">void</span> _<span class="title">Seek_wrapped</span>(_<span class="title">Ty</span>*&amp; _<span class="title">It</span>, _<span class="title">Ty</span>* <span class="title">const</span> _<span class="title">UIt</span>) &#123;</span></span><br><span class="line">    _It = _UIt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际查找过程在_Find_unchecked函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InIt</span> _<span class="title">Find_unchecked</span>(<span class="title">const</span> _<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first matching _Val; choose optimization</span></span><br><span class="line">    <span class="comment">// activate optimization for pointers to (const) bytes and integral values</span></span><br><span class="line">    <span class="keyword">using</span> _Memchr_opt = bool_constant&lt;</span><br><span class="line">        is_integral_v&lt;_Ty&gt; &amp;&amp; _Is_any_of_v&lt;_InIt, <span class="keyword">char</span>*, <span class="keyword">signed</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span>*, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _Find_unchecked1(_First, _Last, _Val, _Memchr_opt&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个函数实际上又调用了_Find_unchecked1函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InIt</span> _<span class="title">Find_unchecked1</span>(_<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, <span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first matching _Val</span></span><br><span class="line">    <span class="keyword">for</span> (; _First != _Last; ++_First) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*_First == _Val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谢天谢地，_Find_unchecked1函数就是主要实现了。我们可以看到整个过程非常简单，就是顺序地查找整个表，如果找到了就退出。</p>
<p>由于模板的存在，在c++中，只要定义了迭代器，一个类就可以使用这个函数进行查找。这也正是对我们抽象描述–查找线性表–的抽象实现。</p>
<p>如果假设等概率，这个算法有</p>
<p>$$ASL_{success} = \frac{n + 1}{2}$$<br>$$ASL_{fail} = n + 1$$</p>
<h2 id="二分查找算法与二叉查找树"><a href="#二分查找算法与二叉查找树" class="headerlink" title="二分查找算法与二叉查找树"></a>二分查找算法与二叉查找树</h2><p>从上面的分析可以看出，顺序查找查找一次的时间复杂度是$O(n)$的。可不可以有更好的效率呢？</p>
<p>如果假定顺序表是有序的，那么思考这样的结论：</p>
<blockquote>
<p>如果待查询的元素大于 $array[floor(n / 2)]$，那么，它一定大于$array[0]$到$array[floor(n / 2) - 1]$的所有元素。</p>
</blockquote>
<p>这样一来，下一次的查询就可以不管这些元素，直接查询$array[floor(n/2) + 1]$到$array[n - 1]$这个区间了。</p>
<p>这实际上已经是一个递归算法了。这个算法的实现很简单，但我们还是来研究一下c++ stl中std::binary_search的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">bool</span> <span class="title">binary_search</span>(</span></span><br><span class="line"><span class="class">    _<span class="title">FwdIt</span> _<span class="title">First</span>, _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span> <span class="comment">// test if _Val equivalent to some element, using operator&lt;</span></span><br><span class="line">    <span class="keyword">return</span> _STD binary_search(_First, _Last, _Val, less&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个binary_search是一个重载的函数，它才是真正用来实现的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE binary_search</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>, <span class="title">class</span> _<span class="title">Pr</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">bool</span> <span class="title">binary_search</span>(</span></span><br><span class="line"><span class="class">    _<span class="title">FwdIt</span> _<span class="title">First</span>, _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, _<span class="title">Pr</span> _<span class="title">Pred</span>) &#123;</span> <span class="comment">// test if _Val equivalent to some element, using _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    _UFirst           = _STD lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));</span><br><span class="line">    <span class="keyword">return</span> _UFirst != _ULast &amp;&amp; !_Pred(_Val, *_UFirst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这看起来并不是直接递归，而是使用了一个lower_bound函数。这个函数是干什么的呢？显然的，lower_bound的意思是下界，它定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE lower_bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>, <span class="title">class</span> _<span class="title">Pr</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> _<span class="title">FwdIt</span> <span class="title">lower_bound</span>(_<span class="title">FwdIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, _<span class="title">Pr</span> _<span class="title">Pred</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first element not before _Val, using _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst                = _Get_unwrapped(_First);</span><br><span class="line">    _Iter_diff_t&lt;_FwdIt&gt; _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> &lt; _Count) &#123; <span class="comment">// divide and conquer, find half that contains answer</span></span><br><span class="line">        <span class="keyword">const</span> _Iter_diff_t&lt;_FwdIt&gt; _Count2 = _Count &gt;&gt; <span class="number">1</span>; <span class="comment">// TRANSITION, VSO#433486</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> _UMid                   = _STD next(_UFirst, _Count2);</span><br><span class="line">        <span class="keyword">if</span> (_Pred(*_UMid, _Val)) &#123; <span class="comment">// try top half</span></span><br><span class="line">            _UFirst = _Next_iter(_UMid);</span><br><span class="line">            _Count -= _Count2 + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Count = _Count2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Seek_wrapped(_First, _UFirst);</span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较麻烦，它返回的是第一个不满足_Pred条件的元素。这里_Pred条件是&lt;，所以返回的是第一个大于等于这个元素的迭代器，<br>然后binary_search函数就用!(_Pred(_Val, *_Ufirst))这个条件来判断是否相等，这相当于构造了<br>$$a &gt;= b$$<br>$$ a &lt;= b$$<br>显然地，只有当$a == b$时，表达式才返回真（吐槽一下，这stl写的太“聪明”了）</p>
<p>在二分查找中，成功查找时的ASL为：<br>$$\sum{i * P(i)} = 1/n*( \sum_{1}^{floor(log(n))}{i * 2^{i}} + ceil(log(n)) * (n - floor(log(n))))$$<br>这个式子过于繁琐，我们假设它的二叉判定树为满二叉树，可以得到：<br>$${n - 1}/{n} * log(n + 1) - 1$$</p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找采用了块间有序，块内无序的基本思想，建立一个索引表记录块内的最大值或最小值，然后先查索引表，找到对应的块，然后再到块中查询。</p>
<p>stl中的deque实现有这种思想的影子。</p>
<h2 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆/优先队列"></a>堆/优先队列</h2><h3 id="堆的概念与实现"><a href="#堆的概念与实现" class="headerlink" title="堆的概念与实现"></a>堆的概念与实现</h3><p>堆这个词来自于heap。我们最先学习到的heap，指的是C程序运行时环境的一部分–内存动态分配器及其分配的空间，我们在使用malloc函数、new函数（new实际上是一个函数）时都要用到它来分配空间。</p>
<p>但是这里的heap，指的是一种特殊的数据结构，它具有以下特点：</p>
<ul>
<li>分为小顶堆和大顶堆</li>
<li>对自$0$至$floor(n/2) - 1$的元素$heap[i]$有<br>  $$heap[i] &lt;= heap[2i + 1]$$<br>  $$heap[i] &lt;= heap[2i + 2]$$</li>
</ul>
<p>其实，第二个特点表明堆可以化为一颗二叉树，这颗二叉树的父亲节点都大于它的子节点。</p>
<p>我们这里用ruby语言实现了一个简单的堆：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">BinaryHeapable</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_to_heap</span> <span class="title">element</span></span></span><br><span class="line">    target = <span class="keyword">self</span>.length</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">self</span>[target / <span class="number">2</span>] &lt; element &amp;&amp; target != <span class="number">0</span></span><br><span class="line">      <span class="keyword">self</span>[target] = <span class="keyword">self</span>[target/<span class="number">2</span>]</span><br><span class="line">      target /= <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">self</span>[target] = element</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove_from_heap</span></span></span><br><span class="line">    ret = <span class="keyword">self</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">self</span>[<span class="number">0</span>] = <span class="keyword">self</span>[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">self</span>.pop</span><br><span class="line">    heap_construct <span class="number">0</span></span><br><span class="line">    ret</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert_to_heap</span></span></span><br><span class="line">    i = <span class="keyword">self</span>.length / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span></span><br><span class="line">      heap_construct i</span><br><span class="line">      i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">heap_construct</span> <span class="title">target</span></span></span><br><span class="line">    what = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> target * <span class="number">2</span> + <span class="number">1</span> &lt; <span class="keyword">self</span>.length</span><br><span class="line">      <span class="keyword">if</span> target * <span class="number">2</span> + <span class="number">2</span> &lt; <span class="keyword">self</span>.length</span><br><span class="line">        what = <span class="keyword">self</span>[target * <span class="number">2</span> + <span class="number">1</span>] &gt; <span class="keyword">self</span>[target * <span class="number">2</span> + <span class="number">2</span>] ? target * <span class="number">2</span> + <span class="number">1</span> : target * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        what = target * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">break</span> <span class="keyword">if</span> <span class="keyword">self</span>[target] &gt; <span class="keyword">self</span>[what]</span><br><span class="line">      temp = <span class="keyword">self</span>[target]</span><br><span class="line">      <span class="keyword">self</span>[target] = <span class="keyword">self</span>[what]</span><br><span class="line">      <span class="keyword">self</span>[what] = temp</span><br><span class="line">      target = what</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    what</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>ruby 中的module是mix-in思想的载体。只要我们让一个类include这个模块，这个类就获得了“堆化”的能力。特别地，ruby的数组被封装为Array类，而所有的自带类都是可以修改的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="keyword">include</span> BinaryHeapable</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以按照以下方法使用数组：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>].convert_to_heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> arr.length != <span class="number">0</span></span><br><span class="line">  pp arr.remove_from_heap</span><br><span class="line">  pp arr</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这段代码会打出：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>在上面的代码中我们看到，堆只需要实现一个操作，就可以搞定建堆和取出堆顶。</p>
<p>这个操作是什么呢？就是如下的操作：</p>
<p>假设一个堆节点的左子树与右子树均已经满足堆序，把以这个堆节点为根的子树调整成堆序。</p>
<p>这个操作实现起来很简单，具体可参加代码。</p>
<p>实现了这个操作后，</p>
<ul>
<li>建堆就是自$floor(n/2) - 1$至$0$调用这个操作；</li>
<li>取出堆顶就是先将堆顶缓存，再将堆尾和堆顶交换，再对堆顶调用这个操作。</li>
</ul>
<h3 id="堆可以用来做什么？"><a href="#堆可以用来做什么？" class="headerlink" title="堆可以用来做什么？"></a>堆可以用来做什么？</h3><p>堆可以在$O(log(n))$的时间复杂度内完成取出最大/最小元素并调整，这一特性可以作以下用途：</p>
<ul>
<li>堆排序</li>
<li>堆优化Dijkstra和Prim算法</li>
<li>霍夫曼树的实现</li>
<li>etc</li>
</ul>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h3><p>散列表，又称哈希表，是一种极为重要的数据结构。</p>
<p>为什么极其重要呢？因为</p>
<ul>
<li>上文提到的ruby，其内部数据结构有很大一部分是用散列表实现的。</li>
<li>散列表可以用来建立映射，例如把一个字符串映射到一个整数上，这对某些情况是极为有用的(例如图结构笔记中实现的IndexMapping类)。</li>
</ul>
<p>散列表的定义为：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>首先必须明确，这里的哈希函数和密码学中的哈希函数实质是一样的，都是一个映射：</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p>
</blockquote>
<p>但是，这里的哈希函数和密码学中的哈希函数侧重点是不一样的：</p>
<p>密码学中的哈希函数主要要求两个性质：</p>
<ol>
<li>均匀性，所有的输出是<em>等概率</em>的</li>
<li>唯一性，要求单射，即是说不能存在$a,b$，使得$f(a) == f(b)$</li>
</ol>
<p>高效性（速度）虽然很重要，但远远没有上面两条重要</p>
<p>而这里的哈希函数则要求高效性，因为我们访问哈希表中的元素可能是很频繁的。</p>
<p>所以密码学中的哈希函数用在这里是不太合适的。</p>
<p>教师讲述了6种方法，均以整数为键：</p>
<ol>
<li>直接定址法(Identity hash function)，找一个整数到整数的线性变换</li>
<li>折叠法(Folding)，将整数分为几个部分，每个部分都是目标长度的倍数（最后一部分可以小于目标长度），然后将这几部分作运算（加、移位、异或等等），得到结果之后取目标长度位结果。<ul>
<li>密码学哈希算法多与这个方法类似</li>
</ul>
</li>
<li>平方取中法(Mid-squares)，先平方，然后取中间的目标长度位</li>
<li>除数余留法（Division hashing），直接取模</li>
<li>代数编码法（Algebraic coding），用数字的不同位作变换。</li>
<li>随机数法，不解释。</li>
</ol>
<h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>如果发生了碰撞，也即是说，存在$a,b$，使得$f(a) == f(b)$，那么就需要进行处理，这大致有四种办法：</p>
<ol>
<li>开放定址法<ul>
<li>线性探测法</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区法<br>具体讨论略。</li>
</ol>
<h3 id="哈希表的实现-–-我实现的c-版本"><a href="#哈希表的实现-–-我实现的c-版本" class="headerlink" title="哈希表的实现 – 我实现的c++版本"></a>哈希表的实现 – 我实现的c++版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hashtable.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_KEY char *</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_VALUE char *</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MD5 md5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOT_FIND NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_NOT_FIND -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">uint64_t</span> <span class="params">(*HASH_FUNC)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">deleteFrom</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">findByKey</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TYPE_VALUE <span class="title">getValueByKey</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkHashTableNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    LinkHashTableNode *next;</span><br><span class="line">    LinkHashTableNode(T value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedHashTable</span> :</span> <span class="keyword">public</span> HashTable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">deleteFrom</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TYPE_VALUE <span class="title">getValueByKey</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    LinkedHashTable(uint value, HASH_FUNC hashFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">findByKey</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">uint64_t</span>(TYPE_KEY)&gt; hash;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LinkHashTableNode&lt;TYPE_VALUE&gt; *&gt; nodePool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hashtable.cpp */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./hashtable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;md5.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LinkedHashTable::LinkedHashTable(uint size, HASH_FUNC hashFunction) : nodePool(size, <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hash = hashFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">LinkedHashTable::findByKey</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash_value = <span class="keyword">this</span>-&gt;hash(key);</span><br><span class="line">    hash_value = hash_value % <span class="keyword">this</span>-&gt;nodePool.size();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;nodePool[hash_value] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NUM_NOT_FIND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedHashTable::insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash_value = <span class="keyword">this</span>-&gt;hash(<span class="built_in">pair</span>.first);</span><br><span class="line">    hash_value = hash_value % <span class="keyword">this</span>-&gt;nodePool.size();</span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> LinkHashTableNode&lt;TYPE_VALUE&gt;(<span class="built_in">pair</span>.second);</span><br><span class="line">    new_node-&gt;next = <span class="keyword">this</span>-&gt;nodePool[hash_value];</span><br><span class="line">    <span class="keyword">this</span>-&gt;nodePool[hash_value] = new_node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedHashTable::deleteFrom</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hash_value = <span class="keyword">this</span>-&gt;findByKey(key);</span><br><span class="line">    <span class="keyword">if</span> (hash_value == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> begin = <span class="keyword">this</span>-&gt;nodePool[hash_value];</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodePool[hash_value] = begin-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> begin;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TYPE_VALUE <span class="title">LinkedHashTable::getValueByKey</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hash_value = <span class="keyword">this</span>-&gt;findByKey(key);</span><br><span class="line">    <span class="keyword">if</span> (hash_value == NUM_NOT_FIND)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NOT_FIND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;nodePool[hash_value]-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实现了一个很简单的哈希表，采用链地址法进行碰撞处理，采用MD5（这是一个密码学哈希函数）作为哈希函数。</p>
<h3 id="Ruby中的哈希表实现"><a href="#Ruby中的哈希表实现" class="headerlink" title="Ruby中的哈希表实现"></a>Ruby中的哈希表实现</h3><p>我们实现的哈希表，玩具色彩浓厚，特别是直接采用MD5算法这种愚蠢行为，每次查询时，都需要做至少64轮循环，效率是很差的。</p>
<p>所以，本笔记的最后一部分就集中精力来讨论一个工业级哈希表 – ruby中的哈希表。</p>
<p>ruby中的哈希表使用为:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;haha&quot;</span>, <span class="symbol">:b</span> =&gt; <span class="string">&quot;hahaha&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这个数据结构在ruby程序中，使用得特别广泛、特别频繁。如果没有一个优秀的内部实现，ruby程序的性能将会受到很大影响。</p>
<p>笔记篇幅所限，这里不能完整地讨论ruby哈希表底层实现ruby/st.c中1000多行代码的全部内容。这里仅仅讨论一些最重要、和我们所学习内容关系最大的内容。</p>
<p><strong>下面所称 st_table 指的就是ruby内部的哈希表</strong></p>
<h4 id="st-table-的哈希函数"><a href="#st-table-的哈希函数" class="headerlink" title="st_table 的哈希函数"></a>st_table 的哈希函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 537行 */</span></span><br><span class="line">    hash_val = do_hash(key, table);</span><br></pre></td></tr></table></figure>

<p>上面这段代码表明哈希函数就是do_hash.我们来看一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 88行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_hash(key,table) (st_index_t)(*(table)-&gt;type-&gt;hash)((key))</span></span><br></pre></td></tr></table></figure>

<p>这段代码似乎不是很好理解，我们来一点点地看：</p>
<p>首先这是一个宏定义，传入两个参数key和table，给出一个值，其类型为st_index_t，也就是哈希表的具体位置（数组下标）</p>
<p>然后来看具体的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(table)-&gt;type-&gt;hash)((key))</span><br></pre></td></tr></table></figure>

<p>这个语法其实是一个函数调用。(table)-&gt;type-&gt;hash是一个函数指针，指向hash函数，key是其参数。</p>
<p>那么想要找到真正的哈希函数，就必须要找到初始化时这个table-&gt;type-&gt;hash被赋了什么值：</p>
<p>哈希表的初始化有些复杂，但是为了讨论的方便还是介绍一下：</p>
<p>首先，所有的初始化都最终被转发到这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_table_with_size(<span class="keyword">const</span> struct st_hash_type *type, <span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<p>然后实际使用时有三种初始化方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_numtable_with_size(<span class="keyword">st_index_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> st_init_table_with_size(&amp;type_numhash, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_strtable_with_size(<span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_strcasetable_with_size(<span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<p>我们这里只研究第一种st_init_numtable_with_size。这一种看名字就知道是整数对整数的映射。<br>它传入了一个type_numhash，这看起来是一个全局常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> type_numhash st_hashtype_num</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> <span class="title">st_hashtype_num</span> = &#123;</span></span><br><span class="line">    st_numcmp,</span><br><span class="line">    st_numhash,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，整数对整数的映射实际上应该调用到st_numhash这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 1666 - 1683行 */</span></span><br><span class="line"><span class="keyword">st_index_t</span></span><br><span class="line">st_numhash(<span class="keyword">st_data_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This hash function is lightly-tuned for Ruby.  Further tuning</span></span><br><span class="line"><span class="comment">     * should be possible.  Notes:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - (n &gt;&gt; 3) alone is great for heap objects and OK for fixnum,</span></span><br><span class="line"><span class="comment">     *   however symbols perform poorly.</span></span><br><span class="line"><span class="comment">     * - (n &gt;&gt; (RUBY_SPECIAL_SHIFT+3)) was added to make symbols hash well,</span></span><br><span class="line"><span class="comment">     *   n.b.: +3 to remove ID scope, +1 worked well initially, too</span></span><br><span class="line"><span class="comment">     * - (n &lt;&lt; 3) was finally added to avoid losing bits for fixnums</span></span><br><span class="line"><span class="comment">     * - avoid expensive modulo instructions, it is currently only</span></span><br><span class="line"><span class="comment">     *   shifts and bitmask operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">st_index_t</span>)((n&gt;&gt;(RUBY_SPECIAL_SHIFT+<span class="number">3</span>)|(n&lt;&lt;<span class="number">3</span>)) ^ (n&gt;&gt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数看起来倒是很简单，就是用n做了一些位运算。不过不属于教师讲述的6中方法之一。</p>
<p>这很大程度地激起了我的好奇心：难道Index是32位的整数吗？这个函数没有任何取模操作，如果传入一个很大的n,它该如何处理呢？</p>
<p>不要着急，让我们继续追踪吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 584 - 588行 */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">key = (*func)(key);</span><br><span class="line">add_direct(table, key, value, hash_val, bin_pos);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到bin_pos这个参数，因为在add_direct函数中，它会调用new_entry函数，最后会执行这个语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 445 行 */</span> </span><br><span class="line">entry-&gt;next = table-&gt;bins[bin_pos];</span><br><span class="line">table-&gt;bins[bin_pos] = entry;</span><br></pre></td></tr></table></figure>

<p>显然地，bin_pos才是数组查找的真正下标！那么bin_pos是在哪里被设置的呢？一个出乎预料的答案是在FIND_ENTRY宏中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 582行*/</span></span><br><span class="line">    FIND_ENTRY(table, ptr, hash_val, bin_pos);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 344行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIND_ENTRY(table, ptr, hash_val, bin_pos) \</span></span><br><span class="line">    ((ptr) = find_entry((table), key, (hash_val), ((bin_pos) = hash_pos(hash_val, (table)-&gt;num_bins))))</span><br></pre></td></tr></table></figure>

<p>经历了千辛万苦，我们终于来到了真正获取下标的hash_pos宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 89行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash_pos(h,n) ((h) &amp; (n - 1))</span></span><br></pre></td></tr></table></figure>

<p>这里可以看到，实际的下标是和哈希表的长度与之后的结果。</p>
<p>有人可能会问，为什么要有两套键（一个hash_val，一个bin_pos）呢？我们下面会谈到，这里埋个伏笔。不过在谈到这个问题之前，我们先要看看它的碰撞处理。</p>
<h4 id="st-table的碰撞处理"><a href="#st-table的碰撞处理" class="headerlink" title="st_table的碰撞处理"></a>st_table的碰撞处理</h4><p>如果FIND_ENTRY宏找到了该key，st_table会如何处理呢？其实，这个问题在add_direct调用的new_enrty函数那里就可以看出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 445 - 446行 */</span></span><br><span class="line">    entry-&gt;next = table-&gt;bins[bin_pos];</span><br><span class="line">    table-&gt;bins[bin_pos] = entry;</span><br></pre></td></tr></table></figure>

<p>这写法显然是链表的头插法，所以是链地址法。</p>
<h4 id="st-table的扩容"><a href="#st-table的扩容" class="headerlink" title="st_table的扩容"></a>st_table的扩容</h4><p>在我们实现的哈希表中，真正的哈希算法为：<br>$$hash = MD5(key) % n$$<br>这样一来带来一个很麻烦的问题 – 扩容时必须重新计算哈希值。</p>
<p>而我们可以猜想到，得益于ruby哈希表中hash_val和bin_pos的分离，扩容时只需要重新计算bin_pos，而不需要重新计算哈希值。</p>
<p>真的是这样吗？让我们再看看源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 459 - 462行 */</span></span><br><span class="line">    <span class="keyword">if</span> (table-&gt;num_entries &gt; ST_DEFAULT_MAX_DENSITY * table-&gt;num_bins) &#123;</span><br><span class="line">rehash(table);</span><br><span class="line">    bin_pos = hash_pos(hash_val, table-&gt;num_bins);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚地看到，如果现在的哈希表项数大于可以容纳的最大数量 * 一个密度常数，那么就用rehash()函数重新对这个表作哈希，而rehash()函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 609 - 627行 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">rehash(<span class="keyword">register</span> st_table *table)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> st_table_entry *ptr, **new_bins;</span><br><span class="line">    <span class="keyword">st_index_t</span> new_num_bins, hash_val;</span><br><span class="line"></span><br><span class="line">    new_num_bins = new_size(table-&gt;num_bins+<span class="number">1</span>);</span><br><span class="line">    new_bins = st_realloc_bins(table-&gt;bins, new_num_bins, table-&gt;num_bins);</span><br><span class="line">    table-&gt;num_bins = new_num_bins;</span><br><span class="line">    table-&gt;bins = new_bins;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ptr = table-&gt;head) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	    ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	    new_bins[hash_val] = ptr;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个地方需要研究</p>
<ol>
<li>new_size是如何实现的，新的大小和现大小是什么关系？</li>
<li>现在的哈希表是如何迁移到新的哈希表的？</li>
</ol>
<p>首先研究第一个问题，我们直接研究new_size函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 157 - 172行 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">st_index_t</span></span><br><span class="line">new_size(<span class="keyword">st_index_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">st_index_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &amp;&amp; (size &amp; ~(size - <span class="number">1</span>)) == size) <span class="comment">/* already a power-of-two? */</span></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    n = next_pow2(size);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size)</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NOT_RUBY</span></span><br><span class="line">    rb_raise(rb_eRuntimeError, <span class="string">&quot;st_table too big&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;			<span class="comment">/* should raise exception */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，下一个大小是next_pow2算出来的。也就是说，新的大小和旧的大小有如下关系：<br>$$size_{new} = 2 \times size_{former}$$</p>
<p>然后研究第二个问题，现在的哈希表如何迁移到新的哈希表。</p>
<p>首先，st_realloc_bins只会重新分配内存，而不会迁移，真正的迁移在这个循环中进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ptr = table-&gt;head) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	    ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	    new_bins[hash_val] = ptr;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要说明白这个循环，必须认真研究一下st_table_entry：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 18 - 26行 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> <span class="title">st_table_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">st_index_t</span> hash;</span><br><span class="line">    <span class="keyword">st_data_t</span> key;</span><br><span class="line">    <span class="keyword">st_data_t</span> record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">    st_table_entry *fore, *back;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个next，指向的是本bin_pos的下一个项；而fore和back，实际上是把整个哈希表中所有的项做成了一个双向链表！</p>
<p>回过头来再看add_direct的最后一部分，我们会有种恍然大悟的感觉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (table-&gt;head != <span class="number">0</span>) &#123;</span><br><span class="line">entry-&gt;fore = <span class="number">0</span>;</span><br><span class="line">(entry-&gt;back = table-&gt;tail)-&gt;fore = entry;</span><br><span class="line">table-&gt;tail = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">table-&gt;head = table-&gt;tail = entry;</span><br><span class="line">entry-&gt;fore = entry-&gt;back = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这也正是双向链表的插入操作，其中table-&gt;head是头指针，table-&gt;tail是尾指针。这样一来，所有的项都串成了一个双向链表，通过从头指针开始的遍历就可以将所有的项加入新的哈希表中，而这正是这个循环所做的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	new_bins[hash_val] = ptr;</span><br><span class="line">&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>特别地，我们发现它确实只是将哈希值用hash_pos宏变为了bin_pos，即下标，从而避免了再次哈希键。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，ruby中的哈希表有这几个特性：</p>
<ol>
<li>哈希函数是将键做不循环的位运算。</li>
<li>哈希值和真正的下标分离，真正的下标由哈希值逻辑与哈希表长度得到，扩容时不需要再次计算哈希值，只需要再次计算真正的下标。</li>
<li>冲突处理采用链地址法。</li>
<li>容量永远是2的n次方，扩容时，新的容量是现容量的两倍</li>
<li>将所有的哈希表项用一个双向链表串起来，用头指针和尾指针实现对整个哈希表的高效遍历。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/10/2019-12-10-find/" data-id="ckg4mhp32001q17sbgw71hdz7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2019-11-02-802-11i-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/11/02/2019-11-02-802-11i-1/" class="article-date">
  <time datetime="2019-11-02T08:53:03.000Z" itemprop="datePublished">2019-11-02</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/802-11i/">802.11i</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/11/02/2019-11-02-802-11i-1/">802.11i 无线安全（一）建立RSNA</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这学期我选了我校的公选课《无线网络安全技术》。以第二个实验为契机，我学习了一下802.11无线网络的安全。感觉网络上的中文资料太混乱、太不成体系。在这里，我用这些文章来系统地说一下这方面的东西。</p>
<p>首先，我们要先分清楚几个名词：WEP WPA WPA2 802.11 802.11i Wifi RSN RSNA</p>
<p>分清楚这几个东西不是很简单的事情。我们应该知道Wi-Fi是无线局域网的意思，而802.11也是无线局域网的标准，那么它们的区别是什么呢?</p>
<p>参考这本书 <strong>Real 802.11 Security: Wi-Fi Protected Access and 802.11i</strong>的说法：</p>
<blockquote class="wp-block-quote">
  <p>
    In summary, Wi-Fi defines a subset of IEEE 802.11 with some extensions
  </p>
</blockquote>

<p>而会出现这种情况的原因要归结于802.11协议比较开放，没有强制规定很多问题。这也就导致一个采用部分802.11特性的设备很可能不能和令一个采用部分802.11特性的设备通信。这很糟糕。为了解决这个问题，Wi-Fi联盟成立（当时叫做 Wireless Ethernet Compatibility Alliance ，WECA）,它推出了Wi-Fi认证，并保证：两台通过Wi-Fi认证的设备可以通过无线网络相互通信。这样一来就解决了上面的问题。</p>
<p>那么，作为安全标准的WEP、WPA、WPA2和ieee 802.11i的关系是什么呢？首先来看WEP。参考<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Wired_Equivalent_Privacy">维基百科</a>的说法：</p>
<blockquote class="wp-block-quote">
  <p>
    Introduced as part of the original 802.11 standard ratified in 1997, its intention was to provide data <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Confidentiality">confidentiality</a> comparable to that of a traditional wired <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Local_area_network">network</a>.
  </p>
</blockquote>

<p>也就是说WEP是IEEE 802.11标准一开始就规定的安全标准。 WEP的意思是“有线等效加密”。</p>
<p>再来看WPA。WPA和Wi-Fi一样，也是Wi-Fi联盟的认证。和Wi-Fi不同的是，WPA是安全性认证。比较麻烦的是，WPA一开始并不是802.11某个部分的子集，它完全是Wi-Fi联盟设计的安全协议。这是为了避免厂家自行其是，从而产生安全上的不兼容问题。这一部分安全协议最终被标准化为802.11i，也就是今天我们要说的主角了。802.11i是对WPA协议的扩展与重构，Wi-Fi联盟使用WPA2作为新的认证商标，以说明这个产品支持802.11i标准。所以简单地说，WPA2应该被视作802.11i的实现。</p>
<p>虽然WPA3认证（对应802.11-2016）已经在2018年发布，但现今市面上绝大多数产品仍是WPA2认证的。下面的讨论也主要基于WPA2，也就是802.11i-2004和802.11-2007</p>
<p>最后来研究RSN和RSNA。RSN(robust security network)是“鲁棒安全网络”或者“健壮安全网络”的意思。RSN的字面意思很好懂，就是一个健壮的、安全的网络。802.11i引入这个概念来区分使用802.11i规定的、新的安全方法的网络和旧的WEP网络。它将WEP网络称为&#8221;pre-RSN&#8221;，也就是在RSN提出之前的网络，而将使用802.11i新引入的安全手段建立的网络称为RSN。所以建立RSN其实是使用802.11i安全的目的。</p>
<p>RSNA则是在两个使用802.11i安全套件的终端间建立的逻辑连接。或者用一个更常用的词“链路”。我们说的两个终端（比如说AP和STA）“连上了”，其实就是在这两个终端间建立了RSNA。</p>
<p>值得一提的是， <strong>深入理解Android：Wi-Fi、NFC和GPS卷</strong> 这本书很不错，值得一读，但在RSNA的概念上犯了错误。原文如下：</p>
<blockquote class="wp-block-quote">
  <p>
    RSNA（Robust Secure Network Association，强健安全网络联合）是802.11定义的一组保护无线网络安全的过程，是一套安全组合拳。这套组合拳包含的过程如图3-45所示。
  </p>
</blockquote>

<p>RSNA的Association不是指802.11i各个组件的组合，而是指两个终端的连接。在NIST上查询RSNA这一词，定义很明确：</p>
<blockquote class="wp-block-quote">
  <p>
    A logical connection between communicating IEEE 802.11 entities established through the IEEE 802.11i key management scheme, also known as the four-way handshake.
  </p>
</blockquote>

<p>其实我们查询Association这个词也会发现，它有两个意思，这里应该取第二个：</p>
<blockquote class="wp-block-quote">
  <p>
    1. (often in names) a group of people organized for a joint purpose.
  </p>

  <p>
    2. a connection or cooperative link between people or organizations.
  </p>
</blockquote>

<p>下面，我们就围绕两个终端如何建立RSNA这一主题，探索802.11i的世界。 </p>
<p>首先，802.11i规定了建立RSNA的方法和建立RSNA后数据如何传输，整个过程可以用802.11i状态机表示：<figure class="wp-block-image"></p>
<p><img src="http://www.tech-faq.com/wp-content/uploads/RSN.png"> </figure> </p>
<p>整个连接可以分为五个过程：</p>
<p>发现（Discovery）-&gt; 认证（Authentication）-&gt; 密钥生成与分发（Key Generation and Distribution） -&gt; 加密数据传输（Protected Communication）-&gt; 连接终止（Connection Termination）</p>
<p>其中相当于建立连接的前三个过程，是我们最感兴趣的过程。下面就来近距离观察这三个过程：</p>
<p><strong>1.发现</strong></p>
<p>AP会对外发送BEACON帧：<figure class="wp-block-image is-resized"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-1024x17.png" alt="" class="wp-image-427" width="580" height="9" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-1024x17.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-300x5.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1-768x13.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104751-1.png 1347w" sizes="(max-width: 580px) 100vw, 580px" /> </figure> </p>
<p>这个帧是AP在对外广播自己的各种信息。见下：<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752.png" alt="" class="wp-image-429" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752.png 587w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104752-300x113.png 300w" sizes="(max-width: 587px) 100vw, 587px" /> </figure> </p>
<p>我们感兴趣的当然是RSN Information:<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753.png" alt="" class="wp-image-430" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753.png 521w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104753-300x116.png 300w" sizes="(max-width: 521px) 100vw, 521px" /> </figure> </p>
<p>这个结构说明了自己支持的加密方法、认证方法等。</p>
<p>STA捕获了这个帧，就可以知道环境中无线网络的信息。如果要求某个AP提供信息，可以用Probe request帧：<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-1024x30.png" alt="" class="wp-image-431" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-1024x30.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-300x9.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754-768x22.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104754.png 1353w" sizes="(max-width: 1024px) 100vw, 1024px" /> </figure> </p>
<p>在Probe response帧中，AP回答自己的各种信息。</p>
<p>在知道AP的信息后就可以连接了。第一个发送的帧应该是Authentication:<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755.png" alt="" class="wp-image-432" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755.png 932w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755-300x25.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104755-768x65.png 768w" sizes="(max-width: 932px) 100vw, 932px" /> </figure> </p>
<p>聪明的同学可能会问，这里的Authentication不是“认证”的意思吗？而认证不是下一步要做的事情吗？其实这个认证，叫做Open System Authentication，或者叫做Null Authentication. 从第二个名字就可以知道它什么也不做，那为什么还是要进行这个过程呢？前面说过，WEP是802.11协议的一部分，有了新的WPA，不能直接剔除掉WEP的过程。这个帧正是WEP的认证，在RSNA建立的过程中使用这个帧是为了和WEP，更准确地说是和802.11状态机兼容。这也体现了开闭原则，在添加新功能时，不能修改原有的体系。</p>
<p>下一步是Association request and response，在这个过程中，STA发送association request，选择自己想采用的各种连接参数（其中包括认证和加密方式），AP发送association response, 确认STA的选择有效。</p>
<p>（不知道为什么，我没有捕获到AP发送的association response）<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-1024x29.png" alt="" class="wp-image-437" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-1024x29.png 1024w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-300x9.png 300w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756-768x22.png 768w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104756.png 1341w" sizes="(max-width: 1024px) 100vw, 1024px" /> </figure> </p>
<p><strong>2.认证</strong></p>
<p>在介绍这个过程之前，我们首先需要知道802.11i使用的两种认证方法。一种是预共享密钥（Pre Shared Key, PSK）认证，另一种是802.1x EAP（Extensible Authentication Protocol ）认证。PSK就是我们常见的那种一个密码的情况，EAP则是公共网络（比如我校的SYSU-SECURE）常用的认证方式。</p>
<p>预共享密钥认证只认证双方对PSK的所有权，而不认证任何其他内容，这个所有权认证通过下面的4-Way Handshake进行；而EAP则要具体协议具体分析。</p>
<p>第二个过程·认证 分为两种情况，如果采用的是802.1x EAP套件，那么在这一步用EAP协议进行认证。关于EAP协议的情况我会在下一篇文章中涉及。如果采用的是PSK，则直接跳过这个过程</p>
<p><strong>3. 密钥生成与分发( 4-WAY HANSHAKE</strong> )</p>
<p>这一步就是传说中的四次握手了。这个过程主要有两个目的：</p>
<p>1.验证上一步认证的效果&#8211;AP和STA是否都对PMK有了所有权。</p>
<p>2.在AP和STA上安装密钥，以便下面加密通信。</p>
<p>（这个过程还可能会有Group Key的生成与分发，但一般用不到，这里不表）</p>
<p>首先先要解释PMK是什么。PMK（Pairwise Master Key）在下面会被用于密钥派生，它的产生分为两种情况：1.如果是PSK模式，PMK就是PSK。2.如果是802.1x EAP模式，它会在EAP协议过程中被安装在AP和STA中。</p>
<p>这样看，PMK是一个相对不变的参数。如果加密时直接使用PMK，那么安全性是很成问题的（据说tls1.1就有这个问题）。所以我们要使用PRF扩展密钥，生成一个暂时的密钥，也就是PTK（ Pairwise Transient Key ）:</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">PTK = PRF-X(PMK, “Pairwise key expansion”,Min(AA,SPA) || Max(AA,SPA) ||Min(ANonce,SNonce) ||Max(ANonce,SNonce))
</pre>

<p>其中X指长度，可以是384（CCMP）或者512（TKIP）.Nonce在这里指随机数，SNONCE指STA的随机数，ANONCE指客户端的随机数。AA指AP的MAC地址，SA指STA的MAC地址。</p>
<p>TIPS: CCMP是采用AES CCM（一种计数器模式）的加密方法，TKIP是采用RC4的加密方法，在802.11i中只支持这两种加密。</p>
<p>这里的SNONCE和ANONCE显然是这一次连接时产生的，那么应该要有某种形式的交换。第一帧就是AP向STA发送自己的随机数：<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757.png" alt="" class="wp-image-441" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757.png 567w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104757-300x97.png 300w" sizes="(max-width: 567px) 100vw, 567px" /> </figure> </p>
<p>拿到这个随机数以后，客户端就可以生成一个随机数，然后开始计算PTK。PTK算出来后会被分为3个部分：<figure class="wp-block-image"></p>
<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758.png" alt="" class="wp-image-443" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758.png 602w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104758-300x106.png 300w" sizes="(max-width: 602px) 100vw, 602px" /> </figure> </p>
<p>其中TK就是加密通信所用的密钥，KCK是下面计算MIC要用到的，KEK是用来加密某些信息的（这里并不深究KEK到底用来做什么，请自行查阅相关资料）。</p>
<p>之后，客户端会构造将自己的随机数写入第二帧，并且将MIC算出来后写入第二帧。MIC是怎么算出来的呢？其实MIC是一个消息校验码，相当于一个HASH函数，但这里用的是HMAC，用我们前面说过的KCK作为HMAC的key，用本帧的所有字节作为输入，计算出来的结果就是MIC。但这里有个问题，MIC不可能在计算出来之前就被填入本帧，所以在计算MIC的时候，要将本帧的MIC字段全部置为0.</p>
<p>第二帧的MIC用这个方式计算：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">MIC = MIC(KCK, EAPOL)</pre><figure class="wp-block-image">

<p><img src="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759.png" alt="" class="wp-image-447" srcset="https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759.png 545w, https://blog.ayanamists.xyz/wp-content/uploads/2019/11/Annotation-2019-11-02-104759-300x59.png 300w" sizes="(max-width: 545px) 100vw, 545px" /> </figure> </p>
<p>AP在收到第二帧后，用相同的方法计算PTK和MIC，再与第二帧时STA传的MIC进行对比，就可以验证STA对PSK的所有权了。</p>
<p>那么，客户端又是如何验证服务端对AP的所有权的呢？其实也是通过MIC的。因为要计算出正确的MIC，就必须要有正确的KCK，只要这一帧的内容和上一帧不一样就可以了！</p>
<p>而这内容肯定是和上一帧不一样的，因为这一帧的NONCE字段被设置为了：</p>
<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Key Nonce = ANonce</pre>

<p>STA只需要计算一下MIC，就可以验证AP对PMK的所有权了。验证成功后，发送第四帧，整个4-WAY-HANDSHAKE握手过程就结束了。</p>
<p>下面的数据就会使用CCMP或TKIP加密，是比较安全的。</p>
<p>总的来说，建立RSNA的过程不是很复杂，也有比较好的扩展性。下一篇文章中我们将会讨论关于EAP的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/11/02/2019-11-02-802-11i-1/" data-id="ckg4mhp1p000b17sbgvpm65dk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>