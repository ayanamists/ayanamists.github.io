<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-2020-07-14-uni" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/14/2020-07-14-uni/" class="article-date">
  <time datetime="2020-07-14T00:00:00.000Z" itemprop="datePublished">2020-07-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/14/2020-07-14-uni/">大学生活的前两年</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E5%AD%A6%E4%B9%A0">学习</a><ul>
<li><a href="#%E4%B8%8A%E8%AF%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0">上课式学习</a></li>
<li><a href="#%E8%87%AA%E5%AD%A6">自学</a></li>
</ul>
</li>
<li><a href="#%E7%94%9F%E6%B4%BB">生活</a><ul>
<li><a href="#%E9%A3%9F">食</a></li>
<li><a href="#%E4%BD%8F">住</a></li>
<li><a href="#%E8%A1%8C">行</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
<p>这几天一直在写作业，今天才有点时间来写写博客。这次我们不谈技术，谈点更有意思的东西：我的大学生活。</p>
<h2 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h2><h3 id="上课式学习"><a href="#上课式学习" class="headerlink" title="上课式学习"></a>上课式学习</h3><p>这两年在课上我学了不少知识，其主要的方面还是计算机和数学。我感受最深的一点是，很多学习过的知识都在期末考试之后就被束之高阁了。</p>
<p>比如说，我们的《数学分析》有三个学期的课程，主要是讲一些分析学的基础知识，也就是实数理论、极限、微积分、级数这些东西。这个课程每周有两节，一节1.5小时，这样算来，我上这门课所花费的时间为：</p>
<p>$$<br>1.5\times20\times3\times2=180<br>$$</p>
<p>这还不算相当长的做作业时间。我在这门课上花费了这么多时间，我究竟收获了什么？</p>
<ul>
<li>实数的七个基本定理，我已经忘得差不多了。不过如果给我具体内容，我应该可以互相证明。</li>
<li>极限的定义我还记得，但是多元函数的连续、可导、可微之间的关系，我已经不记得了。</li>
<li>基本的微积分计算我还是会的。不过某些定式的积分，我也不太会了。</li>
<li>求极值的拉格朗日判别法我已经不太记得了</li>
<li>数项级数、函数项级数的敛散判断我也不太清楚了</li>
<li>曲线积分、曲面积分由于是上个学期最后学的，还有点印象</li>
</ul>
<p>可以看到，在这门课上学到的，至少50%的知识已经暂时性地离开了我。</p>
<p>这是为什么呢？主要还是因为<strong>用得少</strong>。我是计算机系学生，平常使用的数学绝大部分是逻辑学；第二位的是离散数学里的那些结构（图、树等等）；第三位的是数论。如果我学了一些抽象代数，那么抽象代数会排在第四位。</p>
<p>这是因为<strong>只有当我们编写特定领域的程序时，才需要分析学的支持。</strong></p>
<p>所以，我觉得对于这种学科，应该重视三个方面：</p>
<ul>
<li>各个定理的证明。这可以看作【应用逻辑学】</li>
<li>各种结构的应用。</li>
<li>各种结构的计算机实现。</li>
</ul>
<p>换句话说，<strong>我们不要在具体的计算上纠缠</strong>。</p>
<p>比如说，令我印象深刻的一道积分题：</p>
<p>$$<br>\int \frac{1}{1+x^4}<br>$$</p>
<p>让学生求这种【相当麻烦的、但已经有定式的积分】，究竟有什么意义？更应该研究的难道不是如何让计算机做这个积分吗？</p>
<p>比如说，mathematica可以算出：</p>
<p><img src="https://pic.downk.cc/item/5f0dbc6214195aa594eaa384.jpg" alt="1"></p>
<p>真正理解mathematica是如何算出来这个结果人肯定很少，把画到重复劳动上的时间用来研究这个问题不是更有意义的吗？</p>
<p>《数学分析》还不是我上的最窝火的一门课。最让我感到恼火的是《大学物理》。</p>
<p>《大学物理》这门课，学时太少，竟然只有2个学时（每周上一节课）。讲授的老师照本宣科、毫无生气，整个授课过程死气沉沉。基本每节课，我都一些东西没有搞清楚。我们的书名叫【医用物理学】，书里的内容也过少，甚至有些还是错的。</p>
<p>但这门课糟糕的地方还不是上面那些东西，它真正糟糕是这两点：</p>
<ul>
<li>没有帮助学生建立一个正确的感性认识。我虽然为了考试记住了那些知识点，却不明白【波的传播】究竟是一个什么样的过程，【驻波】又是什么样的结构。这直接关系到对计算机网络中【发送时延】、【传输时延】的理解。</li>
<li><strong>在我们学这门课的时候，学《高等数学》的同学已经学过了，或正在学多元微积分；而我们需要在下个学期的《数学分析》中才能学到多元微积分</strong>。</li>
</ul>
<p>既建立不起来感性认识，想用数学结构来认识，却又因为数学水平不行而屡屡受挫，我多次怀疑我到底为什么要学这门课。</p>
<p>其实，物理学在计算机科学中是有点应用的。图形学和游戏引擎中有大量的物理学知识。如果真的要开这种课，我觉得最好的路径是这样的：</p>
<ol>
<li>试着写一个简单的物理引擎 </li>
<li>遇到技术难题，在物理学中寻找答案 </li>
<li>用所学知识解决问题 </li>
<li>重复2</li>
</ol>
<p>通过实现一个简单的物理引擎来教授物理学，这是我觉得比较靠谱的方法。</p>
<p>其他的课在我看来也有这样那样的问题。比如说：</p>
<ul>
<li>数据结构课的老师不知道如何给别人讲授算法</li>
<li>程序设计课不宜从C语言教起（个人看法）</li>
<li>数电课上，我写了一个（自动化简逻辑表达式的）程序来代替我写作业，却被打了低分</li>
<li>线性代数课没有突出重点，而且过于零散</li>
<li>数据库系统课应该从《计算机程序的构造与解释》的第4.3节amb解释器或者逻辑编程讲起</li>
<li>离散数学课应该多讲一些逻辑学的应用，期末考试不应该让人执行算法</li>
<li>计算机组成原理课应该多讲一些物理接口的内容</li>
<li>计算机网络、操作系统课应该允许用电子文档提交作业（而不是蹩脚之极的【先手写，再拍照】）</li>
<li>所有的实验课都应该停止使用word作为【实验报告模板】</li>
</ul>
<p>简单地说，在中大这种层次的学校上课，你会有一堆不满。不过，我们应该看到，这些问题不是中大、甚至不是中国的高校才有的问题。</p>
<p>我真正喜欢上的课，有两门：</p>
<ul>
<li>文学院张均老师的《中国现当代小说选读》</li>
<li>马克思主义学院胡雪莲老师的《中国近现代史》</li>
</ul>
<p>这两门课可以说是非常引人入胜的。授课的老师旁征博引，对很多问题都有自己的观点，而且乐于与学生互动，准备非常充分（这里也表扬一下离散数学的周晓聪老师和信息安全数学基础的郑培嘉老师）。</p>
<p>《中国近现代史》是早晨8点上的课。我只有在上这门课的时候，会不到7点就精神抖擞地起床。希望这种课越来越多吧。</p>
<p>从另外一个角度上看，中大的课业基本上还是宽松的。作业不算多、考试不算难，我的成绩虽然不是很好，但也不是很差。这给我的自学提供了一个比较舒服的外部环境。</p>
<h3 id="自学"><a href="#自学" class="headerlink" title="自学"></a>自学</h3><p>大部分我对知识比较深刻的认识，都来源于自学。学校里没有教过我堆溢出、栈溢出是什么，没有教过我C/C++的链接过程，没有教过我glibc中malloc的实现，没有教过我无线网络的安全体系，没有教过我如何写一个解释器，没有教过我如何写parser，没有教过我什么是continuation，最重要的是，没有教过我如何解决问题。</p>
<p>我所掌握的这些东西全部都来源于我的自学。不过，现在看来，我也是走了很多弯路的。一开始最应该学的是程序语言的相关理论，并且要写程序实践这些理论。在这之后再研究逆向工程、系统结构之类的东西。</p>
<p>虽然自学是我学习生活中一个很重要的组成部分，但是我不想在这里费太多笔墨。每个人自学的强度、节奏都是不一样的，我个人的体验对别人的参考价值恐怕不大。</p>
<h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2><p>当年为什么选择中大而不是别的学校呢？很大程度上，我是看中了广州。2012年，我偶然地有了一次广东之行。这次旅行给了我很深刻的印象：从广州到中山只需要40分钟，城际铁路和地铁相连；几乎没吃到过什么难吃的东西；台风过境时的暴雨倾泻；在广州和深圳的书店里买书……</p>
<p>我甚至记得我当年买的两本书，方舟子的《大象为什么不长毛》和李敖的《审判美国》。</p>
<p>在广州住了一年多的时间，我绝大部分时候都在东校区的教室、宿舍、食堂、图书馆之间穿梭。所谓生活，也无非是衣食住行而已。下面我们就来审视一下这些方面。</p>
<h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><p>我很喜欢粤菜，但【中山大学食堂】的菜，和【粤菜】之间，恐怕是有点差距的。中大食堂我只能用【差强人意】四字形容。当然，这里面也有我期待过高的原因。</p>
<p>2016年的时候，我有幸参加了一个【青少年高校科学营】的活动。具体来说是【厦门大学分营】。也就是说，我在厦大住了一周，参加了很多有意思的活动。而我对厦大食堂的评价是：相当好吃。</p>
<p>所以，我不免对中大食堂有了不切实际的幻想。从我吃过的【大学食堂】来看，中大的食堂只能说是一般水平。如果要吃好吃的东西，那么我不太推荐中大。</p>
<h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>中大在这件事上有严重错误。它在招生时的<strong>承诺</strong>是，大一住一年六人间，大二换成四人间。这个【六人间】不是【原生六人间】，而是【四人间改造成的六人间】。有人可能会好奇，【改造】是什么意思呢？</p>
<p><img src="https://pic4.zhimg.com/v2-7ab638468cc9253cd1eb58272177a0ac_r.jpg?source=1940ef5c" alt="2"></p>
<p>上图是四人间改为六人间以后的设计图，它最大的特点就是那个突出的桌子：</p>
<p><img src="https://pic2.zhimg.com/80/v2-0a019424729948b13d88d7f324de6877_720w.jpg?source=1940ef5c" alt="3"></p>
<p>这个图片可能还没有冲击力，我们看这张：</p>
<p><img src="https://pic2.zhimg.com/80/v2-b6effae087db5ecbd1ca20f0fde661e8_720w.jpg?source=1940ef5c" alt="4"></p>
<p>可想而知，东西多了之后，过道将会多么拥挤。</p>
<p>所以，我们迫切地期望学校能够履行<strong>承诺</strong>。但是，大二上学期，学校因为工程进度原因，没有履行这个承诺。学校失信于学生，是我将会【永志不忘】的一个的污点。</p>
<p>这个宿舍的好处是，<strong>宿舍里有浴室和洗手间</strong>。它虽然有点逼仄，但是总比没有好。我的高中宿舍里没有浴室，在澡堂洗澡的麻烦和尴尬是我难以忘记的回忆。</p>
<p>总体来看，我对宿舍的评价是【还可以】。</p>
<h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>就算是我这样不喜欢外出的人，也会想着出去吃点好的。更何况广州还有不少好去处，比如某个地铁站旁边的地下商场（懂得都懂）。所以，行也是一个值得一说的部分。</p>
<p>中大东校区宿舍距离地铁站不算远，在地图上看是这样的：</p>
<p><img src="https://pic.downk.cc/item/5f0dd9ba14195aa594f42e3e.jpg" alt="5"></p>
<p>步行15分钟就可以到地铁站。</p>
<p>坐上地铁以后，广州市绝大部分需要去的地方都可以方便地到达。在这点上，我还算很满意的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然中大有各种各样的不好，但是我仍然不后悔两年前的选择。中大的气氛是相对自由的，它从来没有过【大一不准携带计算机】、【需要上晚自习】、【需要早起跑操】这些古板而弱智的规定。中大的老师是平易近人的，这里有不会讲课的老师、专业知识不过关的老师，但没有洋洋自得、固步自封、不与学生沟通的老师。中大的饭菜是差强人意的，虽然不是珍馐美味，但也不会难以下咽。</p>
<p><strong>以上均属一家之言，不能也不可能反映全部情况，请自行甄别以上信息的真伪。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/14/2020-07-14-uni/" data-id="ckg4mhp24000w17sb1o1lcktk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-07-04-young" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/04/2020-07-04-young/" class="article-date">
  <time datetime="2020-07-04T00:00:00.000Z" itemprop="datePublished">2020-07-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/04/2020-07-04-young/">一个喜欢网上冲浪的小孩子</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E6%97%B6%E9%9A%94%E5%A4%9A%E5%B9%B4%E7%9A%84%E5%86%8D%E6%AC%A1%E7%99%BB%E5%BD%95">时隔多年的再次登录</a></li>
<li><a href="#%E6%95%B4%E6%B4%BB%E9%92%93%E9%B1%BC%E5%BC%95%E6%88%98%E6%9A%B4%E8%AE%BA">整活、钓鱼、引战、暴论</a></li>
<li><a href="#%E5%85%B3%E4%BA%8E%E7%BE%BD%E9%BB%91%E5%90%A7">关于【羽黑吧】</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%A2%AB%E7%BD%91%E7%BB%9C%E6%9A%B4%E5%8A%9B">第一次被网络暴力</a></li>
<li><a href="#%E5%AF%B9%E5%B0%8F%E5%AD%A9%E5%AD%90%E5%A4%9A%E4%B8%80%E7%82%B9%E5%8C%85%E5%AE%B9">对小孩子多一点包容</a></li>
</ul>
<h2 id="时隔多年的再次登录"><a href="#时隔多年的再次登录" class="headerlink" title="时隔多年的再次登录"></a>时隔多年的再次登录</h2><p>这些天想做的事太多，但都懒得做。我进入了一种类似于【贤者时间】的状态。加之上个月一直在北京，那个家的学习条件没有济南好，我就自然地划水了几天。在这几天里，我登录了<a target="_blank" rel="noopener" href="https://tieba.baidu.com/home/main?id=tb.1.4ed0c736.NG49TDIYDddGwZ4-3OPVEg?t=1389416124&fr=userbar">小时候用的百度贴吧账号</a>，看了看在2012年至2016年间的帖子，不由得感慨万千，记录于此。</p>
<h2 id="整活、钓鱼、引战、暴论"><a href="#整活、钓鱼、引战、暴论" class="headerlink" title="整活、钓鱼、引战、暴论"></a>整活、钓鱼、引战、暴论</h2><p>不得不说，小时候的我的整活能力，或者说搞笑能力，是远胜于今天的我的。请看我在2014年在<a target="_blank" rel="noopener" href="https://tieba.baidu.com/f?kw=%E5%9D%9A%E5%86%B3%E5%8F%8D%E5%AF%B9%E6%88%92%E8%89%B2">坚决反对戒色吧</a>发的<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/3231938966?fid=11668183&pid=55691344790&cid=0&red_tag=2449367415#55691344790">学好文件抓住纲（戒色内部文件）</a>:</p>
<blockquote>
<p>戒色邪教教主和导师飞翔的胡诌著作《戒为良药》这个邪恶文件发表以来，全体邪教人员热烈欢呼，衷心拥护，普遍进行了学习和讨论。当前，各级邪教组织正在加强领导，更加广泛地误导群众，紧密地混淆本地区、本部门、本单位的实际，进一步把这个邪恶文件认真学习好，宣传好，贯彻执行好，在这个邪恶文件的指导下，把本地区、本部门、本单位戒色的邪教运动更加深入地开展起来。学好文件抓住纲，深入误导青少年，这是邪教完成2014年传教任务的关键。</p>
</blockquote>
<blockquote>
<p>当前，邪恶的戒色邪教和正义的反制力量的矛盾、戒色人员和正常人员的矛盾、禁欲主义和和谐主义的矛盾，集中表现为戒色邪教和正义力量的矛盾。深入误导青少年，这就是邪教当前的主题，就是邪教当前的纲。紧紧抓住这个纲，斗争的大方向就掌握牢了，各项工作就有统属了。“捉住了这个主要矛盾，一切问题就迎刃而解了。”这一点，各级邪教组织一定要在思想上非常明确。不光领导者要明确，还要使戒色人员都明确。</p>
</blockquote>
<blockquote>
<p>邪教教主飞翔，领导邪教奋战了半个多世纪，经历了十次重大的教内路线斗争。这半个多世纪的历史反复证明，什么时候，我们执行教主飞翔的传教路线，遵循教主飞翔的指示，革命就胜利；什么时候离开了教主飞翔的传教路线，违背了教主飞翔的指示，传教就失败，就受挫折。教主飞翔的旗帜，就是胜利的旗帜。教主飞翔在世的时候，我们团结战斗在教主飞翔的伟大旗帜下。现在，教主飞翔逝世了，我们更要高高举起和坚决捍卫教主飞翔的伟大旗帜。这是我们教众的邪恶职责，是我们继续团结战斗的政治基础，是我们进一步取得胜利的根本保证。吧零厚教主领导我们，继承教主飞翔的遗志，进行了并在继续进行着误导青少年的活动，这是我们教的历史上又一次重大的路线斗争。经过这个斗争，捍卫了教主飞翔的伟大旗帜，保证我们的邪教沿着教主飞翔的革命路线继续前进，这是吧零厚教主的伟大历史功勋。在英明领袖吧零厚主席领导下，我们踏上了新的征途，正在做继往开来的伟大工作。我们肩上的责任很重。我们面前还有不少困难。我们有勇气、有信心，挑起重担，战胜一切困难。教主飞翔曾经号召我们：“团结起来，以大局为重，焕发精神，努力工作。”让我们高举教主飞翔的伟大旗帜，更加自觉地贯彻执行教主飞翔的传教路线，凡是教主飞翔作出的决策，我们都坚决维护，凡是教主飞翔的指示，我们都始终不渝地遵循，最紧密地团结在以吧零厚教主为首的教中央周围，紧跟以吧零厚为首的教中央的战略部署，一切行动听以吧零厚教主为首的教中央指挥，同心同德，步调一致，牢牢抓住误导青少年这个纲，去夺取控制人民的新的邪恶胜利。</p>
</blockquote>
<p>如果放在今天，我恐怕是想不到也愿意去把历史上的中央文件改成一篇戏谑文章的。在2014年，我甚至不知道网上盛行的【孔乙己修改文】的【孔乙己】是哪篇文章，自己想到了这种结构。如此看来，我还算是有点创造力的。</p>
<p>在钓鱼方面，我也算是有所建树。2015年我在<a href="%5Bhttps://tieba.baidu.com/f?ie=utf-8&kw=%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86&fr=search%5D(https://tieba.baidu.com/f?ie=utf-8&kw=%E7%90%86%E8%AE%BA%E7%89%A9%E7%90%86&fr=search)">理论物理吧</a>发的<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/3962990575">谈谈大气压</a>是这样说的：</p>
<blockquote>
<p>维维安尼做的托里拆利实验证明大气压为1.013*10^5Pa，所以1cm^2的指甲盖受到的压力约为10N，但我们在挥动手指时没感受到这么大的力，这是为什么</p>
</blockquote>
<p>这个问题的答案是很显然的，因为所谓【所以1cm^2的指甲盖受到的压力约为10N】根本就是在胡扯，如果你把指甲盖想象成一个平面的话，那么所谓的【受到的压力约为10N】，实际上指的是【上表面和下表面受到的力是10N】，这两个力是平衡的。</p>
<p>但我发这个帖子，并不是为了求教，而是为了钓鱼。<strong>因为我曾经真的搞不懂过这个问题</strong>，我想看看有没有一知半解的人被我忽悠进去。结果还真钓上来一个：</p>
<p><img src="https://pic.downk.cc/item/5f00995214195aa594ab6034.jpg" alt="1"></p>
<p>当然了，这人说的似乎也有一定正确性，但是显然和这个问题是不相干的。</p>
<p>在【引战】方面，这个帖子比较有代表性：</p>
<p><img src="https://pic.downk.cc/item/5f0f1fff14195aa594512f54.jpg" alt="-1"></p>
<p>这种【第一】【第二】的无聊比较，竟然能引出40多楼的争论。</p>
<p>至于【暴论】，请看<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/3162701390">这个帖子</a>：</p>
<p><img src="https://pic.downk.cc/item/5f0f1f4c14195aa59450f201.jpg" alt="0"></p>
<p>现在看来，这可真实贻笑大方了。</p>
<h2 id="关于【羽黑吧】"><a href="#关于【羽黑吧】" class="headerlink" title="关于【羽黑吧】"></a>关于【羽黑吧】</h2><p>上面的这个只是小打小闹，真正的重头戏在历史类贴吧里。从小到大，我都很喜欢研究历史。不过小时候的我读书不多，思考很浅，表达的欲望却极为强烈。自然地，产生了大量的【中二言论】。</p>
<p>一切的一切都要从2012年关羽吧的<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/1733877698?pid=22042061917&cid=0&red_tag=0337967218#22042061917">这个贴子</a>说起：</p>
<blockquote>
<h3 id="凭神马封我？我说的是不对，封我一两天也太—"><a href="#凭神马封我？我说的是不对，封我一两天也太—" class="headerlink" title="凭神马封我？我说的是不对，封我一两天也太—-"></a>凭神马封我？我说的是不对，封我一两天也太—-</h3></blockquote>
<p>这帖子的缘由应该是我在【关羽吧】发了一个【羽黑】的帖子。所谓的【羽黑】，是一个【抹黑关羽】的【谓语后置】形式。关羽，自然是历史上那位【美髯公】了。抹黑，就是字面意思的抹黑。【羽黑】有两种解释，一是【抹黑关羽的行为】，二是【抹黑关羽的人】。</p>
<p>【抹黑关羽】似乎不是一个正面的词汇，当时的我却把它作为了一种类似于【人生追求】的存在。我在《三国志》里看到的关羽，和在《三国演义》里看到的关羽形象相去甚远。《三国演义》里常常移花接木，把本属于其他人的功劳嫁接到关羽头上。举两个例子:</p>
<ul>
<li><p>所谓的【诛文丑】，实际上是文丑不知道被谁所杀。<a href="%5Bhttps://zh.wikipedia.org/wiki/%E6%96%87%E9%86%9C%5D(https://zh.wikipedia.org/wiki/%E6%96%87%E9%86%9C)">维基百科</a>对此有详细论述</p>
</li>
<li><p>所谓的【斩华雄】，实际上是华雄被孙坚斩杀。《三国志》有明确记载：</p>
<blockquote>
<p>坚移屯梁东，大为卓军所攻，坚与数十骑溃围而出。坚常著赤罽帻，乃脱帻令亲近将祖茂著之。卓骑争逐茂，故坚从间道得免。茂困迫，下马，以帻冠冢间烧柱，因伏草中。卓骑望见，围绕数重，定近觉是柱，乃去。坚复相收兵，合战於阳人，大破卓军，枭其都督华雄等</p>
</blockquote>
</li>
</ul>
<p><strong>中二的人喜欢把自己知道的但一般人不了解的知识当成是【我辈岂是蓬蒿人】的证明，因此，他们特别珍惜这些知识和这些知识所带来的影响。</strong></p>
<p>在那个小学升初中的暑假，我自以为是地认为世间称赞关羽的人都是【被欺骗的人】，我要【告诉他们真相】。所以，我在关羽吧，这个【受害者的集中营】里，发出了【羽黑】的帖子。</p>
<p>可是，这些【受害者】们，不但不领情，还把我的帖子删了。这对我幼小的心灵产生了巨大的冲击。由此开始，我就开始原教旨主义地展开了我所以为的【羽黑活动】。现在想来，<strong>我真的很讨厌关羽吗？恐怕不是。我所发的【羽黑】帖子，即使在今天看来，也只是基于《三国志》祛除演义里的【不真实成分】而已。我真正讨厌的，只是那些不认真听我在说什么的【羽迷】而已。</strong></p>
<p>当然，那些人既没有义务、也没有必要听我的话。他们有不少人不仅对《三国志》有精深研究，而且也研究过各种野史，他们所喜欢的【关羽】，就是史书上的那个【关羽】。他们所讨厌的，是我的【羽黑】身份和我对关羽的不屑口吻。</p>
<p>小学生没有什么能力和别人对线，也不知道怎么举报出口成脏的帖子。一个月后开学，我便把这件事抛之脑后了。</p>
<p>真正让这件事出现转机的，是我无意之间知道了有一个叫【羽黑吧】的地方。</p>
<p>当时这个【羽黑吧】已经被关羽吧的人【攻占】（即关羽吧的人当吧主，把真正的【羽黑】都列入黑名单）了。在它的首页，有<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/879131471">这篇帖子</a>。我第一次有了一种【找到组织】的归属感。但却又叹恨于【组织的家】已经被【攻占】了这一事实。</p>
<p>岁月流转，来到了2014年。不知道怎么想的，我又想起来了【羽黑吧】这回事。这时我的战斗力显然比小学时强得多了。我准备认认真真地恶心关羽吧的人。于是，我创建了【新羽黑吧】，<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/2810108452?pid=44328151508&cid=0&red_tag=0005585224#44328151508">并在关羽吧发帖跳脸</a>。遗憾的是，这个吧自创建到被攻占，用户数都没有超过20个.</p>
<p>除此之外，我还用刚刚在微机课上学的PS做了一张图，作为吧头像：</p>
<p><img src="https://imgsa.baidu.com/forum/w%3D580/sign=b4431b858fb1cb133e693c1bed5556da/92dc5ab5c9ea15ceb6389063b4003af33887b2e9.jpg" alt="2"></p>
<p>2014年的暑假，我趁【羽黑吧】吧主长期不上线的机会，通过三次举报，成功地拿下了羽黑吧的吧主，并以迅雷不及掩耳之势取得了吧主之位。当然了，我以为关羽吧的人的【大意、麻痹】了，其实他们从来就没有把羽黑吧放在眼里过。</p>
<p>这个时候可能有人就要问了，那为什么现在无论是【羽黑吧】，还是【新羽黑吧】，似乎都被【攻占】了呢？</p>
<p>如果我在高中毕业之前被问到这个问题，我的回答会是：“上初三了，没时间管理贴吧，被举报了”。</p>
<p>但今天我意识到了，关键的问题不在这里，而在于，我也有点【麻痹、大意】了。为什么呢？<strong>一个演员只有在观众注视着他时才有表演的欲望</strong>。</p>
<p>在我夺取吧主之位以后，关羽吧的同志们反响平平，这些观众不再看我的演出了，我自然也没有继续表演的动力了。</p>
<p>但令我意想不到的是，我竟然因此阴差阳错地有了一次被网暴的经历。</p>
<h2 id="第一次被网络暴力"><a href="#第一次被网络暴力" class="headerlink" title="第一次被网络暴力"></a>第一次被网络暴力</h2><p>关羽吧有一些嘴很臭的人，这些人倒还不算是网络暴力。真正算是【网络暴力】的事情，与yyut的经历有点像。那就是所谓的【特定】。【特定】是什么意思呢？简单来说就是通过网上的匿名身份，搜索到你的真实身份。也就是说，这个函数：</p>
<p>$$<br>f:匿名身份 \rightarrow 实名身份<br>$$</p>
<p>被【实现】了。</p>
<p>首先，我的百度贴吧账号没有【隐藏我关注的吧】，这直接导致我的初中母校–山东师范大学第二附属中学–被暴露了：</p>
<p><img src="https://pic.downk.cc/item/5f0f14f214195aa5944d7c7d.jpg" alt="3"></p>
<p>这个<a href="%5Bhttps://tieba.baidu.com/home/main?un=%E7%81%AB%E5%B1%B1%E9%A3%9E%E7%8B%90008&ie=utf-8&id=tb.1.ebe7d2a3.yhlVHn_RlI7J6RQZN7CzwA&fr=pb&ie=utf-8%5D(https://tieba.baidu.com/home/main?un=%E7%81%AB%E5%B1%B1%E9%A3%9E%E7%8B%90008&ie=utf-8&id=tb.1.ebe7d2a3.yhlVHn_RlI7J6RQZN7CzwA&fr=pb&ie=utf-8)">人</a>不知道从什么途径搞到了我的真名，他发了<a target="_blank" rel="noopener" href="https://tieba.baidu.com/p/4340486390">这个贴子</a>：</p>
<p><img src="https://pic.downk.cc/item/5f0f167e14195aa5944df8e6.jpg" alt="4"></p>
<p>这个人，首先夺取了我担任吧主的所有吧的控制权（这件事发生在14年，不知道这个人为什么这么有毅力，找我找了两年）。然后，他用极其不堪入目的语言来侮辱我：</p>
<p><img src="https://pic.downk.cc/item/5f0f17b114195aa5944e61ee.jpg" alt="5"></p>
<p>这个帖子不仅侮辱我，还侮辱了我的一个初中同学。<strong>不小心让她也遭了无妄之灾，是我唯一觉得我做错了的地方。</strong>我们再看看这个人侮辱我的例子：</p>
<p><img src="https://pic.downk.cc/item/5f0f187614195aa5944ea501.jpg" alt="6"></p>
<p><img src="https://pic.downk.cc/item/5f0f18b314195aa5944eb760.jpg" alt="7"></p>
<p><img src="https://pic.downk.cc/item/5f0f18fd14195aa5944ed647.jpg" alt="8"></p>
<p><img src="https://pic.downk.cc/item/5f0f194814195aa5944ef4b5.jpg" alt="9"></p>
<p>如果你觉得这个人的恶劣语言就止步于此了，那你就太天真了。我们来看看他赞同的一条发言：</p>
<p><strong>虽然我不想放上来污染我的博客，但是我觉得有必要让读者看看这伙人的真实言论，以及被我删除和举报过的、已经不留存的对我的攻击究竟恶劣到了什么程度</strong>:</p>
<p><img src="https://pic.downk.cc/item/5f0f19cb14195aa5944f1ba5.jpg" alt="10"></p>
<p>唉，20岁的我已经不再对这些东西感到气愤了。我感到是一种悲哀，一种【我们之间已经隔了一层厚壁障】的悲哀。</p>
<h2 id="对小孩子多一点包容"><a href="#对小孩子多一点包容" class="headerlink" title="对小孩子多一点包容"></a>对小孩子多一点包容</h2><p>我曾经中二过，所以我会对中二的小孩子多一点包容；我曾经卖弄过我一知半解的知识，所以我会对卖弄一知半解的知识的小孩子多一点包容。就像这个孩子：</p>
<p><img src="https://pic3.zhimg.com/80/v2-c3e51aef030e5691d7079a314d305912_720w.jpg?source=1940ef5c" alt="11"></p>
<p>我觉得，做这种图片的人，品味和修养真的很差：</p>
<p><img src="https://pic4.zhimg.com/80/v2-028b333395dcb0c2f9cfacfb63e1f13e_720w.jpg?source=1940ef5c" alt="12"></p>
<p>一个拥有知识、拥有技术的【上位者】，应该有一颗善良的心灵。即使他不分享自己的知识，也绝不应该用自己的知识嘲讽没有知识、没有技术的【下位者】。</p>
<p>在这个世界上，我最看不惯的人之一，就是【笑话穷人的人】。像做上图一样的行为，和笑话穷人有什么区别？自己多了一点知识，就有那么了不起吗？</p>
<p>我相信，如果这个小孩子受到的不是这种嘲讽，而是温柔的指正，那么他会真的走上学习编程的道路。在他到了我这个年纪的时候，他会远远超过我。现在他受到了铺天盖地的嘲讽，我甚至怀疑他是否会对java语言有心理阴影了。</p>
<p>勿以恶小而为之，勿以善小而不为。程序员应该是乐于帮助别人的人，不应该是拿着小学生的错误自我高潮的人。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/07/04/2020-07-04-young/" data-id="ckg4mhp23000v17sbbf7cbvvx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-06-23-tramp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/06/23/2020-06-23-tramp/" class="article-date">
  <time datetime="2020-06-23T00:00:00.000Z" itemprop="datePublished">2020-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/06/23/2020-06-23-tramp/">谈谈【蹦床】技术</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="过程式语言中的尾调用"><a href="#过程式语言中的尾调用" class="headerlink" title="过程式语言中的尾调用"></a>过程式语言中的尾调用</h2><p>在scheme中，尾调用完全是循环的：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="builtin-name">define</span></span> factor</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (n result)</span><br><span class="line">    (<span class="name"><span class="builtin-name">if</span></span> (<span class="name"><span class="builtin-name">&lt;</span></span> n <span class="number">2</span>)</span><br><span class="line">      result</span><br><span class="line">      (<span class="name">factor</span> (<span class="name"><span class="builtin-name">-</span></span> n <span class="number">1</span>) (<span class="name"><span class="builtin-name">*</span></span> result n)))))</span><br></pre></td></tr></table></figure>

<p>这段代码和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">    result = n * result;</span><br><span class="line">    n--;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具有完全相同的时间和空间复杂度。这是由于scheme中使用的不是【栈】，而是【继续】(continuation)。如果读者不知道什么是【继续】，可以继续关注我的博客，我会写另外一篇文章来专门解释这个问题。</p>
<p>但在c语言那样的语言中，类似于上面的scheme的代码会产生多余的栈增长：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec_factor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> rec_factor(n - <span class="number">1</span>, ret * n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是因为，在调用rec_factor(n - 1, ret * n)时，这个rec_factor(n, ret)的局部变量、参数等等，都是没有用的。换言之，它应该【退出】之后再调用rec_factor()</p>
<h2 id="【蹦床】技术"><a href="#【蹦床】技术" class="headerlink" title="【蹦床】技术"></a>【蹦床】技术</h2><p>为了解决这个问题，编程语言专家们引入了【蹦床】技术。这个技术的核心是【先退出，再调用】，如果你把【退出函数】想象成落下，【调用函数】想象成弹起，那么C语言的尾调用就是【跳跳跳跳跳。。。落落落落落】，而再使用了蹦床技术之后，尾调用就像是【跳落跳落跳落。。。】，自然就像一个【蹦床】一样了。</p>
<p>怎么实现呢？我们再考察一下刚才的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rec_factor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> rec_factor(n - <span class="number">1</span>, ret * n);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果return的不是一个【函数调用】，而是一个【值】，那么，它就会在这里直接返回。而我们可以在外部用这个【值】来继续计算rec_factor(n - 1, ret * n)，或者说，调用rec_factor(n - 1, ret * n)。</p>
<p>我们先改写一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bounce <span class="title">rec_factor</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> Bounce;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> Bounce;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见，这个Bounce需要既能包住一个【值】（也就是C中的值），又能包住一个【调用】。怎么设计呢？如果使用C++的话，我们有lambda()[]{}，std::function之类的匿名函数可以做到【包住调用】这点，但我们这里不用这些东西，而是使用自己定义的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bounce</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">Bounce</span> <span class="params">(*func)</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">void</span>*)</span></span>;</span><br><span class="line">	func f;</span><br><span class="line">	<span class="keyword">void</span>* args;</span><br><span class="line">	<span class="keyword">void</span>* return_value;</span><br><span class="line">	<span class="keyword">bool</span> end;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的func类型是为了方便而定义的，第一个参数是【参数的指针】，第二个参数是【返回值的指针】，而它在语法意义上的返回值则是一个Bounce。end用来区分它是一个【函数调用】还是一个【值】。</p>
<p>由于bounce包含了【要调用的函数指针、参数】，它自然可以用来保存调用。我们来看一下改写后的factor函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Bounce <span class="title">factor</span><span class="params">(<span class="keyword">int</span> * n, <span class="keyword">int</span>* ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (*n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">		Bounce b;</span><br><span class="line">		b.return_value = ret;</span><br><span class="line">		b.end = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		*ret = (*n) * (*ret);</span><br><span class="line">		*n = (*n) - <span class="number">1</span>;</span><br><span class="line">		Bounce b;</span><br><span class="line">		b.f = (Bounce::func)factor;</span><br><span class="line">		b.args = n;</span><br><span class="line">		b.return_value = ret;</span><br><span class="line">		b.end = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">return</span> b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自然，这样的【函数】是不能直接调用的，因为它返回一个Bounce，我们需要另一个函数来**不断地处理bounce，直至得到一个【被包住的值】，而不是【被包住的调用】为止：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Tramp</span><span class="params">(Bounce b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (b.end == <span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> b.return_value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">auto</span> hot = b;</span><br><span class="line">		<span class="keyword">while</span> (!hot.end)</span><br><span class="line">		&#123;</span><br><span class="line">			hot = hot.f(hot.args, hot.return_value);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b.return_value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在外部，我们会这样来调用它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Bounce b;</span><br><span class="line">	b.f = (Bounce::func)factor;</span><br><span class="line">	b.args = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">	*(<span class="keyword">int</span>*)b.args = <span class="number">100000</span>;</span><br><span class="line">	b.return_value = <span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">	*(<span class="keyword">int</span>*)(b.return_value) = <span class="number">1</span>;</span><br><span class="line">	b.end = <span class="literal">false</span>;</span><br><span class="line">	Tramp(b);</span><br><span class="line"><span class="comment">// 	rec_factor(100000, 1);</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(<span class="keyword">int</span>*)b.return_value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面那行被注释掉的代码，会爆栈；而我们用【蹦床】技术写的等效代码，则不会爆栈。这样一来，对于所有的尾调用，只要调用的函数满足func类型的函数声明，都可以这样调用而不会消耗额外的栈空间。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/06/23/2020-06-23-tramp/" data-id="ckg4mhp22000t17sb2qnx870q" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-05-23-ref" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/05/23/2020-05-23-ref/" class="article-date">
  <time datetime="2020-05-23T00:00:00.000Z" itemprop="datePublished">2020-05-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/05/23/2020-05-23-ref/">“引用类型”、“指针类型”与“值类型”</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E5%B0%86%E7%AC%A6%E5%8F%B7%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%80%BC">将符号解释为值</a></li>
<li><a href="#%E5%B0%86%E7%AC%A6%E5%8F%B7%E7%BB%91%E5%AE%9A%E4%B8%BAir%E7%B1%BB%E5%9E%8B%E4%BB%8D%E7%84%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%80%BC%E7%B1%BB%E5%9E%8B">将符号绑定为IR类型，仍然解释为值类型</a><ul>
<li><a href="#%E7%BB%91%E5%AE%9A%E4%B8%8A%E5%92%8C%E8%A7%A3%E9%87%8A%E4%B8%BA%E7%9A%84%E5%8C%BA%E5%88%AB">“绑定上”和“解释为”的区别</a></li>
<li><a href="#ir%E7%B1%BB%E5%9E%8B%E5%92%8Cer%E7%B1%BB%E5%9E%8B">IR类型和ER类型</a></li>
<li><a href="#%E4%BB%8E%E7%BB%91%E5%AE%9A%E5%80%BC%E5%88%B0%E8%A7%A3%E9%87%8A%E5%80%BC">从绑定值到解释值</a></li>
</ul>
</li>
<li><a href="#%E5%B0%86%E7%AC%A6%E5%8F%B7%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">将符号解释为引用类型</a></li>
<li><a href="#%E4%BC%A0%E5%80%BCcall-by-value%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8call-by-reference">传值（call-by-value）和传引用（call-by-reference）</a><ul>
<li><a href="#%E4%BC%A0%E5%80%BC">传值</a></li>
<li><a href="#%E4%BC%A0%E5%BC%95%E7%94%A8">传引用</a></li>
</ul>
</li>
<li><a href="#%E6%9F%90%E4%BA%9B%E5%85%B7%E6%9C%89gc%E7%9A%84%E8%AF%AD%E8%A8%80%E5%B0%86%E7%AC%A6%E5%8F%B7%E7%BB%91%E5%AE%9A%E5%88%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%A7%A3%E9%87%8A%E4%B8%BA%E5%80%BC%E6%88%96%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B">某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型</a><ul>
<li><a href="#ier%E7%B1%BB%E5%9E%8B">IER类型</a></li>
<li><a href="#ier%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A5%BD%E5%A4%84">IER类型的好处</a></li>
<li><a href="#c%E4%B8%AD%E7%9A%84%E4%BC%A0%E5%BC%95%E7%94%A8">C#中的传引用</a></li>
</ul>
</li>
<li><a href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%80%BC%E7%B1%BB%E5%9E%8B">真正的值类型</a></li>
</ul>
<p>在众多编程语言复杂而不统一的设计的影响下，“引用类型”和“值类型”的问题，已经是一个相当混乱的问题了。在这里简单讲一下我的理解。</p>
<p>首先，我们必须知道这两个概念是什么意思。</p>
<ul>
<li>绑定(binding)。绑定是编程语言里一个符号的解释。</li>
<li>环境(environment)。环境是所有绑定的形成的复合数据结构。</li>
</ul>
<p>简单地说，在scheme里，我们使用</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> x <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">+</span></span> x <span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是把1这个值绑定到x这个符号上，下面(+ x 1)中的x就可以被解释为1.</p>
<p><strong>然而，事情其实没有这么简单。</strong>下面，我们以C/C++为例，谈谈一个符号绑定上的，究竟是什么东西。</p>
<h2 id="将符号解释为值"><a href="#将符号解释为值" class="headerlink" title="将符号解释为值"></a>将符号解释为值</h2><p>考虑下面的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们注意到，a这个变量，是可以被替换为0的，上面的代码和下面的代码等价：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个特性叫做引用透明性(Referential transparency)。其本质就是，一个符号对应一个<strong>不变的值</strong>，就像上面的代码里，我们有：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a : <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>a这个符号，在这个词法作用域里，处处被解释为0，只有声明一个新的a覆盖掉这个符号（C里面不允许这样），a才能不被解释为0.</p>
<p>这才应该是所谓“a这个符号是值类型”的意义。但在C语言里，或者说在大多数命令式编程语言里，<strong>情况与此有些不同</strong>。</p>
<h2 id="将符号绑定为IR类型，仍然解释为值类型"><a href="#将符号绑定为IR类型，仍然解释为值类型" class="headerlink" title="将符号绑定为IR类型，仍然解释为值类型"></a>将符号绑定为IR类型，仍然解释为值类型</h2><h3 id="“绑定上”和“解释为”的区别"><a href="#“绑定上”和“解释为”的区别" class="headerlink" title="“绑定上”和“解释为”的区别"></a>“绑定上”和“解释为”的区别</h3><p>简单来说，“绑定为”是实现上的概念，“解释为”是在外部观察到的现象。比如说，如果找一个C语言的REPL（类似于irb\fsi\scheme一样的东西），你输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它必定告诉你：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>:<span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但a这个符号到底在解释器里真正对应什么东西，仅凭这个是不能确认的。它在解释器里真正对应的东西，就是“绑定为”的东西。</p>
<h3 id="IR类型和ER类型"><a href="#IR类型和ER类型" class="headerlink" title="IR类型和ER类型"></a>IR类型和ER类型</h3><p>在C语言里，一个变量是可以被赋值的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你还是让a绑定上一个值，那么必须要求绑定本身是可变的，而“可变”还不能是这样的可变：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也就是说，不能是开一个新的作用域来“覆盖”，而必须是精准地改变（在这个例子里的）顶层作用域的a符号。我们先禁止这种操作，因为继续看下去，你会发现<strong>这本质上也是引用</strong>。</p>
<p>如果a不能被直接绑定上一个值，它应该被绑定上什么东西呢？<strong>我们创造一个新的类型，叫做“IR类型”</strong>，这个符号绑定上“IR类型”.</p>
<p>IR类型”的构造方式为：</p>
<ul>
<li>声明一个局部变量，该局部变量的类型即为IR类型。</li>
</ul>
<p>“IR类型”应该支持这两种操作：</p>
<ul>
<li>改变其值，记作 set(a, b)，其中a为此类型的值，b为要set的值。</li>
<li>得到其值，记作 get(a), 其中a为此类型的值，这个操作会返回最近一次set(a, b)中的b，如果没有被set过，则为未定义行为</li>
</ul>
<p>如何去实现这个类型呢？实现这个类型的关键在于“记忆最近的b”，而在数字电路中，“记忆”的实现方式是触发器，在现代计算机中就是内存。一个比较自然的想法是，每一个IR类型值都占有一块内存。而这个想法的实现方式，就是在IR类型的实现中，记录这块内存的索引（即地址）。</p>
<p>我们用这种记法来写这个模型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a : IR(location, value)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>简写为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a : location --&gt; value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意到，在静态语言里，set(a, b)中的B必须是某个类型的值，记此类型为B，我们这样表示这个特定的IR类型：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IR[B]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可能会说，<strong>这样不是把“变量”和“指针”混为一谈了吗？这和“指针”有什么区别呢？</strong>不要着急，我们来向这个模型中加入“指针”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&amp;a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这定义了一个新的操作和一个新的类型：</p>
<ul>
<li>对“IR类型”，可以用 get-ref(a)，得到一个“ER类型”值</li>
<li>ER类型值有这几个操作：<ul>
<li>de-ref(er)，er为ER类型值且er = get-ref(ir). 这个操作会返回get(ir)</li>
<li>set-ref(er, b)，er为ER类型值且er = get-ref(ir). 这个操作和 set(ir, b) 等价</li>
</ul>
</li>
</ul>
<p>把ER类型简写为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">er : location -&gt; value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这么说，可能还不是特别清楚，我们来举个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a; <span class="comment">// 相当于构造了一个IR类型值，并绑定到a这个符号上，可以记作 a : loc_0 --&gt; undefined</span></span><br><span class="line">a = <span class="number">10</span>; <span class="comment">// 相当于set(a, 10)，a：loc_0 --&gt; 10</span></span><br><span class="line">a; <span class="comment">// 相当于get(a)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * p = &amp;a;</span><br><span class="line"><span class="comment">// 注意，这里是构造了一个IR类型值，并绑定到p这个符号上，该IR的值为一个ER类型值，应该记作：</span></span><br><span class="line"><span class="comment">// p : loc_1 --&gt; loc_0 -&gt; 10</span></span><br><span class="line">*p = <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 相当于 set-ref(p, 1000)， p: loc_1 --&gt; loc_0 -&gt; 1000</span></span><br></pre></td></tr></table></figure>

<p>讲到这里，我实际上说明了一个问题：<strong>C语言的变量符号，实际上绑定到IR类型值, C语言的指针值，实际上是ER类型值，C语言的指针变量符号，实际上绑定到IR[ER]类型的值</strong>。</p>
<h3 id="从绑定值到解释值"><a href="#从绑定值到解释值" class="headerlink" title="从绑定值到解释值"></a>从绑定值到解释值</h3><p>从上面的例子中，我们看到，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个符号a，绑定为IR类型的值，在我们引用它时，通过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a;</span><br><span class="line">&lt;=&gt;</span><br><span class="line">get(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个变换，实现了绑定值到解释值的转换。实际上，我们可以给出这时的绑定值和解释值的完整定义：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ExpVal = All C Value</span><br><span class="line">BindVal = IR(ExpVal)</span><br></pre></td></tr></table></figure>

<h2 id="将符号解释为引用类型"><a href="#将符号解释为引用类型" class="headerlink" title="将符号解释为引用类型"></a>将符号解释为引用类型</h2><p>我们知道C++中，有引用类型。就像下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line">b = <span class="number">10</span>;</span><br><span class="line">a;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果有C++的REPL，将这份代码打进去，它会告诉你：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>:<span class="number">10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这又是怎么一回事呢？实际上，它不过是将我们之前说的IR类型，同时也作为了一种解释值而已。</p>
<p>换句话说，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="comment">// a: loc_1 --&gt; value</span></span><br></pre></td></tr></table></figure>

<p>这段代码中的b，接受的是a<strong>这个IR值本身</strong>，而不是它的解释值。b可以被记作：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">b: loc_0--&gt;loc_1--&gt;value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样一来，b的解释值就是</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">loc_1--&gt;value</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过要注意的是，下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; c = b;</span><br><span class="line"><span class="comment">// 如果没有右值引用，c应该是loc_2 --&gt; loc_1 --&gt; loc_0 --&gt; value</span></span><br></pre></td></tr></table></figure>

<p>会报错，这是因为c++用&amp;&amp;当作所谓的“右值引用”，导致引用值不能嵌套了。</p>
<h2 id="传值（call-by-value）和传引用（call-by-reference）"><a href="#传值（call-by-value）和传引用（call-by-reference）" class="headerlink" title="传值（call-by-value）和传引用（call-by-reference）"></a>传值（call-by-value）和传引用（call-by-reference）</h2><p>在大多数语言中，函数调用都可以这样建模：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">FUNCTION = BODY + ARG (+ ENV)?</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>BODY就是函数体，ARG就是形式参数，ENV是这个函数定义时的环境，如果有ENV，它就是一个闭包。C语言中的函数就不是闭包，所以它只有BODY和ARG。</p>
<p>在调用函数时，我们必须将ARG绑定上实际参数，怎么绑定就成了一个问题。</p>
<h3 id="传值"><a href="#传值" class="headerlink" title="传值"></a>传值</h3><p>传值是最自然、最合理的方法。</p>
<p>在传值的情况下，调用函数可以写成：</p>
<ol>
<li>求每个参数的<strong>解释值</strong></li>
<li>将对应的值绑定到形式参数上</li>
<li>求函数体的值（面向表达式）/运行函数体（面向陈述）</li>
</ol>
<h3 id="传引用"><a href="#传引用" class="headerlink" title="传引用"></a>传引用</h3><p>传引用需要满足两个前置条件：</p>
<ol>
<li>这个语言的符号（可以）绑定到引用类型</li>
<li>对应的参数绑定到引用类型</li>
</ol>
<p>也就是说，不绑定到引用类型的符号，或者不是符号的东西（例如字面值、调用函数的结果等等），一般来说是不能传引用的。</p>
<p>用一句话来解释传引用，可以这样说：<strong>传引用时，传递一个绑定到IR值的符号的绑定值，而非解释值。</strong></p>
<p>这个规则，应该说，叫做”General call by reference”，具体到C++，应该这么说：</p>
<p><strong>如果符号的解释值是一个值，那么传递这个符号绑定的IR值；如果符号的解释值是一个IR值，那么传递这个解释值。</strong></p>
<p>我们以一段代码为例，解释上面的话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span>&amp; a)</span></span>&#123;</span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// a会绑定到 loc_a --&gt; loc_0 --&gt; 0</span></span><br><span class="line">  <span class="comment">// 所以运行后，a会绑定到 loc_a --&gt; loc_0 --&gt; 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// a: loc_0 --&gt; 0</span></span><br><span class="line">  func2(a);</span><br><span class="line">  <span class="comment">// 传入的是 loc_0 --&gt; 0 这个IR值</span></span><br><span class="line">  <span class="comment">// 汇编形式为</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 00B48E02 8D 45 B8             lea         eax,[a]  </span></span><br><span class="line"><span class="comment">   * 00B48E05 50                   push        eax  </span></span><br><span class="line"><span class="comment">   * 00B48E06 E8 AE 87 FF FF       call        func2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">int</span> &amp;b = a;</span><br><span class="line">  <span class="comment">// b: loc_1 --&gt; loc_0 --&gt; 2</span></span><br><span class="line">  func2(b);</span><br><span class="line">  <span class="comment">// 传入的是 b 的解释值 loc_0 --&gt; 2</span></span><br><span class="line">  <span class="comment">// 汇编形式为</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * 007B8E02 8B 45 AC             mov         eax,dword ptr [b]  </span></span><br><span class="line"><span class="comment">   * 007B8E05 50                   push        eax</span></span><br><span class="line"><span class="comment">   * 007B8E06 E8 AE 87 FF FF       call        func2</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>为啥C++的传引用和别的语言不太一样呢？这就要从那些带GC的语言说起了。</p>
<h2 id="某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型"><a href="#某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型" class="headerlink" title="某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型"></a>某些具有GC的语言：将符号绑定到引用类型，解释为值或引用类型</h2><h3 id="IER类型"><a href="#IER类型" class="headerlink" title="IER类型"></a>IER类型</h3><p>预测一下下面的三个带GC的语言，运行差不多代码的结果：</p>
<p>C#:</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params">List&lt;<span class="keyword">int</span>&gt; a</span>)</span>&#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = List&lt;<span class="keyword">int</span>&gt;() &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">func(a);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ruby:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span> <span class="title">a</span></span></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">func a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>scheme:</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> func</span><br><span class="line">  (<span class="name"><span class="builtin-name">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="builtin-name">vector-set!</span></span> x <span class="number">0</span> <span class="number">0</span>)))</span><br><span class="line">(<span class="name"><span class="builtin-name">define</span></span> a (<span class="name"><span class="builtin-name">vector</span></span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name">func</span> a)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先要提醒一句，<strong>这三个语言全部是传值的</strong>（C#可以传引用，默认传值）</p>
<p>这三段差不多的代码都会得到一个结果–a变成了 {0, 2, 3}.</p>
<p>为什么呢？因为在这三个语言中，数组这个结构，都是一个类似于ER类型、有IR类型的某些特征的值。</p>
<p>这个“类似于ER类型、有IR类型的某些特征的值”，我把它叫做“IER”类型值。</p>
<p>ER类型值的构造方法为：</p>
<ul>
<li>每当构造一个新的“引用类型值”（比如一个新的对象）时。</li>
</ul>
<p>例如，.Net IL的newobj指令会构造一个IER类型值，并把它放在求值栈(evalution stack)的栈顶。</p>
<p>IER类型的行为为：</p>
<ul>
<li>IER类型值的解释值为IER类型值本身</li>
<li>通过IER类型的值a，可以获得a指向的值（<strong>但在绝大多数有GC的语言中，用户不能这样做</strong>）</li>
<li>通过IER类型的值a，可以获得a指向的值的一部分（例如，a指向的值是一个对象，那么可以通过a来获得某个成员的值、调用成员方法）</li>
<li>通过IER类型的值a，可以改变a指向的值（“改变”的意义是模糊的，可以改变整个值，也可以改变这个值的一部分）</li>
<li>IER类型指向的值，由垃圾回收器负责回收。</li>
</ul>
<p>我们记IRE类型的值为：</p>
<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ier : loc ---&gt; value</span><br></pre></td></tr></table></figure>

<p>你也许会问，IER类型的值是IER类型本身，这个特征说明它更像ER类型。它具有IR类型的哪些特质呢？</p>
<p>观察这样的C#代码：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">List&lt;<span class="keyword">int</span>&gt; a = List&lt;<span class="keyword">int</span>&gt;() &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>a这个符号的绑定值的类型为：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">IR[List&lt;<span class="keyword">int</span>&gt;]</span><br><span class="line"><span class="comment">// 看起来像 loc_0 --&gt; value</span></span><br><span class="line"><span class="comment">// 实际上是 loc_0 --&gt; loc_1 ---&gt; value</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>习惯上，这个类型标志的应该是List&lt;int&gt;本身，而不是对List&lt;int&gt;的引用。所以它形式上更像IR一些。</p>
<p>这样一来，整个类型体系可以被写成：</p>
<figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ExpVal = IER + Value</span><br><span class="line">DenVal = IR[ExpVal]</span><br><span class="line">IER = Ref(C# Reference Type)</span><br><span class="line">Value = C# Value Type</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从这里我们可以看到，此处的“引用类型”和C++中的“引用类型”完全是两个东西。C++中的引用类型，是IR，这里的引用类型，是IER。</p>
<h3 id="IER类型的好处"><a href="#IER类型的好处" class="headerlink" title="IER类型的好处"></a>IER类型的好处</h3><ul>
<li><p>IER类型使得程序员不需要考虑大规模对象的复制开销，因为IER类型的值是IER类型本身，赋值过程本质上是共享的。</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;()&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="comment">// a: loc_a --&gt; loc_1 ---&gt; list0</span></span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line"><span class="comment">// b: loc_b --&gt; loc_1 ---&gt; list0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同时，GC的存在使得有一种可靠的方式释放该共享对象。</p>
</li>
</ul>
<h3 id="C-中的传引用"><a href="#C-中的传引用" class="headerlink" title="C#中的传引用"></a>C#中的传引用</h3><p>C#中的变量，也都是可变的，所以势必要有和IR类似的结构。（实际上就是IR）。它传引用的方式和我们前面说的一样：传引用时，传递一个绑定到IR值的符号的绑定值，而非解释值。</p>
<p>举个例子：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span>(<span class="params"><span class="keyword">ref</span> List&lt;<span class="keyword">int</span>&gt; x</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// x被绑定到 loc_x --&gt; loc_0 --&gt; loc_1 ---&gt; (list0)</span></span><br><span class="line">  x = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// x变为 loc_x --&gt; loc_0 --&gt; null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a = <span class="keyword">new</span> List&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="comment">// a: loc_0 --&gt; loc_1 ---&gt; (list0)</span></span><br><span class="line">func(<span class="keyword">ref</span> a);</span><br><span class="line"><span class="comment">// 传入a的绑定值loc_0 --&gt; loc_1 ---&gt; (list0)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="真正的值类型"><a href="#真正的值类型" class="headerlink" title="真正的值类型"></a>真正的值类型</h2><p>在F#、Haskell等等函数式语言里，有真正的、不可变的“值类型”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let a &#x3D; 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的a，永远会被解释为1。这才是真正的“值类型”。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/05/23/2020-05-23-ref/" data-id="ckg4mhp21000r17sbb4we5au6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-04-27-what-to-watch-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/2020-04-27-what-to-watch-2/" class="article-date">
  <time datetime="2020-04-27T00:00:00.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/2020-04-27-what-to-watch-2/">看点什么（二）那些让我不那么满意的作品</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这次谈的是“那些让我不那么满意的作品”，注意，这些作品我仍然是喜欢的，只是他们多多少少有些地方让我不那么满意。至于那些我不喜欢的作品，我可能甚至不会去讨论它们。</p>
<h2 id="第一型：深刻的题材，浅薄的描写"><a href="#第一型：深刻的题材，浅薄的描写" class="headerlink" title="第一型：深刻的题材，浅薄的描写"></a>第一型：深刻的题材，浅薄的描写</h2><p>想到一个深刻的问题，比解决它可能更有价值。我欣赏能提出严肃问题的作者，更欣赏其作品。</p>
<p>但是，很多作品的状态是提出了一个严肃的问题，却给出轻佻的解答。我一直都会觉得这种作品很可惜，也为作者感到遗憾。不过有些时候，不是作者不想给出认真的解答，而是他没有给出解答的能力，或者说，现在还没到能够解答这个问题的时候。</p>
<h3 id="《逃避可耻但有用》"><a href="#《逃避可耻但有用》" class="headerlink" title="《逃避可耻但有用》"></a>《逃避可耻但有用》</h3><p><img src="https://pic.downk.cc/item/5ea6fc8ec2a9a83be5e1a14a.png" alt="0"></p>
<p>这部剧很出名，主要是火力全开的Gakki的着实光彩四射，一颦一笑，摄人心魄。但是，我真的并不很满意这部剧。</p>
<p>请诸位看过这部剧的同志想想它的第一二集在讲什么呢？程序员加班问题（<strong>这个问题提的很好嘛</strong>）、如何实现人的幸福感和获得感的问题，还有一个经典的女权问题–男性对家务劳动价值的无偿占有。</p>
<p>但是这部剧的后续发展让我实在是不忍直视，这几个问题都没有怎么解决。我原本任务男女主可以真正地建立一种新的家庭关系，虽然在这个关系体系下女主就是一个全职保姆，但就算这样也算是有点突破，也算是探讨了新的家庭形态。</p>
<p>可是，也许是制作组似乎只想让Gakki的笑治愈大家吧，最后男女主来了一出假戏真做白头偕老，又回到了传统的家庭形态。唉，可能是我抱的期待过高了吧。</p>
<h3 id="《要听爸爸的话》"><a href="#《要听爸爸的话》" class="headerlink" title="《要听爸爸的话》"></a>《要听爸爸的话》</h3><p><img src="https://pic.downk.cc/item/5ea6fc42c2a9a83be5e148cc.jpg" alt="1"></p>
<p><strong>原作轻小说的作者已经去世，在此表示对他创作的敬意</strong>。</p>
<p>我只看过动画，所以这里只对动画作评论。读者可能不是很熟悉这部作品，这里引用萌娘百科简单介绍一下：</p>
<blockquote>
<p>樱花飞舞的季节，青年濑川祐太成为了新鲜的大学生。开学不久，他就很快交到了几位朋友——心地善良，却爱好花天酒地的帅哥仁村浩一；行动诡异，并领导着奇异社团“路上观察研究会”的留级肥宅佐古俊太郎；以及举止优雅，让祐太一见钟情的美人织田莱香……宽松自由的日子，让祐太对接下来的大学生活十分期待。某一天，祐太相依为命的血亲，已结婚三年多的姐姐小鸟游祐理来探望祐太。在姐姐的邀请（命令）下，祐太第一次拜访了小鸟游家。这次邀请其实是小鸟游祐理拜托他看家的委托。祐太接受了请求，并与三年未见的外甥女们——小鸟游空、小鸟游美羽、小鸟游雏重逢。然而令所有人没有想到的是，小鸟游夫妇出行当日遭遇空难，下落不明。祐太失去了至亲的姐姐，而13岁的小空、10岁的美羽、3岁的小雏，则一下子变成了孤儿。面对着夕阳下死寂寒冷的小鸟游家、即将天各一方的三姐妹，以及独立抚养自己长大的姐姐的相片，下定决心的祐太在无力同时抚养三姐妹的亲戚们面前，面对着小鸟游姐妹们说：“要来我家么？”由此，以一名大学生家长和三个美少女的成长为主线，一部讲述了三个可爱“女儿”与她们的“爸爸”朝夕相处、相扶相持的五年时光的，描绘着亲情、责任、恋爱、成长的温馨喜剧，就此展开……</p>
</blockquote>
<p>看完这段描述，我觉得作者如果好好发挥的话，是能获得相当高的人气的。</p>
<p>因为，它触及了一个核心问题：<strong>人如何在现代社会生存下去</strong>。特别地，它触及的问题更加极端：<strong>一个举目无亲大学生和三个小女孩如何在现代社会生存下去</strong></p>
<p>看这篇文章的读者，无论你是高中生、大学生，还是已经走上社会的人，<strong>请扪心自问：你有能力独立养活三个小女孩吗？</strong></p>
<p>如果作者给出了一个不借助外部力量的答案，那这部作品就会成为一部励志片。因为，<strong>一个不是那么好的大学的大学生都可以养活三个小女孩，你当然也可以养活自己！</strong></p>
<p>我们都知道给出这样的答案是不现实的，至少是没有普遍意义的。虽然如此，我们仍然可以给出一个<strong>合理</strong>的答案。</p>
<p>因为这部作品的前一段剧情是合理的，所以到了空难的时候，我们就获得了这样的局面：</p>
<ul>
<li>小鸟游夫妇住的房子不小，家里资产应该也比较可观</li>
<li>显然的，三个女儿是第一顺位继承人</li>
</ul>
<p>有这个作铺垫，“一个举目无亲的大学生养活三个小女孩”这件事就不离谱了。这部作品本可以描写祐太如何进行规划、进行投资理财，而且这也不需要花费太多笔墨，下面的重点就转移到<strong>一个大学生如何和三个小女孩一起生活</strong>上，来描写那些温情的东西。如果这么写，那这部作品就成为一部现实主义作品，它可以涉及到社会的方方面面，给作品打上时代的烙印。</p>
<p>可实际上，这部作品没有给出一个合理的答案，它甚至在逃避这个问题。</p>
<p>这种状况，首先因为是作者在空难以后争夺抚养权那一部分写的很不好，他是这样写的：</p>
<blockquote>
<p>下定决心的祐太在无力同时抚养三姐妹的亲戚们面前，面对着小鸟游姐妹们说：“要来我家么？</p>
</blockquote>
<p><strong>你确定这真的争夺的到抚养权？？？？？？</strong></p>
<p>如果我来写这个故事，那些亲戚要么不会有出场的机会，要么会被祐太反杀。我有几种设定方法：</p>
<ul>
<li>小鸟游家是独子，三个小女孩的爷爷去世，然后在第一阶段把奶奶写死。</li>
<li>祐太争夺抚养权失败。但亲戚对小女孩很不好，只盯上她们父母的遗产，用一个家暴然后小女孩报警之类的导火索强迫剥夺亲戚抚养权。</li>
</ul>
<p>我不知道日本有没有独身男性不能收养小女孩这个设定，如果有的话，那正好，我们让学姐和祐太假结婚，来明正言顺地收养她们。学姐有两个特质，一是喜欢祐太，二是不是正常人，思维比较开发发散（和我一样），她大概也不会拒绝这样的请求。<strong>这样一来小空和学姐的党争剧情不也就更有看头了吗？</strong></p>
<p>如果说争夺抚养权是不现实的话，那么，后面的剧情可以说就有点魔幻了。首先，<strong>那么大的房子，不要了？遗产也不要了？</strong>。其次，<strong>作者根本没有正面描写祐太是如何获得足够的钱的，他没有一个严谨的计算。一直都是祐太在打工，可是打工能挣多少钱？能养活三个女儿吗？</strong></p>
<p>打到这里，我实在是为这部作品感到惋惜。我当然不能说这是因为作者水平多么差，毕竟他可能只是想写一部温情脉脉的萌系作品。唉，怎么说呢？业界药丸？</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/27/2020-04-27-what-to-watch-2/" data-id="ckg4mhp1z000m17sb83pvhgj6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-04-27-竹笋" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/" class="article-date">
  <time datetime="2020-04-27T00:00:00.000Z" itemprop="datePublished">2020-04-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/">如何正确地烹制春笋</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="我的竹笋记忆"><a href="#我的竹笋记忆" class="headerlink" title="我的竹笋记忆"></a>我的竹笋记忆</h2><p>笋是我最喜欢的食物之一。记得小时侯在聊城，不时去“永宁酒家”饭店吃饭。酒席上最抓住我味蕾的一道菜是“杂烩”，其中的竹笋片味道鲜香、口感嫩滑，在我的饮食记忆里留下了浓墨重彩的一笔。</p>
<p>高中的时候学化学竞赛，17年5月赴杭州参加“培尖教育”组织的化学竞赛培训。当时的三餐是培训所在酒店提供的。令我印象深刻的是几乎每餐都会有的炒竹笋片，或者应该是叫“油焖竹笋”。它的口感和“杂烩”里的又不同。首先，“杂烩”中的竹笋片，是用很多相交于底面圆心的直径切割圆锥形的竹笋所得的，而杭州的竹笋片，则似乎是用平行于直径的线切割竹笋所得的。其次，杭州的竹笋有浓厚的油香，所谓“素食火腿”大概就是那种感觉。</p>
<p>这两道竹笋菜，使我喜欢上了竹笋这种食材。</p>
<h2 id="一般方法的溃败"><a href="#一般方法的溃败" class="headerlink" title="一般方法的溃败"></a>一般方法的溃败</h2><p>疫情以来，我常常在家中掌勺。自然地，烹制竹笋也被我列上了计划日程。春天到来之后，在市场上就时常看到鲜嫩春笋的身影。我的第一次尝试，就在这时开始了。</p>
<p>买到春笋以后，首先是要扒开它，这并不难。但葛朗台看到此情此景，怕不是要从书里跳出来指责我浪费了。把春笋毛茸茸的棕黑外壳完全剥离之后，你会惊讶地发现，垃圾桶满了，而剩下可食用部分不到一半。</p>
<p>此后我不假思索地切开，用“杂烩”里面的切法切片，把每一片切丝。倒油煸肉炒竹笋丝加调料一气呵成。</p>
<p>但炒出来的菜却绝不能称得上好吃，和饭店里的竹笋有很大差别。总结了一下，主要存在两个不好吃的问题：</p>
<ul>
<li>味道上，竹笋有苦涩味，而且味道相当重。</li>
<li>口感上，竹笋硬而干，不讨嘴巴喜欢。</li>
</ul>
<h2 id="改进1-切掉剩余外皮与用水焯制"><a href="#改进1-切掉剩余外皮与用水焯制" class="headerlink" title="改进1 切掉剩余外皮与用水焯制"></a>改进1 切掉剩余外皮与用水焯制</h2><p>上次失败之后没几天，我就又买了一颗竹笋，再次进行挑战。</p>
<p>维基百科上对竹笋有这样的描述：</p>
<blockquote>
<p>竹笋受到阳光照射，会产生“紫杉氰糖苷”(氰甙，Taxiphyllin)，吃起来易有苦味，当储存一定时间后紫杉氰糖苷经水解酶作用后产生氰酸（ＨＣＮ）、醛或酮类，应尽快煮沸杀青处理。</p>
</blockquote>
<p>这“紫杉氰糖苷”的结构式如下：</p>
<p><img src="https://pic.downk.cc/item/5ea6deacc2a9a83be5bf582e.png" alt="0"></p>
<p>从分子结构上来看应该还是比较亲水的，我认为焯一下竹笋可能会在很大程度上解决味道苦涩的问题。</p>
<p>而对于口感的问题，我认为应该</p>
<ol>
<li>在扒开后沿切面方向整个把竹笋的外表刮干净，即使浪费一些也不要紧。</li>
<li>削出一个新的横截面，因为旧的横截面已经风干很长时间了，很可能是干硬口感的元凶之一。</li>
</ol>
<p>果不其然，这次的口感有很大改进，而味道上虽然有改进，但不算很大。</p>
<h2 id="改进2-用盐水焯"><a href="#改进2-用盐水焯" class="headerlink" title="改进2 用盐水焯"></a>改进2 用盐水焯</h2><p>为什么上次的苦涩味没有消除多少呢？细细想来，还是因为那种物质没有溶解多少。如何让那种物质溶解得更多呢？</p>
<p>有这么多羟基，这个化合物应该是相对亲水的。苯酚都有相当的溶解度，这个东西没有道理比苯酚还难溶。</p>
<p>所以这个问题的关键<strong>不在于热力学，而在于动力学</strong>。加盐来破坏细胞结构是一个不错的想法。</p>
<p>这次的尝试就相当成功，剩下的一点苦涩味完全可以看作对肉的油腻的调和。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我又用改进后的方法做了三次竹笋，味道是比较稳定的。用代码来描述一下这个核心过程–焯水的话，就是这样：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">module</span> 烹饪方式</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">self</span>.焯水<span class="params">(食材，时间，环境)</span></span></span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">烹饪方式<span class="symbol">:</span><span class="symbol">:</span>焯水(竹笋丝，<span class="number">10</span>分钟，盐水)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过，要想完全达到酒店的口感，这样还不行。这似乎是因为酒店用的笋，很可能是类似于笋干的一类东西。总之，用这个方法，在家里也可以吃到还不错的竹笋了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/27/2020-04-27-%E7%AB%B9%E7%AC%8B/" data-id="ckg4mhp20000p17sb7fec5334" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-4-25-parser2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/25/2020-4-25-parser2/" class="article-date">
  <time datetime="2020-04-25T00:00:00.000Z" itemprop="datePublished">2020-04-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/25/2020-4-25-parser2/">让我们实现编程语言吧（四） 语法、词法分析器与从解析树到语法树</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">词法分析器</a><ul>
<li><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">为什么要有词法分析器</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">如何构建一个词法分析器</a></li>
</ul>
</li>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8">语法分析器</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98">语法分析器的基本问题</a></li>
<li><a href="#%E5%B8%82%E9%9D%A2%E4%B8%8A%E7%9A%84%E5%B8%B8%E8%A7%81parser">市面上的常见Parser</a></li>
<li><a href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8">递归向下解析器</a></li>
<li><a href="#parser-combinator">Parser Combinator</a></li>
<li><a href="#parser-generator">Parser Generator</a></li>
<li><a href="#%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A7%A3%E6%9E%90%E5%99%A8">算符优先级解析器</a></li>
</ul>
</li>
<li><a href="#%E4%BB%8E%E8%A7%A3%E6%9E%90%E6%A0%91%E5%88%B0%E8%AF%AD%E6%B3%95%E6%A0%91">从解析树到语法树</a><ul>
<li><a href="#%E9%80%92%E5%BD%92%E5%90%91%E4%B8%8B%E8%A7%A3%E6%9E%90%E5%99%A8%E7%9A%84%E6%83%85%E5%86%B5">递归向下解析器的情况</a></li>
<li><a href="#yacc%E7%9A%84%E6%83%85%E5%86%B5">Yacc的情况</a></li>
</ul>
</li>
<li><a href="#%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98">需要注意的几个问题</a><ul>
<li><a href="#%E4%B8%8D%E8%A6%81%E7%BB%99parser%E5%A2%9E%E5%8A%A0%E5%A4%AA%E5%A4%9A%E8%B4%9F%E6%8B%85">不要给Parser增加太多负担</a></li>
<li><a href="#%E6%9C%80%E5%A5%BD%E4%B8%8D%E8%A6%81%E5%AE%9E%E7%8E%B0parser">最好不要实现Parser</a></li>
</ul>
</li>
</ul>
<h2 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h2><p>词法分析器，是将输入的字符串解析为符号串的工具；语法分析器，即parser，是将符号串解析为解析树（并将解析树映射为语法树）的工具。</p>
<h3 id="为什么要有词法分析器"><a href="#为什么要有词法分析器" class="headerlink" title="为什么要有词法分析器"></a>为什么要有词法分析器</h3><p>一般的编译器教科书，常常是先讲词法分析器，再讲语法分析器，顺带着讲讲生成文法。个人认为这是<strong>完全错误</strong>的。</p>
<p>我们必须要知道，我们这里提到的Parser解析的全部都是<strong>上下文无关文法</strong>（CFG），而词法分析器解析的是<strong>正则文法</strong>，我们还知道，<strong>所有的正则文法都是上下文无关文法</strong>，那么这就得出一个结论，因为Parser也可以解析正则文法，所以词法分析起是完全不需要的。</p>
<p>为了解释为什么需要词法分析器，我们必须考察一下市面上常见的各种Parser。</p>
<p>Parser从大的方面上分，有三个属性：</p>
<ul>
<li>定向/非定向</li>
<li>确定型/非确定型</li>
<li>自底向上/自顶向下</li>
</ul>
<p>其中非定向方法构建的Parser在程序语言中用的不多，这里不表。</p>
<p>如果你认真阅读过关于上一篇正则文法的文章，你会知道“确定型”和“非确定型”的区别在于“确定型”不需要搜索，时间复杂度是线性的；“非确定型”需要搜索，时间复杂度按你搜索的方法不同，从$$O(n^2)$$到$$(O(e^n))$$都有可能。如果从这个角度出发，那么这个解析器最好是确定型的。</p>
<p>但凡事有得必有失，确定型的解析器有一个天然劣势–<strong>不存在可以解析任何CFG的确定型解析器</strong>。这就要求我们必须对文法进行限制，以满足特定的解析器。</p>
<p>这种限制有时候是很不舒服的。而正则文法则不同，<strong>只要你的文法是正则文法，不需任何限制即可获得一个确定型解析器</strong>。</p>
<p>所以我们需要正则文法，来将字符串变为符号串，提前解决一些Parser解析起来很麻烦的东西。</p>
<h3 id="如何构建一个词法分析器"><a href="#如何构建一个词法分析器" class="headerlink" title="如何构建一个词法分析器"></a>如何构建一个词法分析器</h3><p>如果你使用的语言有正则表达式支持，那就直接使用正则表达式构建即可；如果没有（常用的语言也就C没有了吧），建议使用flex之类的工具。</p>
<p>这里我们需要注意几个问题：</p>
<ul>
<li>正则表达式最好写在一起，否则和搜索没有区别。</li>
<li>如果你的正则表达式不支持捕获，那么是无法实现的。</li>
<li>注意错误处理，生成好看的错误。</li>
</ul>
<h2 id="语法分析器"><a href="#语法分析器" class="headerlink" title="语法分析器"></a>语法分析器</h2><h3 id="语法分析器的基本问题"><a href="#语法分析器的基本问题" class="headerlink" title="语法分析器的基本问题"></a>语法分析器的基本问题</h3><p>我个人分为三个问题：</p>
<ul>
<li>如何正确、快速地识别输入符号串</li>
<li>如何构建的解析树</li>
<li>如何把解析树映射成语法树</li>
</ul>
<p>接下来的讨论，只讨论第一个问题。后面两个问题见下一节。</p>
<h3 id="市面上的常见Parser"><a href="#市面上的常见Parser" class="headerlink" title="市面上的常见Parser"></a>市面上的常见Parser</h3><p>现在市面上有很多Parser，大概分为五类：</p>
<ul>
<li>手写的递归向下解析器</li>
<li>函数式编程语言里的Parser Combinator</li>
<li>Parser Generator</li>
<li>手写的算符优先级解析器</li>
<li>一些使用特定算法的其他解析器</li>
</ul>
<h3 id="递归向下解析器"><a href="#递归向下解析器" class="headerlink" title="递归向下解析器"></a>递归向下解析器</h3><p>递归向下指的是一种编程方法。比如说你有这样的文法：</p>
<p>$$ A \rightarrow aBc $$</p>
<p>$$ B \rightarrow dB $$</p>
<p>那么，你写出这种函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VALUE <span class="title">handle_A</span><span class="params">(SYMBOL * stream, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == a)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS(handle_B(stream, pos)))&#123;</span><br><span class="line">      <span class="keyword">if</span>(stream[pos] == c)&#123;</span><br><span class="line">        pos++;</span><br><span class="line">        <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// error_handle</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VALUE handle_B(SYMBOL * stream, <span class="keyword">int</span> pos)&#123;</span><br><span class="line">  <span class="keyword">if</span>(stream[pos] == d)&#123;</span><br><span class="line">    pos++;</span><br><span class="line">    <span class="keyword">if</span>(SUCCESS(handle_B(stream, pos)))&#123;</span><br><span class="line">      <span class="comment">// 变成语法树返回回去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">// error_handle</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// error_handle</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从外形上说，这就是把每一个非终结符写成一个函数，然后在这个函数里处理这个非终结符的内容，并返回成功或失败。</p>
<p>从本质上说，这是一个自顶向下解析器。它是一个下推自动机，具有一个栈，以如下方式运行：</p>
<ul>
<li>初始化：将初始符号压入栈中（调用handle_S）</li>
<li>从栈顶弹出一个符号<ul>
<li>如果是终结符就与当前字符串的第一个符号进行比较，如果成功则继续，失败返回错误</li>
<li>如果是非终结符就将这个非终结符的右手侧压入栈中（调用handle_X）</li>
</ul>
</li>
</ul>
<p>这个时候，读者应该隐隐约约地感到到了一些问题。</p>
<p>第一个问题是，一个非终结符可以生成不同的符号串，比如说：</p>
<p>$$ A \rightarrow aBc \tag{0}$$</p>
<p>$$ A \rightarrow cDf \tag{1}$$</p>
<p>如果现在的栈顶符号是$$A$$，你如何判断压入哪个符号串呢？</p>
<p>这就有了递归向下Parser内部的两个实质Parser：</p>
<ul>
<li>回退解析器。如果遇到这种问题，我们使用搜索广度优先或深度优先搜索算法，将两种路径都尝试一下，如果失败就回退。（非确定型）</li>
<li>LL(k)解析器。我们保证文法是LL(k)的，这样一来就可以根据当前输入符号串的前$$k$$个符号判断采取哪条路径。（确定型）</li>
</ul>
<p>第二个问题是，如果我们遇到的是左递归文法：</p>
<p>$$ A \Rightarrow Aa $$</p>
<p>这个规则会使得自动机不停地弹出A和压入A，是一个死循环。所以从本质上来说，执行最左推导的下推自动机极其实现，永远不可能处理原始的左递归文法。</p>
<p>而有时候我们又必须要求左递归，比如四则运算的减号。</p>
<p>有人可能会说，有一个算法可以把左递归强行化成右递归。确实是有，但是如果你把该算法作用于减号上，你会发现，强行化成右递归会导致语义不正确。这个问题是每一个使用递归向下的人不得不解决的。</p>
<h3 id="Parser-Combinator"><a href="#Parser-Combinator" class="headerlink" title="Parser Combinator"></a>Parser Combinator</h3><p>我们知道，所有的生成文法其实都可以写成连接的形式（当然，必须允许重复定义，或者允许选择符号）。而上面的递归向下解析器其实是在用代码定义这些东西：</p>
<ul>
<li>终结符–是否匹配的if判断语句</li>
<li>非终结符–是否匹配的if判断函数</li>
<li>连接–顺序执行</li>
<li>选择–判断进入哪条路径的if判断语句</li>
</ul>
<p>很多人会敏锐的认识到，这些东西都可以进行抽象。把代码的运行逻辑留下，作为一个高阶函数；把具体的代码封装成函数作为其参数。而这恰恰就是函数式编程的思想。</p>
<p>如此一来，我们就获得了一个新的工具–Parser Combinator.</p>
<p>我这里举<a target="_blank" rel="noopener" href="https://www.quanttec.com/fparsec/">FParsec</a>作为例子，看看它是如何构建解析器的：</p>
<p>FParsec把输入流进行封装。其中最重要的概念就是“position”，即当前要处理的符号串位置。<strong>这里需要特别注意，FParsec只支持将字符串作为输入，无法使用词法分析器，这是其美中不足之处。</strong></p>
<p>FParsec将解析器定义为一个函数，原型如下：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type Parser&lt;&#39;Result, &#39;UserState&gt; &#x3D; CharStream&lt;&#39;UserState&gt; -&gt; Reply&lt;&#39;Result&gt;</span><br></pre></td></tr></table></figure>

<p>  这里的UserState是我们自己定义的State，一般设为unit（即空类型，没有内容）即可，暂时不去管他；这里的’Result是一个泛型类型，用户可以自己定义结果。</p>
<p>  这个函数的意义是，一个输入为CharStream型，输出为Reply的函数。</p>
<p>FParsec提供了一些用来从字符构建非终结符的函数，比如说:</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let internal charReturnE (c: char) result error : Parser&lt;&#39;a,&#39;u&gt; &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      if stream.Skip(c) then Reply(result)</span><br><span class="line">      else Reply(Error, error)</span><br></pre></td></tr></table></figure>

<p>  我们使用</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a &#x3D;  charReturnE &quot;a&quot; &quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>  即是定义了非终结符a，对应的字符也是”a”。</p>
<p>FParsec提供了一系列用于连接符号的函数。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let (.&gt;&gt;) (p: Parser&lt;&#39;a,&#39;u&gt;) (q: Parser&lt;&#39;b,&#39;u&gt;) &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      let mutable reply1 &#x3D; p stream</span><br><span class="line">      if reply1.Status &#x3D; Ok then</span><br><span class="line">          let stateTag1 &#x3D; stream.StateTag</span><br><span class="line">          let reply2 &#x3D; q stream</span><br><span class="line">          let error &#x3D; if isNull reply1.Error then reply2.Error</span><br><span class="line">                      elif stateTag1 &lt;&gt; stream.StateTag then reply2.Error</span><br><span class="line">                      else mergeErrors reply2.Error reply1.Error</span><br><span class="line">          reply1.Error  &lt;- error</span><br><span class="line">          reply1.Status &lt;- reply2.Status</span><br><span class="line">      reply1</span><br></pre></td></tr></table></figure>

<p>  这个符号是将两个非终结符连接起来，形成一个新的非终结符的函数。<br>  比如说：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let A &#x3D; charReturnE &quot;a&quot; &quot;a&quot;</span><br><span class="line">let B &#x3D; charReturnE &quot;a&quot; &quot;a&quot;</span><br><span class="line">let C &#x3D; A .&gt;&gt; B</span><br></pre></td></tr></table></figure>

<p>  实际上就是：</p>
<p>  $$ A \rightarrow a $$</p>
<p>  $$ B \rightarrow b $$</p>
<p>  $$ C \rightarrow AB $$</p>
<p>  的实现。</p>
<p>FParsec本质上是一个回退解析器，但它的性能却相当不错。这是因为它对选择符号(&lt;|&gt;)的实现：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let (&lt;|&gt;) (p1: Parser&lt;&#39;a,&#39;u&gt;) (p2: Parser&lt;&#39;a,&#39;u&gt;) : Parser&lt;&#39;a,&#39;u&gt; &#x3D;</span><br><span class="line">  fun stream -&gt;</span><br><span class="line">      let mutable stateTag &#x3D; stream.StateTag</span><br><span class="line">      let mutable reply &#x3D; p1 stream</span><br><span class="line">      if reply.Status &#x3D; Error &amp;&amp; stateTag &#x3D; stream.StateTag then</span><br><span class="line">          let error &#x3D; reply.Error</span><br><span class="line">          reply &lt;- p2 stream</span><br><span class="line">          if stateTag &#x3D; stream.StateTag then</span><br><span class="line">              reply.Error &lt;- mergeErrors reply.Error error</span><br><span class="line">      reply</span><br></pre></td></tr></table></figure>

<p>  我们看到，如果第一个Parser失败，<strong>当且仅当在stateTag没有改变时</strong>，才会进行用第二个Parser进行解析。</p>
<p>  这个stateTag，实际上就是position，也就是是当前解析到的位置。如此设计，保证了这个Parser<strong>仅仅会回退一个字符</strong>，因为如果第一个字符是匹配的，position就发生了变化。如此设计，使得它在某种意义上具有了$$LL(1)$$的特性。</p>
<p>  当然，我们也可以使用attempt强行使它回退。</p>
<p>针对下推自动机无法识别左递归的问题，FParsec引入了一个算符优先级解析器，帮助我们识别(1 + 1 - 2)一类的式子。</p>
<p>个人认为FParsec是一个不错的东西。但是F#和Haskell一样，本身语言设计有诸多麻烦之处，实际开发体验并没有特别舒服。</p>
<h3 id="Parser-Generator"><a href="#Parser-Generator" class="headerlink" title="Parser Generator"></a>Parser Generator</h3><p>这个东西应该是最为正统的方式了。Parser Generator可以做到由文法直接生成代码，我们不太需要关系内部是如何实现的。这个东西的集大成者是yacc，我们没什么好说的。</p>
<h3 id="算符优先级解析器"><a href="#算符优先级解析器" class="headerlink" title="算符优先级解析器"></a>算符优先级解析器</h3><p>我们并不陌生，大名鼎鼎的调度场算法即是这类解析器的一种，这里也不耗费笔墨了。</p>
<h2 id="从解析树到语法树"><a href="#从解析树到语法树" class="headerlink" title="从解析树到语法树"></a>从解析树到语法树</h2><p>解析树，顾名思义，就是解析器生成的树。这里有两个问题：</p>
<ul>
<li>逻辑上的解析树是唯一的，也就是生成文法生成句子的那棵生成树。</li>
<li>一个可以正确识别出输出符号串的解析器，一定是正确地构建出解析树了的，但是这颗解析树是逻辑上的，而非实现上的。实现上的解析树是什么样的，需要一一讨论。</li>
</ul>
<p>语法树则不同，语法树和解析树的关系是若即若离的：</p>
<ul>
<li>语法树的节点并不是解析器自动生成的，而是人为设计的。</li>
<li>即使没有Parser，我们也可以直接根据想法（<strong>而不是根据生成文法</strong>），构建出语法树。</li>
<li>一般来说，我们的Parser会在解析的同时，将解析时映射为语法树。</li>
</ul>
<p>我们考察两个有代表性的解析器–递归向下解析器与Yacc生成的解析器–是如何构建出解析树，并将其映射为语法树的。</p>
<h3 id="递归向下解析器的情况"><a href="#递归向下解析器的情况" class="headerlink" title="递归向下解析器的情况"></a>递归向下解析器的情况</h3><p>以如下文法为例：</p>
<p>$$ S \rightarrow A $$</p>
<p>$$ A \rightarrow M $$</p>
<p>$$ A \rightarrow M + A $$</p>
<p>$$ M \rightarrow D * M $$</p>
<p>$$ M \rightarrow D $$</p>
<p>$$ D \rightarrow int | (A) $$</p>
<p>这文法定义了一个支持加乘两种运算的式子。</p>
<p>我们用C#实现一下；</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RecursiveDesentParser</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Parser</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">string</span> Target &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> pointer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> Node head = <span class="keyword">new</span> Node(<span class="string">&quot;S&quot;</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Parser</span>(<span class="params"><span class="keyword">string</span> s</span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Target = s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Parse</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            <span class="keyword">var</span> success = (head = ParseA()) != <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">return</span> ParseEpsilon() &amp;&amp; success;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Node now = ParseM();</span><br><span class="line">            <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> Node <span class="title">ParseM</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>        &#123;</span><br><span class="line">            Node now = ParseD();</span><br><span class="line">            <span class="keyword">if</span>(now != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;*&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">                    nodes.Add(now);</span><br><span class="line">                    <span class="keyword">var</span> tail = ParseM();</span><br><span class="line">                    nodes.Add(tail);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;*&quot;</span>, nodes);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 以下代码略</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在来解析这样的式子:</p>
<p>$$ 1 + 2 * 3 $$</p>
<p>为了更好地展示解析的过程，我们需要把整个解析的所有调用都画出来：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ParseA</span><br><span class="line">  ParseM</span><br><span class="line">    ParseD : 1</span><br><span class="line">  ParseChar : +</span><br><span class="line">  ParseA</span><br><span class="line">    ParseM</span><br><span class="line">      ParseD : 2</span><br><span class="line">      ParseChar : *</span><br><span class="line">      ParseM</span><br><span class="line">        ParseD : 3</span><br></pre></td></tr></table></figure>

<p>我们发现：<strong>调用函数的过程，自然地形成了一颗解析树！</strong>，这也正是递归向下解析器的一大特性。</p>
<p>调用函数的过程本身就是解析树，将解析树映射为语法树的做法就呼之欲出了：将返回值作为语法树的节点，在每个函数内部实现解析树到语法树的节点的映射：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">ParseA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node now = ParseM();</span><br><span class="line">    <span class="keyword">if</span> (now != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ParseChar(<span class="string">&#x27;+&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Node&gt; nodes = <span class="keyword">new</span> List&lt;Node&gt;();</span><br><span class="line">            nodes.Add(now);</span><br><span class="line">            <span class="keyword">var</span> tail = ParseA();</span><br><span class="line">            nodes.Add(tail);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Node(<span class="string">&quot;+&quot;</span>, nodes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> now; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个函数里，我们把自然形成的这个解析树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">  M</span><br><span class="line">  +</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>

<p>映射成了这样的语法树：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+</span><br><span class="line">  M</span><br><span class="line">  A</span><br></pre></td></tr></table></figure>

<h3 id="Yacc的情况"><a href="#Yacc的情况" class="headerlink" title="Yacc的情况"></a>Yacc的情况</h3><p>yacc是一个LALR(1)文法的Parser Generator. 它产生的分析器是一个自底向上的确定型分析器。</p>
<p>自底向上的意思是，它对应一个这样的自动机：</p>
<p>（在下面的示意中, .表示在.之前的位置已经被分析完了）</p>
<p>这个自动机的输入是一个字符串，它开始的状态是当然是:</p>
<p>$$ .a_{0}a_{1}a_{2}a_{3} $$</p>
<p>这个自动机还具有一个栈，在开始状态，栈中没有元素。</p>
<p>$$ S $$</p>
<p>这个自动机有两种操作：</p>
<ul>
<li>读入一个字符，把字符放到栈里。</li>
<li>把栈里的字符进行规约，化成别的符号。</li>
</ul>
<p>它不断地进行这两个操作，直至栈中得到开始符号为止。</p>
<p>以下面的语法和输入字符为例：</p>
<p>$$ S \Rightarrow A $$</p>
<p>$$ A \rightarrow Aa | a $$</p>
<p>$$ aaaa $$</p>
<p>首先，开始的状态是：</p>
<p>$$ 栈：$$</p>
<p>$$ .aaaa $$</p>
<p>移进一个a：</p>
<p>$$ 栈：a $$</p>
<p>$$ a.aaa $$</p>
<p>进行规约：</p>
<p>$$ 栈：A $$</p>
<p>$$ a.aaa $$</p>
<p>再移入一个a：</p>
<p>$$ 栈：Aa $$</p>
<p>$$ aa.aa $$</p>
<p>下面的操作就无需多言了。</p>
<p>这里我们会发现，自底向上的解析器的解析树，实际上体现在“规约”中，<strong>每一次的规约，实际上是以解析树的叶子节点替换解析树的根节点</strong>。</p>
<p>但这样一来，真正的解析树其实没有被留下，也就无法把解析树映射为语法树了。</p>
<p>为了解决这个问题，yacc引入了一个“内容栈”和“符号栈”的概念。</p>
<ul>
<li>内容栈：栈里是类型为YYSTYPE的值，它是保存结果用的栈。</li>
<li>符号栈：我们刚才说得用来分析的栈。</li>
</ul>
<p>这两个栈到底是怎么一回事呢？我们来看一个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"> typedef struct node</span><br><span class="line"> &#123;</span><br><span class="line"> struct node *left;</span><br><span class="line"> struct node *right;</span><br><span class="line"> char *token;</span><br><span class="line"> &#125; node;</span><br><span class="line"> node *mknode(node *left, node *right, char *token);</span><br><span class="line"> void printtree(node *tree);</span><br><span class="line">#define YYSTYPE struct node *</span><br><span class="line">%&#125; </span><br><span class="line"></span><br><span class="line">exp : term &#123;$$ &#x3D; $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; </span><br></pre></td></tr></table></figure>

<p>不难看出，node是语法树的节点类型，而那句</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YYSTYPE struct node *</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>就是将内容栈的元素类型定义为node*指针类型。</p>
<p>下面的那句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">exp : term &#123;$$ &#x3D; $1;&#125;</span><br><span class="line"> | exp PLUS term &#123;$$ &#x3D; mknode($1, $3, &quot;+&quot;);&#125;</span><br><span class="line"> | exp MINUS term &#123;$$ &#x3D; mknode($1, $3, &quot;-&quot;);&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果除去大括号，就是生成文法；而大括号里面的内容，则是对每条文法在<strong>内容栈</strong>上的操作，这个写法表示，在运用这条文法进行规约时，将内容栈上的对应元素拿出，并压入新构造的node*指针。</p>
<p>这样一来，我们又实现了从解析树映射到语法树的操作。</p>
<h2 id="需要注意的几个问题"><a href="#需要注意的几个问题" class="headerlink" title="需要注意的几个问题"></a>需要注意的几个问题</h2><h3 id="不要给Parser增加太多负担"><a href="#不要给Parser增加太多负担" class="headerlink" title="不要给Parser增加太多负担"></a>不要给Parser增加太多负担</h3><p>有些人想要在解析阶段就识别出来这种语法错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a = <span class="number">0</span>;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>

<p>如果真的想做，这需要CSG解析。而CSG解析并没有一个很好的算法，所以，应该放弃这种不切实际的想法，在后面的阶段再检查这种错误。</p>
<h3 id="最好不要实现Parser"><a href="#最好不要实现Parser" class="headerlink" title="最好不要实现Parser"></a>最好不要实现Parser</h3><p>通过上面的描述，可以看到Parser是一个苦大仇深的行业。如果你实现一个复杂的语法，它的Parser会非常复杂，这会耗尽你对程序语言的热情。所以，让我们一起来实现Lisp吧！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/25/2020-4-25-parser2/" data-id="ckg4mhp39001x17sb4lxy5zod" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-04-21-CLanguage" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/21/2020-04-21-CLanguage/" class="article-date">
  <time datetime="2020-04-21T00:00:00.000Z" itemprop="datePublished">2020-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/21/2020-04-21-CLanguage/">谈谈C语言的两个问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="正确理解函数名"><a href="#正确理解函数名" class="headerlink" title="正确理解函数名"></a>正确理解函数名</h2><p>只有正确理解函数名，才能正确使用函数指针。</p>
<p>函数指针是C语言里一个比较重要的特性。它实现了某种意义上的高阶函数，使得我们可以把函数作为参数和返回值。</p>
<p>我们知道，函数指针也就是一个变量，里面存储着指向的函数的地址。一个比较奇怪的问题是，以下两种写法在绝大多数编译器的眼里都是正确的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*p)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">p pointer = func; <span class="comment">//写法1</span></span><br><span class="line">p pointer = &amp;func; <span class="comment">//写法2</span></span><br></pre></td></tr></table></figure>

<p>有些人会这样解释：对一个函数取地址仍然得到函数本身。</p>
<p>用这个解释，我们可以解决&amp;&amp;func、&amp;&amp;&amp;func的问题，它们仍然会得到func本身。但我们很快就会觉得前一种写法本身与其他指针不太相容，比如说，你永远无法写出这样的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> p = a;</span><br></pre></td></tr></table></figure>

<p>这么想来，我们不得不怀疑<em>对一个函数取地址仍然得到函数本身</em>这个说法的合理性。其实，问题的关键在于函数名究竟被处理为了什么。</p>
<p>答案很简单，<strong>函数名被处理为一个地址字面量值</strong>。</p>
<p>无论你对此有何评价，Clang、MSVC、GCC都是这样实现的。基于此，我们应该理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p pointer = func;</span><br></pre></td></tr></table></figure>

<p>的真正意思是，把func的地址赋给pointer。</p>
<p>所以，我们不能这样去写程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*p)</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> p func;</span><br><span class="line"></span><br><span class="line">func2(p func)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  func2(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//func.c</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这么写，你会惊喜地发现func2函数传入的是func函数编译后的二进制代码的前四位。这是因为编译器认为main.c中的func是一个变量，而对其取地址。但实际上func是一个字面量，本身就是要取的地址中的值了。</p>
<p>你可能会问了，这种不正确的写法为什么还可以正常编译链接呢？</p>
<p>这就要问问链接器了。</p>
<h2 id="正确理解链接过程"><a href="#正确理解链接过程" class="headerlink" title="正确理解链接过程"></a>正确理解链接过程</h2><p>链接器是石器时代的产物。由于C实际上是被编译为汇编后，再生成目标文件，最后被链接，实际上链接器是给汇编语言用的。</p>
<p>而这就带来了一大问题：链接的接口，即符号表（记录所有符号）与重定向表（记录要被重定向的符号），是没有C语言的类型信息的。</p>
<p>也就是说，每当你使用extern关键字声明外部引用时，<strong>你实际上是放弃了对该引用的静态类型检查</strong>。</p>
<p>而C++则不会有这个问题。你可以将上面的代码改成C++文件名或用C++编译器编译，会发现链接器错误。因为C++有名称修饰，它会将符号做处理，实际上附加了类型信息。但是，<strong>名称修饰不蕴含在C++的标准中，各家编译器厂商有自己的实现</strong>，所谓的<em>C++ ABI不兼容</em>，这个问题也占了一席之地。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/21/2020-04-21-CLanguage/" data-id="ckg4mhp1y000l17sb07r3bgd1" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-04-03-net_class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/03/2020-04-03-net_class/" class="article-date">
  <time datetime="2020-04-03T00:00:00.000Z" itemprop="datePublished">2020-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/03/2020-04-03-net_class/">也谈我校在疫情期间不开设网课的诸问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="从一篇文章谈起"><a href="#从一篇文章谈起" class="headerlink" title="从一篇文章谈起"></a>从一篇文章谈起</h2><p>我校，即中山大学，在2020年2月8日–应该开学而没有开学的日子–起，至今没有组织<strong>全校性的</strong>、<strong>算学分的</strong>网课。几乎两个月过去了，我过着田园牧歌式的生活。每天读读书、看看动画、搞搞逆向，尽力做好吃的饭，写优雅的代码，颇有几分“采菊东篱下，悠然见南山”的乐趣。</p>
<p>不过，我们必须承认，这种景象是暗流涌动、危机四伏的。有一位同学就看到了这种危机，奋笔疾书、笔力千钧地写出了一篇文章，痛斥我校教务部不作为，<strong>不过不知道为什么，他已经自己删除了这篇文章</strong>。</p>
<p><img src="https://pic.downk.cc/item/5e86e16a504f4bcb04a6f014.jpg" alt="0"></p>
<p>我对这个文章所反映的问题的评价，正如截图上说的那样：</p>
<p><img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa5991.jpg" alt="1"></p>
<p><img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa5998.jpg" alt="2"></p>
<p><img src="https://pic.downk.cc/item/5e86e5bc504f4bcb04aa599d.jpg" alt="3"></p>
<p>如果具体一点的话，我们引用一下中央巡视组对<strong>山东大学</strong>的反馈意见就好，出处见<a target="_blank" rel="noopener" href="http://news.cctv.com/2017/06/17/ARTIFy0sSrjM7cQrHCDGUAP5170617.shtml">此处</a></p>
<blockquote>
<p>学习贯彻中央决策部署在一些方面存在表面化、形式化、走过场问题；发展理念和办学方针存在一些偏差，偏于注重外延扩张，内涵提升不够；<strong>以学生为本、为学生服务意识不够到位</strong>。</p>
</blockquote>
<h2 id="随便谈谈"><a href="#随便谈谈" class="headerlink" title="随便谈谈"></a>随便谈谈</h2><p>那篇文章，用四个字概括，就是<strong>吊民伐罪</strong>。但，谈吊民，在大多数时候是没有意义的；谈伐罪，我觉得如果学生们可以决定中大的人事任免的话，恐怕很多干部要被免职，而现实中他们还都在悠游地履职，所以也是没有意义的。</p>
<p>吊民伐罪，最多是情绪的宣泄，而不能解决问题。</p>
<p>我认为，中大在两个月的表现，是部分失职的。</p>
<p>为什么说部分失职呢？</p>
<p>搞健康情况申报、湖北同学补助，虽然有点流于形式，但总地来看，中大在学生疫情防控上，是合格的。<strong>在健康申报这件事上，某些同学反而是不合格的。</strong></p>
<p>我们也知道，用这两个月混乱的网课情况当答卷，是难以及格的。</p>
<p>不过，如果把这次事件比作一场游戏的话，游戏最多只进行到了中间的阶段，此时就妄下断语，也是不科学的。</p>
<p>我把所有情绪化的东西剔除掉，得到中大需要给这两个月的不作为擦屁股的内容如下：</p>
<ul>
<li>如何解决暑假已然耗尽的窘迫局面？</li>
<li>如何和其他开设网课的高校接轨？包括但不限于保研考研、暑期夏令营之类的问题。</li>
<li>现在的情况是，某些学院开设了网课，那么这些学院的网课是否算学分？</li>
<li>如何在有些学院开设了网课，有些学院没有开设网课的情况下，编排出一个统一的校历？</li>
<li>……</li>
</ul>
<p>我觉得，如果中大能够交出一份令人满意的答卷，总体上来看教务人员还是尽职的。</p>
<p>不要忘了《三国演义》里庞统的故事：</p>
<blockquote>
<p>张飞领了言语，与孙乾同至耒阳县。军民官吏，皆出郭迎接，独不见县令。飞问曰：“县令何在？”同僚覆曰：“庞县令自到任及今，将百馀日，县中之事，并不理问，每日饮酒，自旦及夜，只在醉乡。今日宿酒未醒，犹卧不起。”</p>
</blockquote>
<blockquote>
<p>张飞大怒，欲擒之。孙乾曰：“庞士元乃高明之人，未可轻忽。且到县问之。如果于理不当，治罪未晚。”飞乃入县，正厅上坐定，教县令来见。统衣冠不整，扶醉而出。飞怒曰：“吾兄以汝为人，令作县宰，汝焉敢尽废县事？”统笑曰：“将军以吾废了县中何事？”飞曰：“汝到任百馀日，终日在醉乡，安得不废政事？”统曰：“量百里小县，些许公事，何难决断？将军少坐，待我发落。”随即唤公吏，将百馀日所积公务，都取来剖断，吏皆纷然赍抱案卷，上厅诉词。被告人等，环跪阶下。统手中批判，口中发落，耳内听词，曲直分明，并无分毫差错，民皆叩首拜伏。不到半日，将百馀日之事，尽断毕了，投笔于地，而对张飞曰：“所废之事何在？曹操，孙权，吾视之若掌上观文，量此小县，何足介意！”</p>
</blockquote>
<p>在发表意见之前，我要提醒一下，这件事在《三国志》里的版本，是这样的：</p>
<blockquote>
<p>先主领荆州，统以从事守耒阳令，在县不治，免官。</p>
</blockquote>
<p>庞统那样的凤凰，“在县不治”尚且要免官，如果某些人“在校不治”，那么应该做些什么呢？</p>
<p><a target="_blank" rel="noopener" href="http://www.xinhuanet.com/politics/2020-01/31/c_1125515085.htm">新华社有篇社论</a>，我引用一些在这里：</p>
<blockquote>
<p>各级党委要在这场严峻斗争的实践中考察识别干部，激励引导广大党员、干部在危难时刻挺身而出、英勇奋斗、扎实工作，经受住考验。</p>
</blockquote>
<blockquote>
<p>考察识别干部，功夫要下在平时，并注意重大关头、关键时刻。</p>
</blockquote>
<blockquote>
<p>对表现突出的，要表扬表彰、大胆使用；对不敢担当、作风飘浮、落实不力的，甚至弄虚作假、失职渎职的，要严肃问责。</p>
</blockquote>
<p>如果中大教务人员真的不能交出一份让教职工和学生都满意的答卷，最好的方法也不是在公众号里宣泄情绪，而是要反馈一下某些人在疫情期间，履职不力的事实：</p>
<p><img src="https://pic.downk.cc/item/5e86edab504f4bcb04b15e5a.jpg" alt="4"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/04/03/2020-04-03-net_class/" data-id="ckg4mhp1x000i17sbb0nj0x1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2020-3-27-what-to-watch-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/27/2020-3-27-what-to-watch-1/" class="article-date">
  <time datetime="2020-03-27T00:00:00.000Z" itemprop="datePublished">2020-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/27/2020-3-27-what-to-watch-1/">看点什么（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="看点什么是什么"><a href="#看点什么是什么" class="headerlink" title="看点什么是什么"></a>看点什么是什么</h2><p>这个博客的专业气息太浓厚了，看到这个博客的人，可能以为我生活中全都是计算机，实际上的图景和此大相径庭。王垠的博客有他喷《星际穿越》的一篇博文和不少人 生 感 悟（到 处 乱 喷），我的博客里也应该有一些富有生活情趣的东西。这栏目就用来安利（和批评）各种文艺作品吧。</p>
<h2 id="看点什么呢？"><a href="#看点什么呢？" class="headerlink" title="看点什么呢？"></a>看点什么呢？</h2><p>有个成语叫“虎头蛇尾”。这当然不是什么褒义词，但是，如果头都不是“虎”的话，那么尾恐怕也只能是“蛇”了。在第一期里，我当然要把我最喜欢的作品拿出来展示。这一期，应该叫“看点我最喜欢看的”</p>
<h3 id="小说篇"><a href="#小说篇" class="headerlink" title="小说篇"></a>小说篇</h3><p>熟悉我的人，可能在看到标题之后就知道要我在这个版块说什么（可惜这两年这种人已经几近绝迹）。没错，就是那本书，那本我很喜欢的书，那本在我瞟了一眼第二章的第一句话以后就一下子击穿了我的书–《玩笑》。但这本书不宜多说，多说几句话就是严重的恶劣的剧透行为。个人认为这是米兰昆德拉最好的作品。之后的作品也不能说不好，但个人色彩特别浓厚。有些人喜欢他的那种风格，有些人不喜欢，我可能是后者吧。</p>
<h3 id="动画篇"><a href="#动画篇" class="headerlink" title="动画篇"></a>动画篇</h3><p>自从高三考完化学竞赛的那几天开始看动画以来，看过的作品也有一定数目了。这一期我写的是“我最喜欢看的”，而不是我认为最优秀的。所以《星际牛仔》这一类的动画就不写了。当然，如果你没有看过《星际牛仔》，那最好还是看看，这动画的优秀程度，是超过我将要谈到的这几部动画的。</p>
<h4 id="《机动警察》系列"><a href="#《机动警察》系列" class="headerlink" title="《机动警察》系列"></a>《机动警察》系列</h4><p><img src="https://akcp.kanfanba.com/wp-content/uploads/2019/11/%E6%9C%BA%E5%8A%A8%E8%AD%A6%E5%AF%9F-%E4%B8%9C%E4%BA%AC%E6%AF%81%E7%81%AD%E6%88%98.jpg" alt="patlabor"></p>
<p>一个让人喜欢看的动画，其先决条件是“有趣”。《机动警察》在这方面做得很出彩。它首先是很有趣的，大多数人看到所谓的“真实系机战番”，往往下意识地联系到《机动战士高达》、《宇宙战舰大和号》一类的太空歌剧。“史诗感”、“沉重”、“黑深残”之类的词是它们的注脚。《机动警察》告诉了我们，机战可以是另一种机战，真实可以是另一种真实。它就像一碗精心烹制的清汤面，少盐少油，味道是平淡甚至平庸的。但，它筋道爽快的口感和星星点点整整齐齐的葱花都在提醒着你，这碗面，没这么简单。</p>
<p>另外，不要看了两集就说是子供向就弃了好不？这应该是“合家欢向”，剧场版2以及OVA完全是成人向，也就第一集和第二集稍显幼稚一些。</p>
<h4 id="《物语系列》"><a href="#《物语系列》" class="headerlink" title="《物语系列》"></a>《物语系列》</h4><p><img src="https://pic.downk.cc/item/5e7f4ec8504f4bcb04885881.jpg" alt="monogatari"></p>
<p>如果说《机动警察》是清汤面的话，这个系列动画，绝对是麻辣小龙虾和四川火锅一类的东西。这十部动画的魅力不需要我说什么，任何一个第一次看《化物语》的人都会见识到她独一无二的风格和感觉。唯一需要提醒的是，这部动画有一定的卖肉倾向，其血腥程度也是不遑多让。如果不太能接受这些元素，那就最好不要看了，因为这两种颜色的东西贯穿整个系列始终，有些时候还对剧情发展起着关键性的作用。</p>
<h4 id="《新世纪福音战士》"><a href="#《新世纪福音战士》" class="headerlink" title="《新世纪福音战士》"></a>《新世纪福音战士》</h4><p><img src="https://cdn.vox-cdn.com/thumbor/SYiIF-623aJEsMLH5ceEnGWWQXw=/0x0:1280x1205/1200x800/filters:focal(514x213:718x417)/cdn.vox-cdn.com/uploads/chorus_image/image/64060202/tumblr_nzss2qZIyT1suxi1yo1_1280.0.jpg" alt="eva"></p>
<p>我的头像和网名的出处（ayanami是绫波嘛），必须推荐一下。看这部动画没必要带着什么观看神作的心情，放松地、享受地去看就好，前13集是很好看的，在各种意义上都是。当然，如果你也想对剧中的各种意象进行解释，成为EVA学家的话，也没有什么不好。</p>
<h4 id="《全部成为F》"><a href="#《全部成为F》" class="headerlink" title="《全部成为F》"></a>《全部成为F》</h4><p><img src="https://pic.downk.cc/item/5e7f507e504f4bcb0489ef81.jpg" alt="ffff"></p>
<p>这部动画，我推荐程序员去看。非程序员当然也可以看，但可能没法经历那种特别的感受。另外，看完之后不要忘了看看我的复现：<a target="_blank" rel="noopener" href="https://ayanamists.github.io/index.php/2019/07/25/ffff/">编写程序验证《全部成为F》中的的巧妙trick</a></p>
<h3 id="漫画篇"><a href="#漫画篇" class="headerlink" title="漫画篇"></a>漫画篇</h3><p>这个模块我们略去热度特别高和名气特别大的漫画，比如《进击的巨人》、《约定的梦幻岛》等等，也略去年代特别久远的漫画，比如《火之鸟》等等。</p>
<h4 id="《魔偶马戏团》"><a href="#《魔偶马戏团》" class="headerlink" title="《魔偶马戏团》"></a>《魔偶马戏团》</h4><p><img src="https://pic.downk.cc/item/5e7f5042504f4bcb0489be61.jpg" alt="魔偶"></p>
<p>这部作品，我在一篇博客中提到过：<a target="_blank" rel="noopener" href="https://ayanamists.github.io/index.php/2019/07/17/maxituan/">魔偶马戏团：不幸的动画与伟大的原作</a>。此处，我想把藤田和日郎老师在《潮与虎》封面上写的一句话复读过来，可能会对理解他的作品起很大帮助：</p>
<blockquote>
<p>我从小就不喜欢我老爸老妈总是在我睡前念的《卖火柴的小女孩》这个故事。我不知道为什么那么可怜的女孩要有那么可怜的遭遇，但我也只能空虚地挥拳捶打书里面的插画。于是我就想出可以代替我的拳头的家伙。而潮与虎–它们正是这样的家伙。</p>
</blockquote>
<p>《魔偶马戏团》虽然在日本可能是热点相当高的漫画，但在中国的热度不算很高，有必要在此处拿出来介绍一下。</p>
<h4 id="《赌博默示录》系列"><a href="#《赌博默示录》系列" class="headerlink" title="《赌博默示录》系列"></a>《赌博默示录》系列</h4><p><img src="https://pic.downk.cc/item/5e7f50c3504f4bcb048a28bb.jpg" alt="赌博"></p>
<p>如果人的心理有形状的话，那么，绝望长什么样？希望长什么样？贪欲长什么样？虐待欲长什么样？死而复生生而复死之后的绝望，又长什么样呢？这部漫画用它极为粗犷（烂 得 要 命）的画工给这个问题交了一张非常优秀的答卷。</p>
<h4 id="《化物语》"><a href="#《化物语》" class="headerlink" title="《化物语》"></a>《化物语》</h4><p>为什么上面已经提到了《物语系列》的动画，还要再说一下《化物语》漫画呢？答案是，这部漫画的画面相当不错。</p>
<p><img src="https://pic.downk.cc/item/5e7f45ee504f4bcb047fc2ba.jpg" alt="化物语"></p>
<p>自行感受吧。</p>
<h4 id="《青色火焰》"><a href="#《青色火焰》" class="headerlink" title="《青色火焰》"></a>《青色火焰》</h4><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTUPc8YqcQv3kWSkQU9bNhoSu7q-DeHNyY08aYoa06PggTvyFEM" alt="青色火焰"></p>
<p>从小到大，我们常常会被问到这样一个问题“你的梦想是什么？”。“我的梦想，是……”</p>
<p>咳咳，太羞耻了说不出来。</p>
<p>这个的主人公（即作者小号），在上世纪80年代的第一年就笃定了自己对于这个问题的回答：“我要成为漫画家！”</p>
<p>这部漫画，就是他追梦之路的全景式记录。</p>
<p>我用一句话来概括一下漫画所展示的这条道路吧：</p>
<p><strong>追求梦想的道路，是一条布满荆棘的道路。为了达到光辉的顶点，你必须舍弃一些东西……一些很重要的东西。</strong></p>
<h3 id="电影篇"><a href="#电影篇" class="headerlink" title="电影篇"></a>电影篇</h3><h4 id="《美国丽人》"><a href="#《美国丽人》" class="headerlink" title="《美国丽人》"></a>《美国丽人》</h4><p><img src="https://pic.downk.cc/item/5e7f5203504f4bcb048b3dba.jpg" alt="美国丽人"></p>
<p>说起“一个中年大叔和女高中生的故事”，我们总会想到《恋如雨止》，最近还有《女儿的朋友》。但这两部漫画的高度，恐怕是难以企及《美国丽人》的。</p>
<p>第一次看这部电影的时候，我尚处对某些东西很好奇的年龄，当时观看这部影片，我完全是出于猎奇和看女主福利镜头的动机。</p>
<p>现在想来，那时候的我还真是好笑呢。这部影片真正的东西，根本不在“性”上，而在（此处不剧透）上。</p>
<p>由于这部影片的表达手法并不晦涩，我不能对其主旨说得太多，但这部影片真的不是靠着“中年大叔和JK的不伦之恋”的噱头卖肉的，<strong>如果你要观看这部影片，请认真观看</strong></p>
<h4 id="《罪人》"><a href="#《罪人》" class="headerlink" title="《罪人》"></a>《罪人》</h4><p>就一句话吧：小成本的大制作。</p>
<h4 id="《楚门的世界》"><a href="#《楚门的世界》" class="headerlink" title="《楚门的世界》"></a>《楚门的世界》</h4><p>无需多言的神作。不过私以为这部作品，并不只是反乌托邦这个主题而已。</p>
<p>“反乌托邦”是被动的，我们要反对一个监狱式的、高度集权的、被人深度控制的社会。</p>
<p>但如何反对呢？用什么去反对呢？或者说，我们应该用什么样的态度（这种态度能够最大程度地使社会不变成那样的社会）去生活呢？这主人公就很好地回答了这个问题嘛。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/03/27/2020-3-27-what-to-watch-1/" data-id="ckg4mhp2g001f17sb2onvclnv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&amp;laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>