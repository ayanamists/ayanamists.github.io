<!DOCTYPE html><html lang="zh-cn"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="theme-color" content="#7350B9"><meta name="author" content="Ayanamists"><meta name="copyright" content="Ayanamists"><meta name="generator" content="Hexo 5.4.0"><meta name="theme" content="hexo-theme-yun"><title>数据结构 -- 查找 -- 笔记 | aya ⊢ blog</title><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@900&amp;display=swap" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/star-markdown-css@0.1.25/dist/yun/yun-markdown.min.css"><script src="//at.alicdn.com/t/font_1140697_dxory92pb0h.js" async></script><script src="https://cdn.jsdelivr.net/npm/scrollreveal/dist/scrollreveal.min.js" defer></script><script>document.addEventListener("DOMContentLoaded", () => {
  [".post-card",".post-content img"].forEach((target)=> {
    ScrollReveal().reveal(target);
  })
});
</script><link id="light-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism.css" media="(prefers-color-scheme: light)"><link id="dark-prism-css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@latest/themes/prism-tomorrow.css" media="(prefers-color-scheme: dark)"><link rel="icon" href="/favicon.ico"><link rel="mask-icon" href="/favicon.ico" color="#7350B9"><link rel="alternate icon" href="/yun.ico"><link rel="preload" href="/css/hexo-theme-yun.css" as="style"><link rel="preload" href="/js/utils.js" as="script"><link rel="preload" href="/js/hexo-theme-yun.js" as="script"><link rel="prefetch" href="/js/sidebar.js" as="script"><link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin><script id="yun-config">
    const Yun = window.Yun || {};
    window.CONFIG = {"hostname":"ayanamists.xyz","root":"/","title":"云游君的小站","version":"1.6.2","mode":"auto","copycode":true,"page":{"isPost":true},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}.","hits":"${hits} results found","hits_time":"${hits} results found in ${time} ms"},"anonymous_image":"https://cdn.jsdelivr.net/gh/YunYouJun/cdn/img/avatar/none.jpg","fireworks":{"colors":["102, 167, 221","62, 131, 225","33, 78, 194"]}};
  </script><link rel="stylesheet" href="/css/hexo-theme-yun.css"><script src="/js/utils.js"></script><script src="/js/hexo-theme-yun.js"></script><meta name="description" content="前言 查找的基本定义 查找算法的分析和设计 顺序查找算法 二分查找算法与二叉查找树 分块查找 堆&#x2F;优先队列  堆的概念与实现 堆可以用来做什么？   散列表  哈希表的定义 哈希函数 碰撞处理 哈希表的实现 – 我实现的c++版本 Ruby中的哈希表实现  st_table 的哈希函数 st_table的碰撞处理 st_table的扩容 总结       前言 这一章，我们学习了查找这种基本操作">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构 -- 查找 -- 笔记">
<meta property="og:url" content="https://ayanamists.xyz/2019/12/10/2019-12-10-find/index.html">
<meta property="og:site_name" content="aya ⊢ blog">
<meta property="og:description" content="前言 查找的基本定义 查找算法的分析和设计 顺序查找算法 二分查找算法与二叉查找树 分块查找 堆&#x2F;优先队列  堆的概念与实现 堆可以用来做什么？   散列表  哈希表的定义 哈希函数 碰撞处理 哈希表的实现 – 我实现的c++版本 Ruby中的哈希表实现  st_table 的哈希函数 st_table的碰撞处理 st_table的扩容 总结       前言 这一章，我们学习了查找这种基本操作">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-12-10T00:00:00.000Z">
<meta property="article:modified_time" content="2021-09-13T08:53:05.917Z">
<meta property="article:author" content="Ayanamists">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary"><script src="/js/ui/mode.js"></script><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head><body><script defer src="https://cdn.jsdelivr.net/npm/animejs@latest"></script><script defer src="/js/ui/fireworks.js"></script><canvas class="fireworks"></canvas><div class="container"><a class="sidebar-toggle hty-icon-button" id="menu-btn"><div class="hamburger hamburger--spin" type="button"><span class="hamburger-box"><span class="hamburger-inner"></span></span></div></a><div class="sidebar-toggle sidebar-overlay"></div><aside class="sidebar"><script src="/js/sidebar.js"></script><ul class="sidebar-nav"><li class="sidebar-nav-item sidebar-nav-toc hty-icon-button sidebar-nav-active" data-target="post-toc-wrap" title="Table of Contents"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-list-ordered"></use></svg></li><li class="sidebar-nav-item sidebar-nav-overview hty-icon-button" data-target="site-overview-wrap" title="Overview"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-passport-line"></use></svg></li></ul><div class="sidebar-panel" id="site-overview-wrap"><div class="site-info fix-top"><a class="site-author-avatar" href="/about/" title="Ayanamists"><img width="96" loading="lazy" src="/avatar.jpg" alt="Ayanamists"></a><div class="site-author-name"><a href="/about/">Ayanamists</a></div><span class="site-name">aya ⊢ blog</span><sub class="site-subtitle"></sub><div class="site-desciption"></div></div><nav class="site-state"><a class="site-state-item hty-icon-button icon-home" href="/" title="Home"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-home-4-line"></use></svg></span></a><div class="site-state-item"><a href="/archives/" title="Archives"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-archive-line"></use></svg></span><span class="site-state-item-count">49</span></a></div><div class="site-state-item"><a href="/categories/" title="Categories"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-2-line"></use></svg></span><span class="site-state-item-count">8</span></a></div><div class="site-state-item"><a href="/tags/" title="Tags"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="site-state-item-count">48</span></a></div><a class="site-state-item hty-icon-button" href="/about/" title="关于"><span class="site-state-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-information-line"></use></svg></span></a></nav><hr style="margin-bottom:0.5rem"><div class="links-of-author"><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://github.com/ayanamists" title="GitHub" target="_blank" style="color:#181717"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-github-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="mailto:ayanamists@gmail.com" title="E-Mail" target="_blank" style="color:#8E71C1"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-mail-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.douban.com/people/191397140/" title="豆瓣" target="_blank" style="color:#007722"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-douban-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://www.zhihu.com/people/woodwardchenxi" title="知乎" target="_blank" style="color:#0084FF"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu-line"></use></svg></a><a class="links-of-author-item hty-icon-button" rel="noopener" href="https://space.bilibili.com/288120032" title="哔哩哔哩动画" target="_blank" style="color:#FF8EB3"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-bilibili-line"></use></svg></a></div><hr style="margin:0.5rem 1rem"><div class="links"><a class="links-item hty-icon-button" href="/links/" title="友情链接" style="color:dodgerblue"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-heart-line"></use></svg></a></div><br><a class="links-item hty-icon-button" id="toggle-mode-btn" href="javascript:;" title="Mode" style="color: #f1cb64"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-contrast-2-line"></use></svg></a></div><div class="sidebar-panel sidebar-panel-active" id="post-toc-wrap"><div class="post-toc"><div class="post-toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text"> 前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text"> 查找的基本定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text"> 查找算法的分析和设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text"> 顺序查找算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text"> 二分查找算法与二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">6.</span> <span class="toc-text"> 分块查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-number">7.</span> <span class="toc-text"> 堆&#x2F;优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.1.</span> <span class="toc-text"> 堆的概念与实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-number">7.2.</span> <span class="toc-text"> 堆可以用来做什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">8.</span> <span class="toc-text"> 散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text"> 哈希表的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">8.2.</span> <span class="toc-text"> 哈希函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86"><span class="toc-number">8.3.</span> <span class="toc-text"> 碰撞处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0-%E6%88%91%E5%AE%9E%E7%8E%B0%E7%9A%84c%E7%89%88%E6%9C%AC"><span class="toc-number">8.4.</span> <span class="toc-text"> 哈希表的实现 – 我实现的c++版本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ruby%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.5.</span> <span class="toc-text"> Ruby中的哈希表实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#st_table-%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0"><span class="toc-number">8.5.1.</span> <span class="toc-text"> st_table 的哈希函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#st_table%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86"><span class="toc-number">8.5.2.</span> <span class="toc-text"> st_table的碰撞处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#st_table%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="toc-number">8.5.3.</span> <span class="toc-text"> st_table的扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.4.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li></ol></div></div></div></aside><main class="sidebar-translate" id="content"><div id="post"><article class="hty-card post-block" itemscope itemtype="https://schema.org/Article"><link itemprop="mainEntityOfPage" href="https://ayanamists.xyz/2019/12/10/2019-12-10-find/"><span hidden itemprop="author" itemscope itemtype="https://schema.org/Person"><meta itemprop="name" content="Ayanamists"><meta itemprop="description"></span><span hidden itemprop="publisher" itemscope itemtype="https://schema.org/Organization"><meta itemprop="name" content="aya ⊢ blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">数据结构 -- 查找 -- 笔记</h1><div class="post-meta"><div class="post-time" style="display:inline-block"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-line"></use></svg></span> <time title="Created: 2019-12-10 00:00:00" itemprop="dateCreated datePublished" datetime="2019-12-10T00:00:00+00:00">2019-12-10</time><span class="post-meta-divider">-</span><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-calendar-2-line"></use></svg></span> <time title="Modified: 2021-09-13 08:53:05" itemprop="dateModified" datetime="2021-09-13T08:53:05+00:00">2021-09-13</time></div><span class="post-busuanzi"><span class="post-meta-divider">-</span><span class="post-meta-item-icon" title="Views"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg> <span id="busuanzi_value_page_pv"></span></span></span><div class="post-classify"><span class="post-category"> <span class="post-meta-item-icon" style="margin-right:3px;"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-folder-line"></use></svg></span><span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a class="category-item" href="/categories/%E7%AC%94%E8%AE%B0/" style="--text-color:dimgray" itemprop="url" rel="index"><span itemprop="text">笔记</span></a></span></span><span class="post-tag"><span class="post-meta-divider">-</span><a class="tag-item" href="/tags/%E7%AE%97%E6%B3%95/" style="--text-color:var(--hty-text-color)"><span class="post-meta-item-icon"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-price-tag-3-line"></use></svg></span><span class="tag-name">算法</span></a></span></div><div class="post-author"><span class="author-name">ayanamists</span></div></div></header><section class="post-body" itemprop="articleBody"><div class="post-content markdown-body" style="--smc-primary:#7350B9;"><ul>
<li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
<li><a href="#%e6%9f%a5%e6%89%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89">查找的基本定义</a></li>
<li><a href="#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e7%9a%84%e5%88%86%e6%9e%90%e5%92%8c%e8%ae%be%e8%ae%a1">查找算法的分析和设计</a></li>
<li><a href="#%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">顺序查找算法</a></li>
<li><a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91">二分查找算法与二叉查找树</a></li>
<li><a href="#%e5%88%86%e5%9d%97%e6%9f%a5%e6%89%be">分块查找</a></li>
<li><a href="#%e5%a0%86%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97">堆/优先队列</a>
<ul>
<li><a href="#%e5%a0%86%e7%9a%84%e6%a6%82%e5%bf%b5%e4%b8%8e%e5%ae%9e%e7%8e%b0">堆的概念与实现</a></li>
<li><a href="#%e5%a0%86%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e5%81%9a%e4%bb%80%e4%b9%88">堆可以用来做什么？</a></li>
</ul>
</li>
<li><a href="#%e6%95%a3%e5%88%97%e8%a1%a8">散列表</a>
<ul>
<li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9a%e4%b9%89">哈希表的定义</a></li>
<li><a href="#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">哈希函数</a></li>
<li><a href="#%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">碰撞处理</a></li>
<li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0----%e6%88%91%e5%ae%9e%e7%8e%b0%e7%9a%84c%e7%89%88%e6%9c%ac">哈希表的实现 – 我实现的c++版本</a></li>
<li><a href="#ruby%e4%b8%ad%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ae%9e%e7%8e%b0">Ruby中的哈希表实现</a>
<ul>
<li><a href="#sttable-%e7%9a%84%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">st_table 的哈希函数</a></li>
<li><a href="#sttable%e7%9a%84%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">st_table的碰撞处理</a></li>
<li><a href="#sttable%e7%9a%84%e6%89%a9%e5%ae%b9">st_table的扩容</a></li>
<li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>这一章，我们学习了查找这种基本操作和堆、散列表这两种非常重要的数据结构。<br />
本笔记主要完成了以下工作：</p>
<ul>
<li>总结了关于查找的各种知识点</li>
<li>用ruby语言实现了一个简单的堆模块(这里的模块指module，是ruby中MIX_IN思想的主要实现模式，下面会做简短介绍)，并进行了简单测试</li>
<li>用C++语言实现了一个简单的哈希表，并进行了简单测试</li>
<li>讨论了ruby中哈希表的实现</li>
<li>讨论了stl中std::find, std::binary_search等函数的实现</li>
</ul>
<h2 id="查找的基本定义"><a class="markdownIt-Anchor" href="#查找的基本定义"></a> 查找的基本定义</h2>
<p>查找也可以视为搜索，wikipedia对搜索的定义是：</p>
<blockquote>
<p>在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题域的搜索空间中计算的信息。<br />
其实简单来说，查找就是“找东西”。</p>
</blockquote>
<p>而我们要找的“东西”，严格来说应该叫做“关键字”，或者更学术一些，叫做“键”。找到“键”之后，如果存在一个“键-值映射”，就可以得到其“值”。</p>
<h2 id="查找算法的分析和设计"><a class="markdownIt-Anchor" href="#查找算法的分析和设计"></a> 查找算法的分析和设计</h2>
<p>查找算法实际上包含三个层次的问题：</p>
<ol>
<li>在什么数据结构上查找</li>
<li>如何查找</li>
<li>查找的效率如何</li>
</ol>
<h2 id="顺序查找算法"><a class="markdownIt-Anchor" href="#顺序查找算法"></a> 顺序查找算法</h2>
<p>顺序查找是最朴素的查找，可以用在各种线性表上。在MSVC的stl中，我们有std::find函数实现这个算法：</p>
<p><em>以下代码来自&lt;algorithm&gt;</em></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _InIt, class _Ty&gt;
_NODISCARD inline _InIt find(_InIt _First, const _InIt _Last, const _Ty&amp; _Val) &#123; &#x2F;&#x2F; find first matching _Val
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    return _First;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>_Adl_verify_range是检查参数范围是否有效，_Seek_wrapped函数简单来说是把后一个参数的值赋给前一个参数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
template &lt;class _Ty&gt;
constexpr void _Seek_wrapped(_Ty*&amp; _It, _Ty* const _UIt) &#123;
    _It &#x3D; _UIt;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>实际查找过程在_Find_unchecked函数中：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _InIt, class _Ty&gt;
inline _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty&amp; _Val) &#123;
    &#x2F;&#x2F; find first matching _Val; choose optimization
    &#x2F;&#x2F; activate optimization for pointers to (const) bytes and integral values
    using _Memchr_opt &#x3D; bool_constant&lt;
        is_integral_v&lt;_Ty&gt; &amp;&amp; _Is_any_of_v&lt;_InIt, char*, signed char*, unsigned char*, &#x2F;&#x2F;
            const char*, const signed char*, const unsigned char*&gt;&gt;;

    return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt&#123;&#125;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而这个函数实际上又调用了_Find_unchecked1函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _InIt, class _Ty&gt;
inline _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty&amp; _Val, false_type) &#123;
    &#x2F;&#x2F; find first matching _Val
    for (; _First !&#x3D; _Last; ++_First) &#123;
        if (*_First &#x3D;&#x3D; _Val) &#123;
            break;
        &#125;
    &#125;

    return _First;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>谢天谢地，_Find_unchecked1函数就是主要实现了。我们可以看到整个过程非常简单，就是顺序地查找整个表，如果找到了就退出。</p>
<p>由于模板的存在，在c++中，只要定义了迭代器，一个类就可以使用这个函数进行查找。这也正是对我们抽象描述–查找线性表–的抽象实现。</p>
<p>如果假设等概率，这个算法有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">ASL_{success} = \frac{n + 1}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL_{fail} = n + 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h2 id="二分查找算法与二叉查找树"><a class="markdownIt-Anchor" href="#二分查找算法与二叉查找树"></a> 二分查找算法与二叉查找树</h2>
<p>从上面的分析可以看出，顺序查找查找一次的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的。可不可以有更好的效率呢？</p>
<p>如果假定顺序表是有序的，那么思考这样的结论：</p>
<blockquote>
<p>如果待查询的元素大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n / 2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>，那么，它一定大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n / 2) - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的所有元素。</p>
</blockquote>
<p>这样一来，下一次的查询就可以不管这些元素，直接查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n/2) + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这个区间了。</p>
<p>这实际上已经是一个递归算法了。这个算法的实现很简单，但我们还是来研究一下c++ stl中std::binary_search的实现：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _FwdIt, class _Ty&gt;
_NODISCARD inline bool binary_search(
    _FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val) &#123; &#x2F;&#x2F; test if _Val equivalent to some element, using operator&lt;
    return _STD binary_search(_First, _Last, _Val, less&lt;&gt;());
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面这个binary_search是一个重载的函数，它才是真正用来实现的函数：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; FUNCTION TEMPLATE binary_search
template &lt;class _FwdIt, class _Ty, class _Pr&gt;
_NODISCARD inline bool binary_search(
    _FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val, _Pr _Pred) &#123; &#x2F;&#x2F; test if _Val equivalent to some element, using _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst      &#x3D; _Get_unwrapped(_First);
    const auto _ULast &#x3D; _Get_unwrapped(_Last);
    _UFirst           &#x3D; _STD lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    return _UFirst !&#x3D; _ULast &amp;&amp; !_Pred(_Val, *_UFirst);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这看起来并不是直接递归，而是使用了一个lower_bound函数。这个函数是干什么的呢？显然的，lower_bound的意思是下界，它定义如下：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; FUNCTION TEMPLATE lower_bound
template &lt;class _FwdIt, class _Ty, class _Pr&gt;
_NODISCARD inline _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val, _Pr _Pred) &#123;
    &#x2F;&#x2F; find first element not before _Val, using _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst                &#x3D; _Get_unwrapped(_First);
    _Iter_diff_t&lt;_FwdIt&gt; _Count &#x3D; _STD distance(_UFirst, _Get_unwrapped(_Last));

    while (0 &lt; _Count) &#123; &#x2F;&#x2F; divide and conquer, find half that contains answer
        const _Iter_diff_t&lt;_FwdIt&gt; _Count2 &#x3D; _Count &gt;&gt; 1; &#x2F;&#x2F; TRANSITION, VSO#433486
        const auto _UMid                   &#x3D; _STD next(_UFirst, _Count2);
        if (_Pred(*_UMid, _Val)) &#123; &#x2F;&#x2F; try top half
            _UFirst &#x3D; _Next_iter(_UMid);
            _Count -&#x3D; _Count2 + 1;
        &#125; else &#123;
            _Count &#x3D; _Count2;
        &#125;
    &#125;

    _Seek_wrapped(_First, _UFirst);
    return _First;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数比较麻烦，它返回的是第一个不满足_Pred条件的元素。这里_Pred条件是&lt;，所以返回的是第一个大于等于这个元素的迭代器，<br />
然后binary_search函数就用!(_Pred(_Val, *_Ufirst))这个条件来判断是否相等，这相当于构造了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &gt;= b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &lt;= b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p>显然地，只有当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a == b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>时，表达式才返回真（吐槽一下，这stl写的太“聪明”了）</p>
<p>在二分查找中，成功查找时的ASL为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mrow><mi>i</mi><mo>∗</mo><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mn>1</mn><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></munderover><mrow><mi>i</mi><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><mo>+</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum{i * P(i)} = 1/n*( \sum_{1}^{floor(log(n))}{i * 2^{i}} + ceil(log(n)) * (n - floor(log(n))))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2281180000000003em;vertical-align:-1.267113em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>这个式子过于繁琐，我们假设它的二叉判定树为满二叉树，可以得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi mathvariant="normal">/</mi><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{n - 1}/{n} * log(n + 1) - 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h2 id="分块查找"><a class="markdownIt-Anchor" href="#分块查找"></a> 分块查找</h2>
<p>分块查找采用了块间有序，块内无序的基本思想，建立一个索引表记录块内的最大值或最小值，然后先查索引表，找到对应的块，然后再到块中查询。</p>
<p>stl中的deque实现有这种思想的影子。</p>
<h2 id="堆优先队列"><a class="markdownIt-Anchor" href="#堆优先队列"></a> 堆/优先队列</h2>
<h3 id="堆的概念与实现"><a class="markdownIt-Anchor" href="#堆的概念与实现"></a> 堆的概念与实现</h3>
<p>堆这个词来自于heap。我们最先学习到的heap，指的是C程序运行时环境的一部分–内存动态分配器及其分配的空间，我们在使用malloc函数、new函数（new实际上是一个函数）时都要用到它来分配空间。</p>
<p>但是这里的heap，指的是一种特殊的数据结构，它具有以下特点：</p>
<ul>
<li>分为小顶堆和大顶堆</li>
<li>对自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">floor(n/2) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>有<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i] &lt;= heap[2i + 1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i] &lt;= heap[2i + 2]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p>
</li>
</ul>
<p>其实，第二个特点表明堆可以化为一颗二叉树，这颗二叉树的父亲节点都大于它的子节点。</p>
<p>我们这里用ruby语言实现了一个简单的堆：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">module</span> <span class="token constant">BinaryHeapable</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">insert_to_heap</span></span> element
    target <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>length
    <span class="token keyword">while</span> <span class="token keyword">self</span><span class="token punctuation">[</span>target <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> element <span class="token operator">&amp;&amp;</span> target <span class="token operator">!=</span> <span class="token number">0</span>
      <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span>
      target <span class="token operator">/</span><span class="token operator">=</span> <span class="token number">2</span>
    <span class="token keyword">end</span>
    <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">=</span> element
  <span class="token keyword">end</span>

  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">remove_from_heap</span></span>
    ret <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">self</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token keyword">self</span><span class="token punctuation">.</span>pop
    heap_construct <span class="token number">0</span>
    ret
  <span class="token keyword">end</span>
  
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">convert_to_heap</span></span>
    i <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token keyword">while</span> i <span class="token operator">>=</span> <span class="token number">0</span>
      heap_construct i
      i <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">1</span>
    <span class="token keyword">end</span>
    <span class="token keyword">self</span>
  <span class="token keyword">end</span>

  <span class="token keyword">private</span>
  <span class="token keyword">def</span> <span class="token method-definition"><span class="token function">heap_construct</span></span> target
    what <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">while</span> target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>length
      <span class="token keyword">if</span> target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">&lt;</span> <span class="token keyword">self</span><span class="token punctuation">.</span>length
        what <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span>target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token keyword">self</span><span class="token punctuation">[</span>target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">?</span> target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">:</span> target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
      <span class="token keyword">else</span>
        what <span class="token operator">=</span> target <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span>
      <span class="token keyword">end</span>
      <span class="token keyword">break</span> <span class="token keyword">if</span> <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token keyword">self</span><span class="token punctuation">[</span>what<span class="token punctuation">]</span>
      temp <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span>
      <span class="token keyword">self</span><span class="token punctuation">[</span>target<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">[</span>what<span class="token punctuation">]</span>
      <span class="token keyword">self</span><span class="token punctuation">[</span>what<span class="token punctuation">]</span> <span class="token operator">=</span> temp
      target <span class="token operator">=</span> what
    <span class="token keyword">end</span>
    what
  <span class="token keyword">end</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>ruby 中的module是mix-in思想的载体。只要我们让一个类include这个模块，这个类就获得了“堆化”的能力。特别地，ruby的数组被封装为Array类，而所有的自带类都是可以修改的：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token keyword">class</span> <span class="token class-name">Array</span>
  <span class="token keyword">include</span> <span class="token constant">BinaryHeapable</span>
<span class="token keyword">end</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这样一来，我们就可以按照以下方法使用数组：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>convert_to_heap

<span class="token keyword">while</span> arr<span class="token punctuation">.</span>length <span class="token operator">!=</span> <span class="token number">0</span>
  pp arr<span class="token punctuation">.</span>remove_from_heap
  pp arr
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码会打出：</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby"><span class="token number">8</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">6</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">5</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">0</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在上面的代码中我们看到，堆只需要实现一个操作，就可以搞定建堆和取出堆顶。</p>
<p>这个操作是什么呢？就是如下的操作：</p>
<p>假设一个堆节点的左子树与右子树均已经满足堆序，把以这个堆节点为根的子树调整成堆序。</p>
<p>这个操作实现起来很简单，具体可参加代码。</p>
<p>实现了这个操作后，</p>
<ul>
<li>建堆就是自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">floor(n/2) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>调用这个操作；</li>
<li>取出堆顶就是先将堆顶缓存，再将堆尾和堆顶交换，再对堆顶调用这个操作。</li>
</ul>
<h3 id="堆可以用来做什么"><a class="markdownIt-Anchor" href="#堆可以用来做什么"></a> 堆可以用来做什么？</h3>
<p>堆可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的时间复杂度内完成取出最大/最小元素并调整，这一特性可以作以下用途：</p>
<ul>
<li>堆排序</li>
<li>堆优化Dijkstra和Prim算法</li>
<li>霍夫曼树的实现</li>
<li>etc</li>
</ul>
<h2 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h2>
<h3 id="哈希表的定义"><a class="markdownIt-Anchor" href="#哈希表的定义"></a> 哈希表的定义</h3>
<p>散列表，又称哈希表，是一种极为重要的数据结构。</p>
<p>为什么极其重要呢？因为</p>
<ul>
<li>上文提到的ruby，其内部数据结构有很大一部分是用散列表实现的。</li>
<li>散列表可以用来建立映射，例如把一个字符串映射到一个整数上，这对某些情况是极为有用的(例如图结构笔记中实现的IndexMapping类)。</li>
</ul>
<p>散列表的定义为：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<h3 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数"></a> 哈希函数</h3>
<p>首先必须明确，这里的哈希函数和密码学中的哈希函数实质是一样的，都是一个映射：</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p>
</blockquote>
<p>但是，这里的哈希函数和密码学中的哈希函数侧重点是不一样的：</p>
<p>密码学中的哈希函数主要要求两个性质：</p>
<ol>
<li>均匀性，所有的输出是<em>等概率</em>的</li>
<li>唯一性，要求单射，即是说不能存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a) == f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>高效性（速度）虽然很重要，但远远没有上面两条重要</p>
<p>而这里的哈希函数则要求高效性，因为我们访问哈希表中的元素可能是很频繁的。</p>
<p>所以密码学中的哈希函数用在这里是不太合适的。</p>
<p>教师讲述了6种方法，均以整数为键：</p>
<ol>
<li>直接定址法(Identity hash function)，找一个整数到整数的线性变换</li>
<li>折叠法(Folding)，将整数分为几个部分，每个部分都是目标长度的倍数（最后一部分可以小于目标长度），然后将这几部分作运算（加、移位、异或等等），得到结果之后取目标长度位结果。
<ul>
<li>密码学哈希算法多与这个方法类似</li>
</ul>
</li>
<li>平方取中法(Mid-squares)，先平方，然后取中间的目标长度位</li>
<li>除数余留法（Division hashing），直接取模</li>
<li>代数编码法（Algebraic coding），用数字的不同位作变换。</li>
<li>随机数法，不解释。</li>
</ol>
<h3 id="碰撞处理"><a class="markdownIt-Anchor" href="#碰撞处理"></a> 碰撞处理</h3>
<p>如果发生了碰撞，也即是说，存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a) == f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，那么就需要进行处理，这大致有四种办法：</p>
<ol>
<li>开放定址法
<ul>
<li>线性探测法</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区法<br />
具体讨论略。</li>
</ol>
<h3 id="哈希表的实现-我实现的c版本"><a class="markdownIt-Anchor" href="#哈希表的实现-我实现的c版本"></a> 哈希表的实现 – 我实现的c++版本</h3>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* hashtable.h *&#x2F;

#pragma once
#include &lt;bits&#x2F;stdc++.h&gt;

#define TYPE_KEY char *
#define TYPE_VALUE char *
#define MD5 md5
#define NOT_FIND NULL
#define NUM_NOT_FIND -1

typedef uint64_t (*HASH_FUNC)(char *);
class HashTable
&#123;
public:
    virtual bool insertTo(std::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair) &#x3D; 0;
    virtual bool deleteFrom(TYPE_KEY key) &#x3D; 0;
    virtual uint64_t findByKey(TYPE_KEY key) &#x3D; 0;
    virtual TYPE_VALUE getValueByKey(TYPE_KEY key) &#x3D; 0;
&#125;;

template &lt;typename T&gt;
class LinkHashTableNode
&#123;
public:
    T value;
    LinkHashTableNode *next;
    LinkHashTableNode(T value)
    &#123;
        this-&gt;value &#x3D; value;
        this-&gt;next &#x3D; NULL;
    &#125;
&#125;;

class LinkedHashTable : public HashTable
&#123;
public:
    virtual bool insertTo(std::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair);
    virtual bool deleteFrom(TYPE_KEY key);
    virtual TYPE_VALUE getValueByKey(TYPE_KEY key);
    LinkedHashTable(uint value, HASH_FUNC hashFunction);

private:
    virtual uint64_t findByKey(TYPE_KEY key);
    std::function&lt;uint64_t(TYPE_KEY)&gt; hash;
    std::vector&lt;LinkHashTableNode&lt;TYPE_VALUE&gt; *&gt; nodePool;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;* hashtable.cpp *&#x2F;

#include &quot;.&#x2F;hashtable.h&quot;
#include &quot;md5.h&quot;

LinkedHashTable::LinkedHashTable(uint size, HASH_FUNC hashFunction) : nodePool(size, NULL)
&#123;
    this-&gt;hash &#x3D; hashFunction;
&#125;

uint64_t LinkedHashTable::findByKey(TYPE_KEY key)
&#123;
    uint64_t hash_value &#x3D; this-&gt;hash(key);
    hash_value &#x3D; hash_value % this-&gt;nodePool.size();
    if (this-&gt;nodePool[hash_value] &#x3D;&#x3D; NULL)
    &#123;
        return NUM_NOT_FIND;
    &#125;
    else
    &#123;
        return hash_value;
    &#125;
&#125;

bool LinkedHashTable::insertTo(std::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair)
&#123;
    uint64_t hash_value &#x3D; this-&gt;hash(pair.first);
    hash_value &#x3D; hash_value % this-&gt;nodePool.size();
    auto new_node &#x3D; new LinkHashTableNode&lt;TYPE_VALUE&gt;(pair.second);
    new_node-&gt;next &#x3D; this-&gt;nodePool[hash_value];
    this-&gt;nodePool[hash_value] &#x3D; new_node;
    return true;
&#125;

bool LinkedHashTable::deleteFrom(TYPE_KEY key)
&#123;
    auto hash_value &#x3D; this-&gt;findByKey(key);
    if (hash_value &#x3D;&#x3D; -1)
    &#123;
        return false;
    &#125;
    else
    &#123;
        auto begin &#x3D; this-&gt;nodePool[hash_value];
        this-&gt;nodePool[hash_value] &#x3D; begin-&gt;next;
        delete begin;
        return true;
    &#125;
&#125;

TYPE_VALUE LinkedHashTable::getValueByKey(TYPE_KEY key)
&#123;
    auto hash_value &#x3D; this-&gt;findByKey(key);
    if (hash_value &#x3D;&#x3D; NUM_NOT_FIND)
    &#123;
        return NOT_FIND;
    &#125;
    else
    &#123;
        return this-&gt;nodePool[hash_value]-&gt;value;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们实现了一个很简单的哈希表，采用链地址法进行碰撞处理，采用MD5（这是一个密码学哈希函数）作为哈希函数。</p>
<h3 id="ruby中的哈希表实现"><a class="markdownIt-Anchor" href="#ruby中的哈希表实现"></a> Ruby中的哈希表实现</h3>
<p>我们实现的哈希表，玩具色彩浓厚，特别是直接采用MD5算法这种愚蠢行为，每次查询时，都需要做至少64轮循环，效率是很差的。</p>
<p>所以，本笔记的最后一部分就集中精力来讨论一个工业级哈希表 – ruby中的哈希表。</p>
<p>ruby中的哈希表使用为:</p>
<pre class="line-numbers language-ruby" data-language="ruby"><code class="language-ruby">hash <span class="token operator">=</span> <span class="token punctuation">&#123;</span><span class="token symbol">:a</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"haha"</span><span class="token punctuation">,</span> <span class="token symbol">:b</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"hahaha"</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个数据结构在ruby程序中，使用得特别广泛、特别频繁。如果没有一个优秀的内部实现，ruby程序的性能将会受到很大影响。</p>
<p>笔记篇幅所限，这里不能完整地讨论ruby哈希表底层实现ruby/st.c中1000多行代码的全部内容。这里仅仅讨论一些最重要、和我们所学习内容关系最大的内容。</p>
<p><strong>下面所称 st_table 指的就是ruby内部的哈希表</strong></p>
<h4 id="st_table-的哈希函数"><a class="markdownIt-Anchor" href="#st_table-的哈希函数"></a> st_table 的哈希函数</h4>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 537行 */</span>
    hash_val <span class="token operator">=</span> <span class="token function">do_hash</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> table<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面这段代码表明哈希函数就是do_hash.我们来看一下这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 88行 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">do_hash</span><span class="token expression"><span class="token punctuation">(</span>key<span class="token punctuation">,</span>table<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token class-name">st_index_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token operator">-></span>type<span class="token operator">-></span>hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这段代码似乎不是很好理解，我们来一点点地看：</p>
<p>首先这是一个宏定义，传入两个参数key和table，给出一个值，其类型为st_index_t，也就是哈希表的具体位置（数组下标）</p>
<p>然后来看具体的内容</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token operator">-></span>type<span class="token operator">-></span>hash<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个语法其实是一个函数调用。(table)-&gt;type-&gt;hash是一个函数指针，指向hash函数，key是其参数。</p>
<p>那么想要找到真正的哈希函数，就必须要找到初始化时这个table-&gt;type-&gt;hash被赋了什么值：</p>
<p>哈希表的初始化有些复杂，但是为了讨论的方便还是介绍一下：</p>
<p>首先，所有的初始化都最终被转发到这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">st_table<span class="token operator">*</span>
<span class="token function">st_init_table_with_size</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">st_hash_type</span> <span class="token operator">*</span>type<span class="token punctuation">,</span> <span class="token class-name">st_index_t</span> size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然后实际使用时有三种初始化方法：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">st_table<span class="token operator">*</span>
<span class="token function">st_init_numtable_with_size</span><span class="token punctuation">(</span><span class="token class-name">st_index_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> <span class="token function">st_init_table_with_size</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>type_numhash<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">st_table<span class="token operator">*</span>
<span class="token function">st_init_strtable_with_size</span><span class="token punctuation">(</span><span class="token class-name">st_index_t</span> size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">st_table<span class="token operator">*</span>
<span class="token function">st_init_strcasetable_with_size</span><span class="token punctuation">(</span><span class="token class-name">st_index_t</span> size<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>我们这里只研究第一种st_init_numtable_with_size。这一种看名字就知道是整数对整数的映射。<br />
它传入了一个type_numhash，这看起来是一个全局常量：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">type_numhash</span> <span class="token expression">st_hashtype_num</span></span>
<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">st_hash_type</span> st_hashtype_num <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    st_numcmp<span class="token punctuation">,</span>
    st_numhash<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么，整数对整数的映射实际上应该调用到st_numhash这个函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 1666 - 1683行 */</span>
<span class="token class-name">st_index_t</span>
<span class="token function">st_numhash</span><span class="token punctuation">(</span><span class="token class-name">st_data_t</span> n<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">/*
     * This hash function is lightly-tuned for Ruby.  Further tuning
     * should be possible.  Notes:
     *
     * - (n >> 3) alone is great for heap objects and OK for fixnum,
     *   however symbols perform poorly.
     * - (n >> (RUBY_SPECIAL_SHIFT+3)) was added to make symbols hash well,
     *   n.b.: +3 to remove ID scope, +1 worked well initially, too
     * - (n &lt;&lt; 3) was finally added to avoid losing bits for fixnums
     * - avoid expensive modulo instructions, it is currently only
     *   shifts and bitmask operations.
     */</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">st_index_t</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">>></span><span class="token punctuation">(</span>RUBY_SPECIAL_SHIFT<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token punctuation">(</span>n<span class="token operator">&lt;&lt;</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>n<span class="token operator">>></span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个函数看起来倒是很简单，就是用n做了一些位运算。不过不属于教师讲述的6中方法之一。</p>
<p>这很大程度地激起了我的好奇心：难道Index是32位的整数吗？这个函数没有任何取模操作，如果传入一个很大的n,它该如何处理呢？</p>
<p>不要着急，让我们继续追踪吧：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 584 - 588行 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
key <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">add_direct</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> hash_val<span class="token punctuation">,</span> bin_pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们注意到bin_pos这个参数，因为在add_direct函数中，它会调用new_entry函数，最后会执行这个语句：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 445 行 */</span> 
entry<span class="token operator">-></span>next <span class="token operator">=</span> table<span class="token operator">-></span>bins<span class="token punctuation">[</span>bin_pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
table<span class="token operator">-></span>bins<span class="token punctuation">[</span>bin_pos<span class="token punctuation">]</span> <span class="token operator">=</span> entry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>显然地，bin_pos才是数组查找的真正下标！那么bin_pos是在哪里被设置的呢？一个出乎预料的答案是在FIND_ENTRY宏中：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 582行*/</span>
    <span class="token function">FIND_ENTRY</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> hash_val<span class="token punctuation">,</span> bin_pos<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 344行 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FIND_ENTRY</span><span class="token expression"><span class="token punctuation">(</span>table<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> hash_val<span class="token punctuation">,</span> bin_pos<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">find_entry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">(</span>hash_val<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bin_pos<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">hash_pos</span><span class="token punctuation">(</span>hash_val<span class="token punctuation">,</span> <span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token operator">-></span>num_bins<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>经历了千辛万苦，我们终于来到了真正获取下标的hash_pos宏：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 89行 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">hash_pos</span><span class="token expression"><span class="token punctuation">(</span>h<span class="token punctuation">,</span>n<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>这里可以看到，实际的下标是和哈希表的长度与之后的结果。</p>
<p>有人可能会问，为什么要有两套键（一个hash_val，一个bin_pos）呢？我们下面会谈到，这里埋个伏笔。不过在谈到这个问题之前，我们先要看看它的碰撞处理。</p>
<h4 id="st_table的碰撞处理"><a class="markdownIt-Anchor" href="#st_table的碰撞处理"></a> st_table的碰撞处理</h4>
<p>如果FIND_ENTRY宏找到了该key，st_table会如何处理呢？其实，这个问题在add_direct调用的new_enrty函数那里就可以看出来：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 445 - 446行 */</span>
    entry<span class="token operator">-></span>next <span class="token operator">=</span> table<span class="token operator">-></span>bins<span class="token punctuation">[</span>bin_pos<span class="token punctuation">]</span><span class="token punctuation">;</span>
    table<span class="token operator">-></span>bins<span class="token punctuation">[</span>bin_pos<span class="token punctuation">]</span> <span class="token operator">=</span> entry<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这写法显然是链表的头插法，所以是链地址法。</p>
<h4 id="st_table的扩容"><a class="markdownIt-Anchor" href="#st_table的扩容"></a> st_table的扩容</h4>
<p>在我们实现的哈希表中，真正的哈希算法为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>M</mi><mi>D</mi><mn>5</mn><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">hash = MD5(key) \% n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>这样一来带来一个很麻烦的问题 – 扩容时必须重新计算哈希值。</p>
<p>而我们可以猜想到，得益于ruby哈希表中hash_val和bin_pos的分离，扩容时只需要重新计算bin_pos，而不需要重新计算哈希值。</p>
<p>真的是这样吗？让我们再看看源代码：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 459 - 462行 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>num_entries <span class="token operator">></span> ST_DEFAULT_MAX_DENSITY <span class="token operator">*</span> table<span class="token operator">-></span>num_bins<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
<span class="token function">rehash</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span><span class="token punctuation">;</span>
    bin_pos <span class="token operator">=</span> <span class="token function">hash_pos</span><span class="token punctuation">(</span>hash_val<span class="token punctuation">,</span> table<span class="token operator">-></span>num_bins<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以清楚地看到，如果现在的哈希表项数大于可以容纳的最大数量 * 一个密度常数，那么就用rehash()函数重新对这个表作哈希，而rehash()函数定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 609 - 627行 */</span>
<span class="token keyword">static</span> <span class="token keyword">void</span>
<span class="token function">rehash</span><span class="token punctuation">(</span><span class="token keyword">register</span> st_table <span class="token operator">*</span>table<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token keyword">register</span> st_table_entry <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token operator">*</span>new_bins<span class="token punctuation">;</span>
    <span class="token class-name">st_index_t</span> new_num_bins<span class="token punctuation">,</span> hash_val<span class="token punctuation">;</span>

    new_num_bins <span class="token operator">=</span> <span class="token function">new_size</span><span class="token punctuation">(</span>table<span class="token operator">-></span>num_bins<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    new_bins <span class="token operator">=</span> <span class="token function">st_realloc_bins</span><span class="token punctuation">(</span>table<span class="token operator">-></span>bins<span class="token punctuation">,</span> new_num_bins<span class="token punctuation">,</span> table<span class="token operator">-></span>num_bins<span class="token punctuation">)</span><span class="token punctuation">;</span>
    table<span class="token operator">-></span>num_bins <span class="token operator">=</span> new_num_bins<span class="token punctuation">;</span>
    table<span class="token operator">-></span>bins <span class="token operator">=</span> new_bins<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> table<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	    hash_val <span class="token operator">=</span> <span class="token function">hash_pos</span><span class="token punctuation">(</span>ptr<span class="token operator">-></span>hash<span class="token punctuation">,</span> new_num_bins<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    ptr<span class="token operator">-></span>next <span class="token operator">=</span> new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">;</span>
	    new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span> <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> ptr<span class="token operator">-></span>fore<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这段代码有两个地方需要研究</p>
<ol>
<li>new_size是如何实现的，新的大小和现大小是什么关系？</li>
<li>现在的哈希表是如何迁移到新的哈希表的？</li>
</ol>
<p>首先研究第一个问题，我们直接研究new_size函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 157 - 172行 */</span>
<span class="token keyword">static</span> <span class="token class-name">st_index_t</span>
<span class="token function">new_size</span><span class="token punctuation">(</span><span class="token class-name">st_index_t</span> size<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">st_index_t</span> n<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>size <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> size<span class="token punctuation">)</span> <span class="token comment">/* already a power-of-two? */</span>
	<span class="token keyword">return</span> size<span class="token punctuation">;</span>

    n <span class="token operator">=</span> <span class="token function">next_pow2</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> size<span class="token punctuation">)</span>
	<span class="token keyword">return</span> n<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">NOT_RUBY</span></span>
    <span class="token function">rb_raise</span><span class="token punctuation">(</span>rb_eRuntimeError<span class="token punctuation">,</span> <span class="token string">"st_table too big"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">/* should raise exception */</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，下一个大小是next_pow2算出来的。也就是说，新的大小和旧的大小有如下关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mn>2</mn><mo>×</mo><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">size_{new} = 2 \times size_{former}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后研究第二个问题，现在的哈希表如何迁移到新的哈希表。</p>
<p>首先，st_realloc_bins只会重新分配内存，而不会迁移，真正的迁移在这个循环中进行：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> table<span class="token operator">-></span>head<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	    hash_val <span class="token operator">=</span> <span class="token function">hash_pos</span><span class="token punctuation">(</span>ptr<span class="token operator">-></span>hash<span class="token punctuation">,</span> new_num_bins<span class="token punctuation">)</span><span class="token punctuation">;</span>
	    ptr<span class="token operator">-></span>next <span class="token operator">=</span> new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">;</span>
	    new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span> <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> ptr<span class="token operator">-></span>fore<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>要说明白这个循环，必须认真研究一下st_table_entry：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* ruby/st.c 18 - 26行 */</span>
<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">st_table_entry</span> st_table_entry<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">st_table_entry</span> <span class="token punctuation">&#123;</span>
    <span class="token class-name">st_index_t</span> hash<span class="token punctuation">;</span>
    <span class="token class-name">st_data_t</span> key<span class="token punctuation">;</span>
    <span class="token class-name">st_data_t</span> record<span class="token punctuation">;</span>
    st_table_entry <span class="token operator">*</span>next<span class="token punctuation">;</span>
    st_table_entry <span class="token operator">*</span>fore<span class="token punctuation">,</span> <span class="token operator">*</span>back<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个next，指向的是本bin_pos的下一个项；而fore和back，实际上是把整个哈希表中所有的项做成了一个双向链表！</p>
<p>回过头来再看add_direct的最后一部分，我们会有种恍然大悟的感觉：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">    <span class="token keyword">if</span> <span class="token punctuation">(</span>table<span class="token operator">-></span>head <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
entry<span class="token operator">-></span>fore <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>entry<span class="token operator">-></span>back <span class="token operator">=</span> table<span class="token operator">-></span>tail<span class="token punctuation">)</span><span class="token operator">-></span>fore <span class="token operator">=</span> entry<span class="token punctuation">;</span>
table<span class="token operator">-></span>tail <span class="token operator">=</span> entry<span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span>
    <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
table<span class="token operator">-></span>head <span class="token operator">=</span> table<span class="token operator">-></span>tail <span class="token operator">=</span> entry<span class="token punctuation">;</span>
entry<span class="token operator">-></span>fore <span class="token operator">=</span> entry<span class="token operator">-></span>back <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这也正是双向链表的插入操作，其中table-&gt;head是头指针，table-&gt;tail是尾指针。这样一来，所有的项都串成了一个双向链表，通过从头指针开始的遍历就可以将所有的项加入新的哈希表中，而这正是这个循环所做的事情：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">do</span> <span class="token punctuation">&#123;</span>
	hash_val <span class="token operator">=</span> <span class="token function">hash_pos</span><span class="token punctuation">(</span>ptr<span class="token operator">-></span>hash<span class="token punctuation">,</span> new_num_bins<span class="token punctuation">)</span><span class="token punctuation">;</span>
	ptr<span class="token operator">-></span>next <span class="token operator">=</span> new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span><span class="token punctuation">;</span>
	new_bins<span class="token punctuation">[</span>hash_val<span class="token punctuation">]</span> <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ptr <span class="token operator">=</span> ptr<span class="token operator">-></span>fore<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特别地，我们发现它确实只是将哈希值用hash_pos宏变为了bin_pos，即下标，从而避免了再次哈希键。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>总的来说，ruby中的哈希表有这几个特性：</p>
<ol>
<li>哈希函数是将键做不循环的位运算。</li>
<li>哈希值和真正的下标分离，真正的下标由哈希值逻辑与哈希表长度得到，扩容时不需要再次计算哈希值，只需要再次计算真正的下标。</li>
<li>冲突处理采用链地址法。</li>
<li>容量永远是2的n次方，扩容时，新的容量是现容量的两倍</li>
<li>将所有的哈希表项用一个双向链表串起来，用头指针和尾指针实现对整个哈希表的高效遍历。</li>
</ol>
</div><ul class="post-copyright"><li class="post-copyright-author"><strong>Post author: </strong>ayanamists</li><li class="post-copyright-link"><strong>Post link: </strong><a href="https://ayanamists.xyz/2019/12/10/2019-12-10-find/" title="数据结构 -- 查找 -- 笔记">https://ayanamists.xyz/2019/12/10/2019-12-10-find/</a></li><li class="post-copyright-license"><strong>Copyright Notice: </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener" title="CC BY-NC-SA 4.0 "><svg class="icon"><use xlink:href="#icon-creative-commons-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-by-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-nc-line"></use></svg><svg class="icon"><use xlink:href="#icon-creative-commons-sa-line"></use></svg></a> unless otherwise stated.</li></ul></section></article><div class="post-nav"><div class="post-nav-item"><a class="post-nav-prev" href="/2019/12/22/2019-12-22-Graph/" rel="prev" title="数据结构 -- 图 -- 笔记"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-left-s-line"></use></svg><span class="post-nav-text">数据结构 -- 图 -- 笔记</span></a></div><div class="post-nav-item"><a class="post-nav-next" href="/2019/11/02/2019-11-02-802-11i-1/" rel="next" title="802.11i 无线安全（一）建立RSNA"><span class="post-nav-text">802.11i 无线安全（一）建立RSNA</span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-right-s-line"></use></svg></a></div></div></div><div class="hty-card" id="comment"><div class="comment-tooltip text-center"><span>要不要和我说些什么？</span><br></div><style>.utterances {
  max-width: 100%;
}</style><script src="https://utteranc.es/client.js" repo="ayanamists/ayanamists.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async></script></div></main><footer class="sidebar-translate" id="footer"><div class="copyright"><span>&copy; 2019 – 2021 </span><span class="with-love" id="animate"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-cloud-line"></use></svg></span><span class="author"> Ayanamists</span></div><div class="powered"><span>Powered by <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> v5.4.0</span><span class="footer-separator">|</span><span>Theme - <a rel="noopener" href="https://github.com/YunYouJun/hexo-theme-yun" target="_blank"><span>Yun</span></a> v1.6.2</span></div><div id="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv" title="Total Visitors"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-user-line"></use></svg></span><span id="busuanzi_value_site_uv"></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv" title="Total Views"><span><svg class="icon" aria-hidden="true"><use xlink:href="#icon-eye-line"></use></svg></span><span id="busuanzi_value_site_pv"></span></span></div></footer><a class="hty-icon-button" id="back-to-top" aria-label="back-to-top" href="#"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-arrow-up-s-line"></use></svg><svg class="progress-circle-container" viewBox="0 0 100 100"><circle class="progress-circle" id="progressCircle" cx="50" cy="50" r="48" fill="none" stroke="#7350B9" stroke-width="2" stroke-linecap="round"></circle></svg></a></div></body></html>