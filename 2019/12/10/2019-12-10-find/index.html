<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>数据结构 -- 查找 -- 笔记 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言 查找的基本定义 查找算法的分析和设计 顺序查找算法 二分查找算法与二叉查找树 分块查找 堆&#x2F;优先队列 堆的概念与实现 堆可以用来做什么？   散列表 哈希表的定义 哈希函数 碰撞处理 哈希表的实现 – 我实现的c++版本 Ruby中的哈希表实现 st_table 的哈希函数 st_table的碰撞处理 st_table的扩容 总结      前言这一章，我们学习了查找这种基本操作和堆、散列">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构 -- 查找 -- 笔记">
<meta property="og:url" content="http://example.com/2019/12/10/2019-12-10-find/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前言 查找的基本定义 查找算法的分析和设计 顺序查找算法 二分查找算法与二叉查找树 分块查找 堆&#x2F;优先队列 堆的概念与实现 堆可以用来做什么？   散列表 哈希表的定义 哈希函数 碰撞处理 哈希表的实现 – 我实现的c++版本 Ruby中的哈希表实现 st_table 的哈希函数 st_table的碰撞处理 st_table的扩容 总结      前言这一章，我们学习了查找这种基本操作和堆、散列">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-12-10T00:00:00.000Z">
<meta property="article:modified_time" content="2020-10-11T04:43:47.184Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-2019-12-10-find" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/12/10/2019-12-10-find/" class="article-date">
  <time datetime="2019-12-10T00:00:00.000Z" itemprop="datePublished">2019-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      数据结构 -- 查找 -- 笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89">查找的基本定义</a></li>
<li><a href="#%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E8%AE%BE%E8%AE%A1">查找算法的分析和设计</a></li>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">顺序查找算法</a></li>
<li><a href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二分查找算法与二叉查找树</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">分块查找</a></li>
<li><a href="#%E5%A0%86%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97">堆/优先队列</a><ul>
<li><a href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0">堆的概念与实现</a></li>
<li><a href="#%E5%A0%86%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88">堆可以用来做什么？</a></li>
</ul>
</li>
<li><a href="#%E6%95%A3%E5%88%97%E8%A1%A8">散列表</a><ul>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89">哈希表的定义</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">哈希函数</a></li>
<li><a href="#%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86">碰撞处理</a></li>
<li><a href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0----%E6%88%91%E5%AE%9E%E7%8E%B0%E7%9A%84c%E7%89%88%E6%9C%AC">哈希表的实现 – 我实现的c++版本</a></li>
<li><a href="#ruby%E4%B8%AD%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9E%E7%8E%B0">Ruby中的哈希表实现</a><ul>
<li><a href="#sttable-%E7%9A%84%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0">st_table 的哈希函数</a></li>
<li><a href="#sttable%E7%9A%84%E7%A2%B0%E6%92%9E%E5%A4%84%E7%90%86">st_table的碰撞处理</a></li>
<li><a href="#sttable%E7%9A%84%E6%89%A9%E5%AE%B9">st_table的扩容</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这一章，我们学习了查找这种基本操作和堆、散列表这两种非常重要的数据结构。<br>本笔记主要完成了以下工作：</p>
<ul>
<li>总结了关于查找的各种知识点</li>
<li>用ruby语言实现了一个简单的堆模块(这里的模块指module，是ruby中MIX_IN思想的主要实现模式，下面会做简短介绍)，并进行了简单测试</li>
<li>用C++语言实现了一个简单的哈希表，并进行了简单测试</li>
<li>讨论了ruby中哈希表的实现</li>
<li>讨论了stl中std::find, std::binary_search等函数的实现</li>
</ul>
<h2 id="查找的基本定义"><a href="#查找的基本定义" class="headerlink" title="查找的基本定义"></a>查找的基本定义</h2><p>查找也可以视为搜索，wikipedia对搜索的定义是：</p>
<blockquote>
<p>在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题域的搜索空间中计算的信息。<br>其实简单来说，查找就是“找东西”。</p>
</blockquote>
<p>而我们要找的“东西”，严格来说应该叫做“关键字”，或者更学术一些，叫做“键”。找到“键”之后，如果存在一个“键-值映射”，就可以得到其“值”。</p>
<h2 id="查找算法的分析和设计"><a href="#查找算法的分析和设计" class="headerlink" title="查找算法的分析和设计"></a>查找算法的分析和设计</h2><p>查找算法实际上包含三个层次的问题：</p>
<ol>
<li>在什么数据结构上查找</li>
<li>如何查找</li>
<li>查找的效率如何</li>
</ol>
<h2 id="顺序查找算法"><a href="#顺序查找算法" class="headerlink" title="顺序查找算法"></a>顺序查找算法</h2><p>顺序查找是最朴素的查找，可以用在各种线性表上。在MSVC的stl中，我们有std::find函数实现这个算法：</p>
<p><em>以下代码来自&lt;algorithm&gt;</em></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> _<span class="title">InIt</span> <span class="title">find</span>(_<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span> <span class="comment">// find first matching _Val</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));</span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>_Adl_verify_range是检查参数范围是否有效，_Seek_wrapped函数简单来说是把后一个参数的值赋给前一个参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">void</span> _<span class="title">Seek_wrapped</span>(_<span class="title">Ty</span>*&amp; _<span class="title">It</span>, _<span class="title">Ty</span>* <span class="title">const</span> _<span class="title">UIt</span>) &#123;</span></span><br><span class="line">    _It = _UIt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际查找过程在_Find_unchecked函数中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InIt</span> _<span class="title">Find_unchecked</span>(<span class="title">const</span> _<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first matching _Val; choose optimization</span></span><br><span class="line">    <span class="comment">// activate optimization for pointers to (const) bytes and integral values</span></span><br><span class="line">    <span class="keyword">using</span> _Memchr_opt = bool_constant&lt;</span><br><span class="line">        is_integral_v&lt;_Ty&gt; &amp;&amp; _Is_any_of_v&lt;_InIt, <span class="keyword">char</span>*, <span class="keyword">signed</span> <span class="keyword">char</span>*, <span class="keyword">unsigned</span> <span class="keyword">char</span>*, <span class="comment">//</span></span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">signed</span> <span class="keyword">char</span>*, <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span>*&gt;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _Find_unchecked1(_First, _Last, _Val, _Memchr_opt&#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个函数实际上又调用了_Find_unchecked1函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">InIt</span> _<span class="title">Find_unchecked1</span>(_<span class="title">InIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">InIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, <span class="title">false_type</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first matching _Val</span></span><br><span class="line">    <span class="keyword">for</span> (; _First != _Last; ++_First) &#123;</span><br><span class="line">        <span class="keyword">if</span> (*_First == _Val) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>谢天谢地，_Find_unchecked1函数就是主要实现了。我们可以看到整个过程非常简单，就是顺序地查找整个表，如果找到了就退出。</p>
<p>由于模板的存在，在c++中，只要定义了迭代器，一个类就可以使用这个函数进行查找。这也正是对我们抽象描述–查找线性表–的抽象实现。</p>
<p>如果假设等概率，这个算法有</p>
<p>$$ASL_{success} = \frac{n + 1}{2}$$<br>$$ASL_{fail} = n + 1$$</p>
<h2 id="二分查找算法与二叉查找树"><a href="#二分查找算法与二叉查找树" class="headerlink" title="二分查找算法与二叉查找树"></a>二分查找算法与二叉查找树</h2><p>从上面的分析可以看出，顺序查找查找一次的时间复杂度是$O(n)$的。可不可以有更好的效率呢？</p>
<p>如果假定顺序表是有序的，那么思考这样的结论：</p>
<blockquote>
<p>如果待查询的元素大于 $array[floor(n / 2)]$，那么，它一定大于$array[0]$到$array[floor(n / 2) - 1]$的所有元素。</p>
</blockquote>
<p>这样一来，下一次的查询就可以不管这些元素，直接查询$array[floor(n/2) + 1]$到$array[n - 1]$这个区间了。</p>
<p>这实际上已经是一个递归算法了。这个算法的实现很简单，但我们还是来研究一下c++ stl中std::binary_search的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">bool</span> <span class="title">binary_search</span>(</span></span><br><span class="line"><span class="class">    _<span class="title">FwdIt</span> _<span class="title">First</span>, _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>) &#123;</span> <span class="comment">// test if _Val equivalent to some element, using operator&lt;</span></span><br><span class="line">    <span class="keyword">return</span> _STD binary_search(_First, _Last, _Val, less&lt;&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个binary_search是一个重载的函数，它才是真正用来实现的函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE binary_search</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>, <span class="title">class</span> _<span class="title">Pr</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> <span class="title">bool</span> <span class="title">binary_search</span>(</span></span><br><span class="line"><span class="class">    _<span class="title">FwdIt</span> _<span class="title">First</span>, _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, _<span class="title">Pr</span> _<span class="title">Pred</span>) &#123;</span> <span class="comment">// test if _Val equivalent to some element, using _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst      = _Get_unwrapped(_First);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> _ULast = _Get_unwrapped(_Last);</span><br><span class="line">    _UFirst           = _STD lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));</span><br><span class="line">    <span class="keyword">return</span> _UFirst != _ULast &amp;&amp; !_Pred(_Val, *_UFirst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这看起来并不是直接递归，而是使用了一个lower_bound函数。这个函数是干什么的呢？显然的，lower_bound的意思是下界，它定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// FUNCTION TEMPLATE lower_bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">FwdIt</span>, <span class="title">class</span> _<span class="title">Ty</span>, <span class="title">class</span> _<span class="title">Pr</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">NODISCARD</span> <span class="title">inline</span> _<span class="title">FwdIt</span> <span class="title">lower_bound</span>(_<span class="title">FwdIt</span> _<span class="title">First</span>, <span class="title">const</span> _<span class="title">FwdIt</span> _<span class="title">Last</span>, <span class="title">const</span> _<span class="title">Ty</span>&amp; _<span class="title">Val</span>, _<span class="title">Pr</span> _<span class="title">Pred</span>) &#123;</span></span><br><span class="line">    <span class="comment">// find first element not before _Val, using _Pred</span></span><br><span class="line">    _Adl_verify_range(_First, _Last);</span><br><span class="line">    <span class="keyword">auto</span> _UFirst                = _Get_unwrapped(_First);</span><br><span class="line">    _Iter_diff_t&lt;_FwdIt&gt; _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> &lt; _Count) &#123; <span class="comment">// divide and conquer, find half that contains answer</span></span><br><span class="line">        <span class="keyword">const</span> _Iter_diff_t&lt;_FwdIt&gt; _Count2 = _Count &gt;&gt; <span class="number">1</span>; <span class="comment">// TRANSITION, VSO#433486</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">auto</span> _UMid                   = _STD next(_UFirst, _Count2);</span><br><span class="line">        <span class="keyword">if</span> (_Pred(*_UMid, _Val)) &#123; <span class="comment">// try top half</span></span><br><span class="line">            _UFirst = _Next_iter(_UMid);</span><br><span class="line">            _Count -= _Count2 + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _Count = _Count2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Seek_wrapped(_First, _UFirst);</span><br><span class="line">    <span class="keyword">return</span> _First;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数比较麻烦，它返回的是第一个不满足_Pred条件的元素。这里_Pred条件是&lt;，所以返回的是第一个大于等于这个元素的迭代器，<br>然后binary_search函数就用!(_Pred(_Val, *_Ufirst))这个条件来判断是否相等，这相当于构造了<br>$$a &gt;= b$$<br>$$ a &lt;= b$$<br>显然地，只有当$a == b$时，表达式才返回真（吐槽一下，这stl写的太“聪明”了）</p>
<p>在二分查找中，成功查找时的ASL为：<br>$$\sum{i * P(i)} = 1/n*( \sum_{1}^{floor(log(n))}{i * 2^{i}} + ceil(log(n)) * (n - floor(log(n))))$$<br>这个式子过于繁琐，我们假设它的二叉判定树为满二叉树，可以得到：<br>$${n - 1}/{n} * log(n + 1) - 1$$</p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>分块查找采用了块间有序，块内无序的基本思想，建立一个索引表记录块内的最大值或最小值，然后先查索引表，找到对应的块，然后再到块中查询。</p>
<p>stl中的deque实现有这种思想的影子。</p>
<h2 id="堆-优先队列"><a href="#堆-优先队列" class="headerlink" title="堆/优先队列"></a>堆/优先队列</h2><h3 id="堆的概念与实现"><a href="#堆的概念与实现" class="headerlink" title="堆的概念与实现"></a>堆的概念与实现</h3><p>堆这个词来自于heap。我们最先学习到的heap，指的是C程序运行时环境的一部分–内存动态分配器及其分配的空间，我们在使用malloc函数、new函数（new实际上是一个函数）时都要用到它来分配空间。</p>
<p>但是这里的heap，指的是一种特殊的数据结构，它具有以下特点：</p>
<ul>
<li>分为小顶堆和大顶堆</li>
<li>对自$0$至$floor(n/2) - 1$的元素$heap[i]$有<br>  $$heap[i] &lt;= heap[2i + 1]$$<br>  $$heap[i] &lt;= heap[2i + 2]$$</li>
</ul>
<p>其实，第二个特点表明堆可以化为一颗二叉树，这颗二叉树的父亲节点都大于它的子节点。</p>
<p>我们这里用ruby语言实现了一个简单的堆：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">BinaryHeapable</span></span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">insert_to_heap</span> <span class="title">element</span></span></span><br><span class="line">    target = <span class="keyword">self</span>.length</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">self</span>[target / <span class="number">2</span>] &lt; element &amp;&amp; target != <span class="number">0</span></span><br><span class="line">      <span class="keyword">self</span>[target] = <span class="keyword">self</span>[target/<span class="number">2</span>]</span><br><span class="line">      target /= <span class="number">2</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">self</span>[target] = element</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">remove_from_heap</span></span></span><br><span class="line">    ret = <span class="keyword">self</span>[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">self</span>[<span class="number">0</span>] = <span class="keyword">self</span>[-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">self</span>.pop</span><br><span class="line">    heap_construct <span class="number">0</span></span><br><span class="line">    ret</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert_to_heap</span></span></span><br><span class="line">    i = <span class="keyword">self</span>.length / <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span></span><br><span class="line">      heap_construct i</span><br><span class="line">      i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">self</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  private</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">heap_construct</span> <span class="title">target</span></span></span><br><span class="line">    what = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> target * <span class="number">2</span> + <span class="number">1</span> &lt; <span class="keyword">self</span>.length</span><br><span class="line">      <span class="keyword">if</span> target * <span class="number">2</span> + <span class="number">2</span> &lt; <span class="keyword">self</span>.length</span><br><span class="line">        what = <span class="keyword">self</span>[target * <span class="number">2</span> + <span class="number">1</span>] &gt; <span class="keyword">self</span>[target * <span class="number">2</span> + <span class="number">2</span>] ? target * <span class="number">2</span> + <span class="number">1</span> : target * <span class="number">2</span> + <span class="number">2</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        what = target * <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">break</span> <span class="keyword">if</span> <span class="keyword">self</span>[target] &gt; <span class="keyword">self</span>[what]</span><br><span class="line">      temp = <span class="keyword">self</span>[target]</span><br><span class="line">      <span class="keyword">self</span>[target] = <span class="keyword">self</span>[what]</span><br><span class="line">      <span class="keyword">self</span>[what] = temp</span><br><span class="line">      target = what</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    what</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>ruby 中的module是mix-in思想的载体。只要我们让一个类include这个模块，这个类就获得了“堆化”的能力。特别地，ruby的数组被封装为Array类，而所有的自带类都是可以修改的：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line">  <span class="keyword">include</span> BinaryHeapable</span><br><span class="line"><span class="keyword">end</span> </span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以按照以下方法使用数组：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>].convert_to_heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> arr.length != <span class="number">0</span></span><br><span class="line">  pp arr.remove_from_heap</span><br><span class="line">  pp arr</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这段代码会打出：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">[<span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">6</span></span><br><span class="line">[<span class="number">5</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">5</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">3</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line">[]</span><br></pre></td></tr></table></figure>

<p>在上面的代码中我们看到，堆只需要实现一个操作，就可以搞定建堆和取出堆顶。</p>
<p>这个操作是什么呢？就是如下的操作：</p>
<p>假设一个堆节点的左子树与右子树均已经满足堆序，把以这个堆节点为根的子树调整成堆序。</p>
<p>这个操作实现起来很简单，具体可参加代码。</p>
<p>实现了这个操作后，</p>
<ul>
<li>建堆就是自$floor(n/2) - 1$至$0$调用这个操作；</li>
<li>取出堆顶就是先将堆顶缓存，再将堆尾和堆顶交换，再对堆顶调用这个操作。</li>
</ul>
<h3 id="堆可以用来做什么？"><a href="#堆可以用来做什么？" class="headerlink" title="堆可以用来做什么？"></a>堆可以用来做什么？</h3><p>堆可以在$O(log(n))$的时间复杂度内完成取出最大/最小元素并调整，这一特性可以作以下用途：</p>
<ul>
<li>堆排序</li>
<li>堆优化Dijkstra和Prim算法</li>
<li>霍夫曼树的实现</li>
<li>etc</li>
</ul>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="哈希表的定义"><a href="#哈希表的定义" class="headerlink" title="哈希表的定义"></a>哈希表的定义</h3><p>散列表，又称哈希表，是一种极为重要的数据结构。</p>
<p>为什么极其重要呢？因为</p>
<ul>
<li>上文提到的ruby，其内部数据结构有很大一部分是用散列表实现的。</li>
<li>散列表可以用来建立映射，例如把一个字符串映射到一个整数上，这对某些情况是极为有用的(例如图结构笔记中实现的IndexMapping类)。</li>
</ul>
<p>散列表的定义为：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>首先必须明确，这里的哈希函数和密码学中的哈希函数实质是一样的，都是一个映射：</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p>
</blockquote>
<p>但是，这里的哈希函数和密码学中的哈希函数侧重点是不一样的：</p>
<p>密码学中的哈希函数主要要求两个性质：</p>
<ol>
<li>均匀性，所有的输出是<em>等概率</em>的</li>
<li>唯一性，要求单射，即是说不能存在$a,b$，使得$f(a) == f(b)$</li>
</ol>
<p>高效性（速度）虽然很重要，但远远没有上面两条重要</p>
<p>而这里的哈希函数则要求高效性，因为我们访问哈希表中的元素可能是很频繁的。</p>
<p>所以密码学中的哈希函数用在这里是不太合适的。</p>
<p>教师讲述了6种方法，均以整数为键：</p>
<ol>
<li>直接定址法(Identity hash function)，找一个整数到整数的线性变换</li>
<li>折叠法(Folding)，将整数分为几个部分，每个部分都是目标长度的倍数（最后一部分可以小于目标长度），然后将这几部分作运算（加、移位、异或等等），得到结果之后取目标长度位结果。<ul>
<li>密码学哈希算法多与这个方法类似</li>
</ul>
</li>
<li>平方取中法(Mid-squares)，先平方，然后取中间的目标长度位</li>
<li>除数余留法（Division hashing），直接取模</li>
<li>代数编码法（Algebraic coding），用数字的不同位作变换。</li>
<li>随机数法，不解释。</li>
</ol>
<h3 id="碰撞处理"><a href="#碰撞处理" class="headerlink" title="碰撞处理"></a>碰撞处理</h3><p>如果发生了碰撞，也即是说，存在$a,b$，使得$f(a) == f(b)$，那么就需要进行处理，这大致有四种办法：</p>
<ol>
<li>开放定址法<ul>
<li>线性探测法</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区法<br>具体讨论略。</li>
</ol>
<h3 id="哈希表的实现-–-我实现的c-版本"><a href="#哈希表的实现-–-我实现的c-版本" class="headerlink" title="哈希表的实现 – 我实现的c++版本"></a>哈希表的实现 – 我实现的c++版本</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hashtable.h */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_KEY char *</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE_VALUE char *</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MD5 md5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NOT_FIND NULL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_NOT_FIND -1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">uint64_t</span> <span class="params">(*HASH_FUNC)</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">deleteFrom</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">findByKey</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TYPE_VALUE <span class="title">getValueByKey</span><span class="params">(TYPE_KEY key)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkHashTableNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T value;</span><br><span class="line">    LinkHashTableNode *next;</span><br><span class="line">    LinkHashTableNode(T value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">        <span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedHashTable</span> :</span> <span class="keyword">public</span> HashTable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">deleteFrom</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> TYPE_VALUE <span class="title">getValueByKey</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    LinkedHashTable(uint value, HASH_FUNC hashFunction);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">uint64_t</span> <span class="title">findByKey</span><span class="params">(TYPE_KEY key)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">uint64_t</span>(TYPE_KEY)&gt; hash;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LinkHashTableNode&lt;TYPE_VALUE&gt; *&gt; nodePool;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* hashtable.cpp */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;./hashtable.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;md5.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">LinkedHashTable::LinkedHashTable(uint size, HASH_FUNC hashFunction) : nodePool(size, <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;hash = hashFunction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">LinkedHashTable::findByKey</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash_value = <span class="keyword">this</span>-&gt;hash(key);</span><br><span class="line">    hash_value = hash_value % <span class="keyword">this</span>-&gt;nodePool.size();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;nodePool[hash_value] == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NUM_NOT_FIND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> hash_value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedHashTable::insertTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;<span class="built_in">pair</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> hash_value = <span class="keyword">this</span>-&gt;hash(<span class="built_in">pair</span>.first);</span><br><span class="line">    hash_value = hash_value % <span class="keyword">this</span>-&gt;nodePool.size();</span><br><span class="line">    <span class="keyword">auto</span> new_node = <span class="keyword">new</span> LinkHashTableNode&lt;TYPE_VALUE&gt;(<span class="built_in">pair</span>.second);</span><br><span class="line">    new_node-&gt;next = <span class="keyword">this</span>-&gt;nodePool[hash_value];</span><br><span class="line">    <span class="keyword">this</span>-&gt;nodePool[hash_value] = new_node;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">LinkedHashTable::deleteFrom</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hash_value = <span class="keyword">this</span>-&gt;findByKey(key);</span><br><span class="line">    <span class="keyword">if</span> (hash_value == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> begin = <span class="keyword">this</span>-&gt;nodePool[hash_value];</span><br><span class="line">        <span class="keyword">this</span>-&gt;nodePool[hash_value] = begin-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> begin;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TYPE_VALUE <span class="title">LinkedHashTable::getValueByKey</span><span class="params">(TYPE_KEY key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> hash_value = <span class="keyword">this</span>-&gt;findByKey(key);</span><br><span class="line">    <span class="keyword">if</span> (hash_value == NUM_NOT_FIND)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> NOT_FIND;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;nodePool[hash_value]-&gt;value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们实现了一个很简单的哈希表，采用链地址法进行碰撞处理，采用MD5（这是一个密码学哈希函数）作为哈希函数。</p>
<h3 id="Ruby中的哈希表实现"><a href="#Ruby中的哈希表实现" class="headerlink" title="Ruby中的哈希表实现"></a>Ruby中的哈希表实现</h3><p>我们实现的哈希表，玩具色彩浓厚，特别是直接采用MD5算法这种愚蠢行为，每次查询时，都需要做至少64轮循环，效率是很差的。</p>
<p>所以，本笔记的最后一部分就集中精力来讨论一个工业级哈希表 – ruby中的哈希表。</p>
<p>ruby中的哈希表使用为:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash = &#123;<span class="symbol">:a</span> =&gt; <span class="string">&quot;haha&quot;</span>, <span class="symbol">:b</span> =&gt; <span class="string">&quot;hahaha&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>这个数据结构在ruby程序中，使用得特别广泛、特别频繁。如果没有一个优秀的内部实现，ruby程序的性能将会受到很大影响。</p>
<p>笔记篇幅所限，这里不能完整地讨论ruby哈希表底层实现ruby/st.c中1000多行代码的全部内容。这里仅仅讨论一些最重要、和我们所学习内容关系最大的内容。</p>
<p><strong>下面所称 st_table 指的就是ruby内部的哈希表</strong></p>
<h4 id="st-table-的哈希函数"><a href="#st-table-的哈希函数" class="headerlink" title="st_table 的哈希函数"></a>st_table 的哈希函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 537行 */</span></span><br><span class="line">    hash_val = do_hash(key, table);</span><br></pre></td></tr></table></figure>

<p>上面这段代码表明哈希函数就是do_hash.我们来看一下这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 88行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> do_hash(key,table) (st_index_t)(*(table)-&gt;type-&gt;hash)((key))</span></span><br></pre></td></tr></table></figure>

<p>这段代码似乎不是很好理解，我们来一点点地看：</p>
<p>首先这是一个宏定义，传入两个参数key和table，给出一个值，其类型为st_index_t，也就是哈希表的具体位置（数组下标）</p>
<p>然后来看具体的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(table)-&gt;type-&gt;hash)((key))</span><br></pre></td></tr></table></figure>

<p>这个语法其实是一个函数调用。(table)-&gt;type-&gt;hash是一个函数指针，指向hash函数，key是其参数。</p>
<p>那么想要找到真正的哈希函数，就必须要找到初始化时这个table-&gt;type-&gt;hash被赋了什么值：</p>
<p>哈希表的初始化有些复杂，但是为了讨论的方便还是介绍一下：</p>
<p>首先，所有的初始化都最终被转发到这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_table_with_size(<span class="keyword">const</span> struct st_hash_type *type, <span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<p>然后实际使用时有三种初始化方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_numtable_with_size(<span class="keyword">st_index_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> st_init_table_with_size(&amp;type_numhash, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_strtable_with_size(<span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st_table*</span><br><span class="line">st_init_strcasetable_with_size(<span class="keyword">st_index_t</span> size)</span><br></pre></td></tr></table></figure>

<p>我们这里只研究第一种st_init_numtable_with_size。这一种看名字就知道是整数对整数的映射。<br>它传入了一个type_numhash，这看起来是一个全局常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> type_numhash st_hashtype_num</span></span><br><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_hash_type</span> <span class="title">st_hashtype_num</span> = &#123;</span></span><br><span class="line">    st_numcmp,</span><br><span class="line">    st_numhash,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>那么，整数对整数的映射实际上应该调用到st_numhash这个函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 1666 - 1683行 */</span></span><br><span class="line"><span class="keyword">st_index_t</span></span><br><span class="line">st_numhash(<span class="keyword">st_data_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * This hash function is lightly-tuned for Ruby.  Further tuning</span></span><br><span class="line"><span class="comment">     * should be possible.  Notes:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - (n &gt;&gt; 3) alone is great for heap objects and OK for fixnum,</span></span><br><span class="line"><span class="comment">     *   however symbols perform poorly.</span></span><br><span class="line"><span class="comment">     * - (n &gt;&gt; (RUBY_SPECIAL_SHIFT+3)) was added to make symbols hash well,</span></span><br><span class="line"><span class="comment">     *   n.b.: +3 to remove ID scope, +1 worked well initially, too</span></span><br><span class="line"><span class="comment">     * - (n &lt;&lt; 3) was finally added to avoid losing bits for fixnums</span></span><br><span class="line"><span class="comment">     * - avoid expensive modulo instructions, it is currently only</span></span><br><span class="line"><span class="comment">     *   shifts and bitmask operations.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">st_index_t</span>)((n&gt;&gt;(RUBY_SPECIAL_SHIFT+<span class="number">3</span>)|(n&lt;&lt;<span class="number">3</span>)) ^ (n&gt;&gt;<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数看起来倒是很简单，就是用n做了一些位运算。不过不属于教师讲述的6中方法之一。</p>
<p>这很大程度地激起了我的好奇心：难道Index是32位的整数吗？这个函数没有任何取模操作，如果传入一个很大的n,它该如何处理呢？</p>
<p>不要着急，让我们继续追踪吧：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 584 - 588行 */</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">key = (*func)(key);</span><br><span class="line">add_direct(table, key, value, hash_val, bin_pos);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到bin_pos这个参数，因为在add_direct函数中，它会调用new_entry函数，最后会执行这个语句：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 445 行 */</span> </span><br><span class="line">entry-&gt;next = table-&gt;bins[bin_pos];</span><br><span class="line">table-&gt;bins[bin_pos] = entry;</span><br></pre></td></tr></table></figure>

<p>显然地，bin_pos才是数组查找的真正下标！那么bin_pos是在哪里被设置的呢？一个出乎预料的答案是在FIND_ENTRY宏中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 582行*/</span></span><br><span class="line">    FIND_ENTRY(table, ptr, hash_val, bin_pos);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 344行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FIND_ENTRY(table, ptr, hash_val, bin_pos) \</span></span><br><span class="line">    ((ptr) = find_entry((table), key, (hash_val), ((bin_pos) = hash_pos(hash_val, (table)-&gt;num_bins))))</span><br></pre></td></tr></table></figure>

<p>经历了千辛万苦，我们终于来到了真正获取下标的hash_pos宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 89行 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> hash_pos(h,n) ((h) &amp; (n - 1))</span></span><br></pre></td></tr></table></figure>

<p>这里可以看到，实际的下标是和哈希表的长度与之后的结果。</p>
<p>有人可能会问，为什么要有两套键（一个hash_val，一个bin_pos）呢？我们下面会谈到，这里埋个伏笔。不过在谈到这个问题之前，我们先要看看它的碰撞处理。</p>
<h4 id="st-table的碰撞处理"><a href="#st-table的碰撞处理" class="headerlink" title="st_table的碰撞处理"></a>st_table的碰撞处理</h4><p>如果FIND_ENTRY宏找到了该key，st_table会如何处理呢？其实，这个问题在add_direct调用的new_enrty函数那里就可以看出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 445 - 446行 */</span></span><br><span class="line">    entry-&gt;next = table-&gt;bins[bin_pos];</span><br><span class="line">    table-&gt;bins[bin_pos] = entry;</span><br></pre></td></tr></table></figure>

<p>这写法显然是链表的头插法，所以是链地址法。</p>
<h4 id="st-table的扩容"><a href="#st-table的扩容" class="headerlink" title="st_table的扩容"></a>st_table的扩容</h4><p>在我们实现的哈希表中，真正的哈希算法为：<br>$$hash = MD5(key) % n$$<br>这样一来带来一个很麻烦的问题 – 扩容时必须重新计算哈希值。</p>
<p>而我们可以猜想到，得益于ruby哈希表中hash_val和bin_pos的分离，扩容时只需要重新计算bin_pos，而不需要重新计算哈希值。</p>
<p>真的是这样吗？让我们再看看源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 459 - 462行 */</span></span><br><span class="line">    <span class="keyword">if</span> (table-&gt;num_entries &gt; ST_DEFAULT_MAX_DENSITY * table-&gt;num_bins) &#123;</span><br><span class="line">rehash(table);</span><br><span class="line">    bin_pos = hash_pos(hash_val, table-&gt;num_bins);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>可以清楚地看到，如果现在的哈希表项数大于可以容纳的最大数量 * 一个密度常数，那么就用rehash()函数重新对这个表作哈希，而rehash()函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 609 - 627行 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">rehash(<span class="keyword">register</span> st_table *table)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> st_table_entry *ptr, **new_bins;</span><br><span class="line">    <span class="keyword">st_index_t</span> new_num_bins, hash_val;</span><br><span class="line"></span><br><span class="line">    new_num_bins = new_size(table-&gt;num_bins+<span class="number">1</span>);</span><br><span class="line">    new_bins = st_realloc_bins(table-&gt;bins, new_num_bins, table-&gt;num_bins);</span><br><span class="line">    table-&gt;num_bins = new_num_bins;</span><br><span class="line">    table-&gt;bins = new_bins;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ptr = table-&gt;head) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	    ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	    new_bins[hash_val] = ptr;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码有两个地方需要研究</p>
<ol>
<li>new_size是如何实现的，新的大小和现大小是什么关系？</li>
<li>现在的哈希表是如何迁移到新的哈希表的？</li>
</ol>
<p>首先研究第一个问题，我们直接研究new_size函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 157 - 172行 */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">st_index_t</span></span><br><span class="line">new_size(<span class="keyword">st_index_t</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">st_index_t</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size &amp;&amp; (size &amp; ~(size - <span class="number">1</span>)) == size) <span class="comment">/* already a power-of-two? */</span></span><br><span class="line">	<span class="keyword">return</span> size;</span><br><span class="line"></span><br><span class="line">    n = next_pow2(size);</span><br><span class="line">    <span class="keyword">if</span> (n &gt; size)</span><br><span class="line">	<span class="keyword">return</span> n;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NOT_RUBY</span></span><br><span class="line">    rb_raise(rb_eRuntimeError, <span class="string">&quot;st_table too big&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;			<span class="comment">/* should raise exception */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，下一个大小是next_pow2算出来的。也就是说，新的大小和旧的大小有如下关系：<br>$$size_{new} = 2 \times size_{former}$$</p>
<p>然后研究第二个问题，现在的哈希表如何迁移到新的哈希表。</p>
<p>首先，st_realloc_bins只会重新分配内存，而不会迁移，真正的迁移在这个循环中进行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((ptr = table-&gt;head) != <span class="number">0</span>) &#123;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	    ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	    new_bins[hash_val] = ptr;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要说明白这个循环，必须认真研究一下st_table_entry：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ruby/st.c 18 - 26行 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> <span class="title">st_table_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">st_table_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">st_index_t</span> hash;</span><br><span class="line">    <span class="keyword">st_data_t</span> key;</span><br><span class="line">    <span class="keyword">st_data_t</span> record;</span><br><span class="line">    st_table_entry *next;</span><br><span class="line">    st_table_entry *fore, *back;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个next，指向的是本bin_pos的下一个项；而fore和back，实际上是把整个哈希表中所有的项做成了一个双向链表！</p>
<p>回过头来再看add_direct的最后一部分，我们会有种恍然大悟的感觉：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (table-&gt;head != <span class="number">0</span>) &#123;</span><br><span class="line">entry-&gt;fore = <span class="number">0</span>;</span><br><span class="line">(entry-&gt;back = table-&gt;tail)-&gt;fore = entry;</span><br><span class="line">table-&gt;tail = entry;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">table-&gt;head = table-&gt;tail = entry;</span><br><span class="line">entry-&gt;fore = entry-&gt;back = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这也正是双向链表的插入操作，其中table-&gt;head是头指针，table-&gt;tail是尾指针。这样一来，所有的项都串成了一个双向链表，通过从头指针开始的遍历就可以将所有的项加入新的哈希表中，而这正是这个循环所做的事情：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">	hash_val = hash_pos(ptr-&gt;hash, new_num_bins);</span><br><span class="line">	ptr-&gt;next = new_bins[hash_val];</span><br><span class="line">	new_bins[hash_val] = ptr;</span><br><span class="line">&#125; <span class="keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>特别地，我们发现它确实只是将哈希值用hash_pos宏变为了bin_pos，即下标，从而避免了再次哈希键。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>总的来说，ruby中的哈希表有这几个特性：</p>
<ol>
<li>哈希函数是将键做不循环的位运算。</li>
<li>哈希值和真正的下标分离，真正的下标由哈希值逻辑与哈希表长度得到，扩容时不需要再次计算哈希值，只需要再次计算真正的下标。</li>
<li>冲突处理采用链地址法。</li>
<li>容量永远是2的n次方，扩容时，新的容量是现容量的两倍</li>
<li>将所有的哈希表项用一个双向链表串起来，用头指针和尾指针实现对整个哈希表的高效遍历。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2019/12/10/2019-12-10-find/" data-id="ckg4mhp32001q17sbgw71hdz7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/02/14/2020-02-14-eap/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          802.11i 无线网络安全（二）-- 802.1x eap认证
        
      </div>
    </a>
  
  
    <a href="/2019/11/02/2019-11-02-802-11i-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">802.11i 无线安全（一）建立RSNA</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/802-11i/">802.11i</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/">C/C++</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E5%8A%A8%E7%94%BB/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/network-speed/">network_speed</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/">动画</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E7%94%BB/%E6%BC%AB%E7%94%BB/">漫画</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/">未分类</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/11/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2019-12-22-Graph/">数据结构 -- 图 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/11/2020-1-2-sort/">数据结构 -- 排序 -- 笔记</a>
          </li>
        
          <li>
            <a href="/2020/10/03/2020-10-03-mma/">mathematica入坑指南</a>
          </li>
        
          <li>
            <a href="/2020/09/15/2020-09-25-fuck-the-signal/">f(x)记法的滥用与匿名函数</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>