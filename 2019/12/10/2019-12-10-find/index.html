<!DOCTYPE html>
<html>
    <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" name="viewport" />
    <link rel="alternate icon" type="image/png" href="/img/favicon.png">
    <link href="https://lf9-cdn-tos.bytecdntp.com/cdn/expire-1-M/KaTeX/0.10.2/katex.min.css" rel="stylesheet">
    <title>aya ⊢ blog | </title>
    
<link rel="stylesheet" href="/css/reset.css">

    
<link rel="stylesheet" href="/css/style.css">

    
<link rel="stylesheet" href="/css/markdown.css">

    
<link rel="stylesheet" href="/css/fonts.css">

<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head>
    <body>
        <div class="paper">
            <div class="paper-main">
                
                    <div class="post-header">
    <a class="logo" href="/">aya ⊢ blog</a>
    <a class="go-home" href="/">
        <svg width="8" height="14" viewBox="0 0 8 14">
            <path d="M7 1L1 7l6 6" stroke="#000" stroke-width="2" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </a>
</div>
                
                <div class="post-main">

    
        <div class="post-main-title">
            数据结构 -- 查找 -- 笔记
        </div>
        <div class="post-meta">
            2019-12-10
        </div>
    

    <div class="post-md">
        <ul>
<li><a href="#%e5%89%8d%e8%a8%80">前言</a></li>
<li><a href="#%e6%9f%a5%e6%89%be%e7%9a%84%e5%9f%ba%e6%9c%ac%e5%ae%9a%e4%b9%89">查找的基本定义</a></li>
<li><a href="#%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e7%9a%84%e5%88%86%e6%9e%90%e5%92%8c%e8%ae%be%e8%ae%a1">查找算法的分析和设计</a></li>
<li><a href="#%e9%a1%ba%e5%ba%8f%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95">顺序查找算法</a></li>
<li><a href="#%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%be%e7%ae%97%e6%b3%95%e4%b8%8e%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91">二分查找算法与二叉查找树</a></li>
<li><a href="#%e5%88%86%e5%9d%97%e6%9f%a5%e6%89%be">分块查找</a></li>
<li><a href="#%e5%a0%86%e4%bc%98%e5%85%88%e9%98%9f%e5%88%97">堆/优先队列</a>
<ul>
<li><a href="#%e5%a0%86%e7%9a%84%e6%a6%82%e5%bf%b5%e4%b8%8e%e5%ae%9e%e7%8e%b0">堆的概念与实现</a></li>
<li><a href="#%e5%a0%86%e5%8f%af%e4%bb%a5%e7%94%a8%e6%9d%a5%e5%81%9a%e4%bb%80%e4%b9%88">堆可以用来做什么？</a></li>
</ul>
</li>
<li><a href="#%e6%95%a3%e5%88%97%e8%a1%a8">散列表</a>
<ul>
<li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9a%e4%b9%89">哈希表的定义</a></li>
<li><a href="#%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">哈希函数</a></li>
<li><a href="#%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">碰撞处理</a></li>
<li><a href="#%e5%93%88%e5%b8%8c%e8%a1%a8%e7%9a%84%e5%ae%9e%e7%8e%b0----%e6%88%91%e5%ae%9e%e7%8e%b0%e7%9a%84c%e7%89%88%e6%9c%ac">哈希表的实现 – 我实现的c++版本</a></li>
<li><a href="#ruby%e4%b8%ad%e7%9a%84%e5%93%88%e5%b8%8c%e8%a1%a8%e5%ae%9e%e7%8e%b0">Ruby中的哈希表实现</a>
<ul>
<li><a href="#sttable-%e7%9a%84%e5%93%88%e5%b8%8c%e5%87%bd%e6%95%b0">st_table 的哈希函数</a></li>
<li><a href="#sttable%e7%9a%84%e7%a2%b0%e6%92%9e%e5%a4%84%e7%90%86">st_table的碰撞处理</a></li>
<li><a href="#sttable%e7%9a%84%e6%89%a9%e5%ae%b9">st_table的扩容</a></li>
<li><a href="#%e6%80%bb%e7%bb%93">总结</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2>
<p>这一章，我们学习了查找这种基本操作和堆、散列表这两种非常重要的数据结构。<br />
本笔记主要完成了以下工作：</p>
<ul>
<li>总结了关于查找的各种知识点</li>
<li>用ruby语言实现了一个简单的堆模块(这里的模块指module，是ruby中MIX_IN思想的主要实现模式，下面会做简短介绍)，并进行了简单测试</li>
<li>用C++语言实现了一个简单的哈希表，并进行了简单测试</li>
<li>讨论了ruby中哈希表的实现</li>
<li>讨论了stl中std::find, std::binary_search等函数的实现</li>
</ul>
<h2 id="查找的基本定义"><a class="markdownIt-Anchor" href="#查找的基本定义"></a> 查找的基本定义</h2>
<p>查找也可以视为搜索，wikipedia对搜索的定义是：</p>
<blockquote>
<p>在计算机科学中，搜索算法是解决搜索问题的任何算法，即检索存储在某个数据结构中的信息，或者在问题域的搜索空间中计算的信息。<br />
其实简单来说，查找就是“找东西”。</p>
</blockquote>
<p>而我们要找的“东西”，严格来说应该叫做“关键字”，或者更学术一些，叫做“键”。找到“键”之后，如果存在一个“键-值映射”，就可以得到其“值”。</p>
<h2 id="查找算法的分析和设计"><a class="markdownIt-Anchor" href="#查找算法的分析和设计"></a> 查找算法的分析和设计</h2>
<p>查找算法实际上包含三个层次的问题：</p>
<ol>
<li>在什么数据结构上查找</li>
<li>如何查找</li>
<li>查找的效率如何</li>
</ol>
<h2 id="顺序查找算法"><a class="markdownIt-Anchor" href="#顺序查找算法"></a> 顺序查找算法</h2>
<p>顺序查找是最朴素的查找，可以用在各种线性表上。在MSVC的stl中，我们有std::find函数实现这个算法：</p>
<p><em>以下代码来自&lt;algorithm&gt;</em></p>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">InIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>&gt;
_<span class="hljs-title">NODISCARD</span> <span class="hljs-title">inline</span> _<span class="hljs-title">InIt</span> <span class="hljs-title">find</span>(_<span class="hljs-title">InIt</span> _<span class="hljs-title">First</span>, <span class="hljs-title">const</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>) &#123;</span> <span class="hljs-comment">// find first matching _Val</span>
    _Adl_verify_range(_First, _Last);
    _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    <span class="hljs-keyword">return</span> _First;
&#125;
</code></pre>
<p>_Adl_verify_range是检查参数范围是否有效，_Seek_wrapped函数简单来说是把后一个参数的值赋给前一个参数：</p>
<pre class="highlight"><code class="c++">
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">Ty</span>&gt;
<span class="hljs-title">constexpr</span> <span class="hljs-title">void</span> _<span class="hljs-title">Seek_wrapped</span>(_<span class="hljs-title">Ty</span>*&amp; _<span class="hljs-title">It</span>, _<span class="hljs-title">Ty</span>* <span class="hljs-title">const</span> _<span class="hljs-title">UIt</span>) &#123;</span>
    _It = _UIt;
&#125;
</code></pre>
<p>实际查找过程在_Find_unchecked函数中：</p>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">InIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>&gt;
<span class="hljs-title">inline</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">Find_unchecked</span>(<span class="hljs-title">const</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">First</span>, <span class="hljs-title">const</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>) &#123;</span>
    <span class="hljs-comment">// find first matching _Val; choose optimization</span>
    <span class="hljs-comment">// activate optimization for pointers to (const) bytes and integral values</span>
    <span class="hljs-keyword">using</span> _Memchr_opt = bool_constant&lt;
        is_integral_v&lt;_Ty&gt; &amp;&amp; _Is_any_of_v&lt;_InIt, <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*, <span class="hljs-comment">//</span>
            <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">signed</span> <span class="hljs-keyword">char</span>*, <span class="hljs-keyword">const</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>*&gt;&gt;;

    <span class="hljs-keyword">return</span> _Find_unchecked1(_First, _Last, _Val, _Memchr_opt&#123;&#125;);
&#125;
</code></pre>
<p>而这个函数实际上又调用了_Find_unchecked1函数：</p>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">InIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>&gt;
<span class="hljs-title">inline</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">Find_unchecked1</span>(_<span class="hljs-title">InIt</span> _<span class="hljs-title">First</span>, <span class="hljs-title">const</span> _<span class="hljs-title">InIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>, <span class="hljs-title">false_type</span>) &#123;</span>
    <span class="hljs-comment">// find first matching _Val</span>
    <span class="hljs-keyword">for</span> (; _First != _Last; ++_First) &#123;
        <span class="hljs-keyword">if</span> (*_First == _Val) &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> _First;
&#125;
</code></pre>
<p>谢天谢地，_Find_unchecked1函数就是主要实现了。我们可以看到整个过程非常简单，就是顺序地查找整个表，如果找到了就退出。</p>
<p>由于模板的存在，在c++中，只要定义了迭代器，一个类就可以使用这个函数进行查找。这也正是对我们抽象描述–查找线性表–的抽象实现。</p>
<p>如果假设等概率，这个算法有</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>s</mi><mi>u</mi><mi>c</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi></mrow></msub><mo>=</mo><mfrac><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">ASL_{success} = \frac{n + 1}{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">u</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.00744em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.32144em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>A</mi><mi>S</mi><msub><mi>L</mi><mrow><mi>f</mi><mi>a</mi><mi>i</mi><mi>l</mi></mrow></msub><mo>=</mo><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">ASL_{fail} = n + 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h2 id="二分查找算法与二叉查找树"><a class="markdownIt-Anchor" href="#二分查找算法与二叉查找树"></a> 二分查找算法与二叉查找树</h2>
<p>从上面的分析可以看出，顺序查找查找一次的时间复杂度是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的。可不可以有更好的效率呢？</p>
<p>如果假定顺序表是有序的，那么思考这样的结论：</p>
<blockquote>
<p>如果待查询的元素大于 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n / 2)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">]</span></span></span></span>，那么，它一定大于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mn>0</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n / 2) - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>的所有元素。</p>
</blockquote>
<p>这样一来，下一次的查询就可以不管这些元素，直接查询<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[floor(n/2) + 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mi>r</mi><mi>r</mi><mi>a</mi><mi>y</mi><mo stretchy="false">[</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">array[n - 1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mopen">[</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这个区间了。</p>
<p>这实际上已经是一个递归算法了。这个算法的实现很简单，但我们还是来研究一下c++ stl中std::binary_search的实现：</p>
<pre class="highlight"><code class="c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">FwdIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>&gt;
_<span class="hljs-title">NODISCARD</span> <span class="hljs-title">inline</span> <span class="hljs-title">bool</span> <span class="hljs-title">binary_search</span>(
    _<span class="hljs-title">FwdIt</span> _<span class="hljs-title">First</span>, _<span class="hljs-title">FwdIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>) &#123;</span> <span class="hljs-comment">// test if _Val equivalent to some element, using operator&lt;</span>
    <span class="hljs-keyword">return</span> _STD binary_search(_First, _Last, _Val, less&lt;&gt;());
&#125;
</code></pre>
<p>下面这个binary_search是一个重载的函数，它才是真正用来实现的函数：</p>
<pre class="highlight"><code class="c++"><span class="hljs-comment">// FUNCTION TEMPLATE binary_search</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">FwdIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Pr</span>&gt;
_<span class="hljs-title">NODISCARD</span> <span class="hljs-title">inline</span> <span class="hljs-title">bool</span> <span class="hljs-title">binary_search</span>(
    _<span class="hljs-title">FwdIt</span> _<span class="hljs-title">First</span>, _<span class="hljs-title">FwdIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>, _<span class="hljs-title">Pr</span> _<span class="hljs-title">Pred</span>) &#123;</span> <span class="hljs-comment">// test if _Val equivalent to some element, using _Pred</span>
    _Adl_verify_range(_First, _Last);
    <span class="hljs-keyword">auto</span> _UFirst      = _Get_unwrapped(_First);
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> _ULast = _Get_unwrapped(_Last);
    _UFirst           = _STD lower_bound(_UFirst, _ULast, _Val, _Pass_fn(_Pred));
    <span class="hljs-keyword">return</span> _UFirst != _ULast &amp;&amp; !_Pred(_Val, *_UFirst);
&#125;
</code></pre>
<p>这看起来并不是直接递归，而是使用了一个lower_bound函数。这个函数是干什么的呢？显然的，lower_bound的意思是下界，它定义如下：</p>
<pre class="highlight"><code class="c++"><span class="hljs-comment">// FUNCTION TEMPLATE lower_bound</span>
<span class="hljs-keyword">template</span> &lt;<span class="hljs-class"><span class="hljs-keyword">class</span> _<span class="hljs-title">FwdIt</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Ty</span>, <span class="hljs-title">class</span> _<span class="hljs-title">Pr</span>&gt;
_<span class="hljs-title">NODISCARD</span> <span class="hljs-title">inline</span> _<span class="hljs-title">FwdIt</span> <span class="hljs-title">lower_bound</span>(_<span class="hljs-title">FwdIt</span> _<span class="hljs-title">First</span>, <span class="hljs-title">const</span> _<span class="hljs-title">FwdIt</span> _<span class="hljs-title">Last</span>, <span class="hljs-title">const</span> _<span class="hljs-title">Ty</span>&amp; _<span class="hljs-title">Val</span>, _<span class="hljs-title">Pr</span> _<span class="hljs-title">Pred</span>) &#123;</span>
    <span class="hljs-comment">// find first element not before _Val, using _Pred</span>
    _Adl_verify_range(_First, _Last);
    <span class="hljs-keyword">auto</span> _UFirst                = _Get_unwrapped(_First);
    _Iter_diff_t&lt;_FwdIt&gt; _Count = _STD distance(_UFirst, _Get_unwrapped(_Last));

    <span class="hljs-keyword">while</span> (<span class="hljs-number">0</span> &lt; _Count) &#123; <span class="hljs-comment">// divide and conquer, find half that contains answer</span>
        <span class="hljs-keyword">const</span> _Iter_diff_t&lt;_FwdIt&gt; _Count2 = _Count &gt;&gt; <span class="hljs-number">1</span>; <span class="hljs-comment">// TRANSITION, VSO#433486</span>
        <span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> _UMid                   = _STD next(_UFirst, _Count2);
        <span class="hljs-keyword">if</span> (_Pred(*_UMid, _Val)) &#123; <span class="hljs-comment">// try top half</span>
            _UFirst = _Next_iter(_UMid);
            _Count -= _Count2 + <span class="hljs-number">1</span>;
        &#125; <span class="hljs-keyword">else</span> &#123;
            _Count = _Count2;
        &#125;
    &#125;

    _Seek_wrapped(_First, _UFirst);
    <span class="hljs-keyword">return</span> _First;
&#125;
</code></pre>
<p>这个函数比较麻烦，它返回的是第一个不满足_Pred条件的元素。这里_Pred条件是&lt;，所以返回的是第一个大于等于这个元素的迭代器，<br />
然后binary_search函数就用!(_Pred(_Val, *_Ufirst))这个条件来判断是否相等，这相当于构造了</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&gt;</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &gt;= b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>&lt;</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a &lt;= b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span></span></p>
<p>显然地，只有当<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>=</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a == b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">b</span></span></span></span>时，表达式才返回真（吐槽一下，这stl写的太“聪明”了）</p>
<p>在二分查找中，成功查找时的ASL为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>∑</mo><mrow><mi>i</mi><mo>∗</mo><mi>P</mi><mo stretchy="false">(</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><mo>=</mo><mn>1</mn><mi mathvariant="normal">/</mi><mi>n</mi><mo>∗</mo><mo stretchy="false">(</mo><munderover><mo>∑</mo><mn>1</mn><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow></munderover><mrow><mi>i</mi><mo>∗</mo><msup><mn>2</mn><mi>i</mi></msup></mrow><mo>+</mo><mi>c</mi><mi>e</mi><mi>i</mi><mi>l</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo>∗</mo><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum{i * P(i)} = 1/n*( \sum_{1}^{floor(log(n))}{i * 2^{i}} + ceil(log(n)) * (n - floor(log(n))))
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord mathdefault">i</span><span class="mclose">)</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mord">/</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.2281180000000003em;vertical-align:-1.267113em;"></span><span class="mopen">(</span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.9610050000000003em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.386005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.01968em;">l</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mclose mtight">)</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8746639999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p>
<p>这个式子过于繁琐，我们假设它的二叉判定树为满二叉树，可以得到：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mi mathvariant="normal">/</mi><mi>n</mi><mo>∗</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">{n - 1}/{n} * log(n + 1) - 1
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span></span><span class="mord">/</span><span class="mord"><span class="mord mathdefault">n</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></span></p>
<h2 id="分块查找"><a class="markdownIt-Anchor" href="#分块查找"></a> 分块查找</h2>
<p>分块查找采用了块间有序，块内无序的基本思想，建立一个索引表记录块内的最大值或最小值，然后先查索引表，找到对应的块，然后再到块中查询。</p>
<p>stl中的deque实现有这种思想的影子。</p>
<h2 id="堆优先队列"><a class="markdownIt-Anchor" href="#堆优先队列"></a> 堆/优先队列</h2>
<h3 id="堆的概念与实现"><a class="markdownIt-Anchor" href="#堆的概念与实现"></a> 堆的概念与实现</h3>
<p>堆这个词来自于heap。我们最先学习到的heap，指的是C程序运行时环境的一部分–内存动态分配器及其分配的空间，我们在使用malloc函数、new函数（new实际上是一个函数）时都要用到它来分配空间。</p>
<p>但是这里的heap，指的是一种特殊的数据结构，它具有以下特点：</p>
<ul>
<li>分为小顶堆和大顶堆</li>
<li>对自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">floor(n/2) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的元素<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>有<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i] &lt;= heap[2i + 1]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mo>=</mo><mi>h</mi><mi>e</mi><mi>a</mi><mi>p</mi><mo stretchy="false">[</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>2</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">heap[i] &lt;= heap[2i + 2]
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">a</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span></span></span></span></span></p>
</li>
</ul>
<p>其实，第二个特点表明堆可以化为一颗二叉树，这颗二叉树的父亲节点都大于它的子节点。</p>
<p>我们这里用ruby语言实现了一个简单的堆：</p>
<pre class="highlight"><code class="ruby"><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">BinaryHeapable</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">insert_to_heap</span> <span class="hljs-title">element</span></span>
    target = <span class="hljs-keyword">self</span>.length
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>[target / <span class="hljs-number">2</span>] &lt; element &amp;&amp; target != <span class="hljs-number">0</span>
      <span class="hljs-keyword">self</span>[target] = <span class="hljs-keyword">self</span>[target/<span class="hljs-number">2</span>]
      target /= <span class="hljs-number">2</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">self</span>[target] = element
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_from_heap</span></span>
    ret = <span class="hljs-keyword">self</span>[<span class="hljs-number">0</span>]
    <span class="hljs-keyword">self</span>[<span class="hljs-number">0</span>] = <span class="hljs-keyword">self</span>[-<span class="hljs-number">1</span>]
    <span class="hljs-keyword">self</span>.pop
    heap_construct <span class="hljs-number">0</span>
    ret
  <span class="hljs-keyword">end</span>
  
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_to_heap</span></span>
    i = <span class="hljs-keyword">self</span>.length / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>
    <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>
      heap_construct i
      i -= <span class="hljs-number">1</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">self</span>
  <span class="hljs-keyword">end</span>

  private
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">heap_construct</span> <span class="hljs-title">target</span></span>
    what = <span class="hljs-number">0</span>
    <span class="hljs-keyword">while</span> target * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> &lt; <span class="hljs-keyword">self</span>.length
      <span class="hljs-keyword">if</span> target * <span class="hljs-number">2</span> + <span class="hljs-number">2</span> &lt; <span class="hljs-keyword">self</span>.length
        what = <span class="hljs-keyword">self</span>[target * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>] &gt; <span class="hljs-keyword">self</span>[target * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>] ? target * <span class="hljs-number">2</span> + <span class="hljs-number">1</span> : target * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>
      <span class="hljs-keyword">else</span>
        what = target * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>
      <span class="hljs-keyword">end</span>
      <span class="hljs-keyword">break</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>[target] &gt; <span class="hljs-keyword">self</span>[what]
      temp = <span class="hljs-keyword">self</span>[target]
      <span class="hljs-keyword">self</span>[target] = <span class="hljs-keyword">self</span>[what]
      <span class="hljs-keyword">self</span>[what] = temp
      target = what
    <span class="hljs-keyword">end</span>
    what
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre>
<p>ruby 中的module是mix-in思想的载体。只要我们让一个类include这个模块，这个类就获得了“堆化”的能力。特别地，ruby的数组被封装为Array类，而所有的自带类都是可以修改的：</p>
<pre class="highlight"><code class="ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span></span>
  <span class="hljs-keyword">include</span> BinaryHeapable
<span class="hljs-keyword">end</span> 
</code></pre>
<p>这样一来，我们就可以按照以下方法使用数组：</p>
<pre class="highlight"><code class="ruby">arr = [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">6</span>, <span class="hljs-number">1</span>].convert_to_heap

<span class="hljs-keyword">while</span> arr.length != <span class="hljs-number">0</span>
  pp arr.remove_from_heap
  pp arr
<span class="hljs-keyword">end</span>
</code></pre>
<p>这段代码会打出：</p>
<pre class="highlight"><code class="ruby"><span class="hljs-number">8</span>
[<span class="hljs-number">6</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>]
<span class="hljs-number">6</span>
[<span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
<span class="hljs-number">5</span>
[<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
<span class="hljs-number">3</span>
[<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]
<span class="hljs-number">3</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]
<span class="hljs-number">1</span>
[<span class="hljs-number">0</span>]
<span class="hljs-number">0</span>
[]
</code></pre>
<p>在上面的代码中我们看到，堆只需要实现一个操作，就可以搞定建堆和取出堆顶。</p>
<p>这个操作是什么呢？就是如下的操作：</p>
<p>假设一个堆节点的左子树与右子树均已经满足堆序，把以这个堆节点为根的子树调整成堆序。</p>
<p>这个操作实现起来很简单，具体可参加代码。</p>
<p>实现了这个操作后，</p>
<ul>
<li>建堆就是自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mi>l</mi><mi>o</mi><mi>o</mi><mi>r</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn><mo stretchy="false">)</mo><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">floor(n/2) - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord">2</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>至<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>调用这个操作；</li>
<li>取出堆顶就是先将堆顶缓存，再将堆尾和堆顶交换，再对堆顶调用这个操作。</li>
</ul>
<h3 id="堆可以用来做什么"><a class="markdownIt-Anchor" href="#堆可以用来做什么"></a> 堆可以用来做什么？</h3>
<p>堆可以在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的时间复杂度内完成取出最大/最小元素并调整，这一特性可以作以下用途：</p>
<ul>
<li>堆排序</li>
<li>堆优化Dijkstra和Prim算法</li>
<li>霍夫曼树的实现</li>
<li>etc</li>
</ul>
<h2 id="散列表"><a class="markdownIt-Anchor" href="#散列表"></a> 散列表</h2>
<h3 id="哈希表的定义"><a class="markdownIt-Anchor" href="#哈希表的定义"></a> 哈希表的定义</h3>
<p>散列表，又称哈希表，是一种极为重要的数据结构。</p>
<p>为什么极其重要呢？因为</p>
<ul>
<li>上文提到的ruby，其内部数据结构有很大一部分是用散列表实现的。</li>
<li>散列表可以用来建立映射，例如把一个字符串映射到一个整数上，这对某些情况是极为有用的(例如图结构笔记中实现的IndexMapping类)。</li>
</ul>
<p>散列表的定义为：</p>
<blockquote>
<p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存存储位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
</blockquote>
<h3 id="哈希函数"><a class="markdownIt-Anchor" href="#哈希函数"></a> 哈希函数</h3>
<p>首先必须明确，这里的哈希函数和密码学中的哈希函数实质是一样的，都是一个映射：</p>
<blockquote>
<p>A hash function is any function that can be used to map data of arbitrary size to fixed-size values.</p>
</blockquote>
<p>但是，这里的哈希函数和密码学中的哈希函数侧重点是不一样的：</p>
<p>密码学中的哈希函数主要要求两个性质：</p>
<ol>
<li>均匀性，所有的输出是<em>等概率</em>的</li>
<li>唯一性，要求单射，即是说不能存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a) == f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span></li>
</ol>
<p>高效性（速度）虽然很重要，但远远没有上面两条重要</p>
<p>而这里的哈希函数则要求高效性，因为我们访问哈希表中的元素可能是很频繁的。</p>
<p>所以密码学中的哈希函数用在这里是不太合适的。</p>
<p>教师讲述了6种方法，均以整数为键：</p>
<ol>
<li>直接定址法(Identity hash function)，找一个整数到整数的线性变换</li>
<li>折叠法(Folding)，将整数分为几个部分，每个部分都是目标长度的倍数（最后一部分可以小于目标长度），然后将这几部分作运算（加、移位、异或等等），得到结果之后取目标长度位结果。
<ul>
<li>密码学哈希算法多与这个方法类似</li>
</ul>
</li>
<li>平方取中法(Mid-squares)，先平方，然后取中间的目标长度位</li>
<li>除数余留法（Division hashing），直接取模</li>
<li>代数编码法（Algebraic coding），用数字的不同位作变换。</li>
<li>随机数法，不解释。</li>
</ol>
<h3 id="碰撞处理"><a class="markdownIt-Anchor" href="#碰撞处理"></a> 碰撞处理</h3>
<p>如果发生了碰撞，也即是说，存在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo separator="true">,</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">a,b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">a</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">b</span></span></span></span>，使得<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo><mo>=</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>b</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(a) == f(b)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">a</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">b</span><span class="mclose">)</span></span></span></span>，那么就需要进行处理，这大致有四种办法：</p>
<ol>
<li>开放定址法
<ul>
<li>线性探测法</li>
<li>二次探测法</li>
<li>随机探测法</li>
</ul>
</li>
<li>再哈希法</li>
<li>链地址法</li>
<li>建立公共溢出区法<br />
具体讨论略。</li>
</ol>
<h3 id="哈希表的实现-我实现的c版本"><a class="markdownIt-Anchor" href="#哈希表的实现-我实现的c版本"></a> 哈希表的实现 – 我实现的c++版本</h3>
<pre class="highlight"><code class="c++"><span class="hljs-comment">/* hashtable.h */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_KEY char *</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TYPE_VALUE char *</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MD5 md5</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NOT_FIND NULL</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> NUM_NOT_FIND -1</span>

<span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">uint64_t</span> <span class="hljs-params">(*HASH_FUNC)</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *)</span></span>;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashTable</span>
&#123;</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">insertTo</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">deleteFrom</span><span class="hljs-params">(TYPE_KEY key)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">findByKey</span><span class="hljs-params">(TYPE_KEY key)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> TYPE_VALUE <span class="hljs-title">getValueByKey</span><span class="hljs-params">(TYPE_KEY key)</span> </span>= <span class="hljs-number">0</span>;
&#125;;

<span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkHashTableNode</span>
&#123;</span>
<span class="hljs-keyword">public</span>:
    T value;
    LinkHashTableNode *next;
    LinkHashTableNode(T value)
    &#123;
        <span class="hljs-keyword">this</span>-&gt;value = value;
        <span class="hljs-keyword">this</span>-&gt;next = <span class="hljs-literal">NULL</span>;
    &#125;
&#125;;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedHashTable</span> :</span> <span class="hljs-keyword">public</span> HashTable
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">insertTo</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">bool</span> <span class="hljs-title">deleteFrom</span><span class="hljs-params">(TYPE_KEY key)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> TYPE_VALUE <span class="hljs-title">getValueByKey</span><span class="hljs-params">(TYPE_KEY key)</span></span>;
    LinkedHashTable(uint value, HASH_FUNC hashFunction);

<span class="hljs-keyword">private</span>:
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-keyword">uint64_t</span> <span class="hljs-title">findByKey</span><span class="hljs-params">(TYPE_KEY key)</span></span>;
    <span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">uint64_t</span>(TYPE_KEY)&gt; hash;
    <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;LinkHashTableNode&lt;TYPE_VALUE&gt; *&gt; nodePool;
&#125;;
</code></pre>
<pre class="highlight"><code class="c++"><span class="hljs-comment">/* hashtable.cpp */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"./hashtable.h"</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"md5.h"</span></span>

LinkedHashTable::LinkedHashTable(uint <span class="hljs-built_in">size</span>, HASH_FUNC hashFunction) : nodePool(<span class="hljs-built_in">size</span>, <span class="hljs-literal">NULL</span>)
&#123;
    <span class="hljs-keyword">this</span>-&gt;hash = hashFunction;
&#125;

<span class="hljs-function"><span class="hljs-keyword">uint64_t</span> <span class="hljs-title">LinkedHashTable::findByKey</span><span class="hljs-params">(TYPE_KEY key)</span>
</span>&#123;
    <span class="hljs-keyword">uint64_t</span> hash_value = <span class="hljs-keyword">this</span>-&gt;hash(key);
    hash_value = hash_value % <span class="hljs-keyword">this</span>-&gt;nodePool.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;nodePool[hash_value] == <span class="hljs-literal">NULL</span>)
    &#123;
        <span class="hljs-keyword">return</span> NUM_NOT_FIND;
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">return</span> hash_value;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">LinkedHashTable::insertTo</span><span class="hljs-params">(<span class="hljs-built_in">std</span>::pair&lt;TYPE_KEY, TYPE_VALUE&gt; &amp;pair)</span>
</span>&#123;
    <span class="hljs-keyword">uint64_t</span> hash_value = <span class="hljs-keyword">this</span>-&gt;hash(pair.first);
    hash_value = hash_value % <span class="hljs-keyword">this</span>-&gt;nodePool.<span class="hljs-built_in">size</span>();
    <span class="hljs-keyword">auto</span> new_node = <span class="hljs-keyword">new</span> LinkHashTableNode&lt;TYPE_VALUE&gt;(pair.second);
    new_node-&gt;next = <span class="hljs-keyword">this</span>-&gt;nodePool[hash_value];
    <span class="hljs-keyword">this</span>-&gt;nodePool[hash_value] = new_node;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">LinkedHashTable::deleteFrom</span><span class="hljs-params">(TYPE_KEY key)</span>
</span>&#123;
    <span class="hljs-keyword">auto</span> hash_value = <span class="hljs-keyword">this</span>-&gt;findByKey(key);
    <span class="hljs-keyword">if</span> (hash_value == <span class="hljs-number">-1</span>)
    &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">auto</span> <span class="hljs-built_in">begin</span> = <span class="hljs-keyword">this</span>-&gt;nodePool[hash_value];
        <span class="hljs-keyword">this</span>-&gt;nodePool[hash_value] = <span class="hljs-built_in">begin</span>-&gt;next;
        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">begin</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
&#125;

<span class="hljs-function">TYPE_VALUE <span class="hljs-title">LinkedHashTable::getValueByKey</span><span class="hljs-params">(TYPE_KEY key)</span>
</span>&#123;
    <span class="hljs-keyword">auto</span> hash_value = <span class="hljs-keyword">this</span>-&gt;findByKey(key);
    <span class="hljs-keyword">if</span> (hash_value == NUM_NOT_FIND)
    &#123;
        <span class="hljs-keyword">return</span> NOT_FIND;
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>-&gt;nodePool[hash_value]-&gt;value;
    &#125;
&#125;
</code></pre>
<p>我们实现了一个很简单的哈希表，采用链地址法进行碰撞处理，采用MD5（这是一个密码学哈希函数）作为哈希函数。</p>
<h3 id="ruby中的哈希表实现"><a class="markdownIt-Anchor" href="#ruby中的哈希表实现"></a> Ruby中的哈希表实现</h3>
<p>我们实现的哈希表，玩具色彩浓厚，特别是直接采用MD5算法这种愚蠢行为，每次查询时，都需要做至少64轮循环，效率是很差的。</p>
<p>所以，本笔记的最后一部分就集中精力来讨论一个工业级哈希表 – ruby中的哈希表。</p>
<p>ruby中的哈希表使用为:</p>
<pre class="highlight"><code class="ruby">hash = &#123;<span class="hljs-symbol">:a</span> =&gt; <span class="hljs-string">"haha"</span>, <span class="hljs-symbol">:b</span> =&gt; <span class="hljs-string">"hahaha"</span>&#125;
</code></pre>
<p>这个数据结构在ruby程序中，使用得特别广泛、特别频繁。如果没有一个优秀的内部实现，ruby程序的性能将会受到很大影响。</p>
<p>笔记篇幅所限，这里不能完整地讨论ruby哈希表底层实现ruby/st.c中1000多行代码的全部内容。这里仅仅讨论一些最重要、和我们所学习内容关系最大的内容。</p>
<p><strong>下面所称 st_table 指的就是ruby内部的哈希表</strong></p>
<h4 id="st_table-的哈希函数"><a class="markdownIt-Anchor" href="#st_table-的哈希函数"></a> st_table 的哈希函数</h4>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 537行 */</span>
    hash_val = do_hash(key, table);
</code></pre>
<p>上面这段代码表明哈希函数就是do_hash.我们来看一下这个函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 88行 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> do_hash(key,table) (st_index_t)(*(table)-&gt;type-&gt;hash)((key))</span>
</code></pre>
<p>这段代码似乎不是很好理解，我们来一点点地看：</p>
<p>首先这是一个宏定义，传入两个参数key和table，给出一个值，其类型为st_index_t，也就是哈希表的具体位置（数组下标）</p>
<p>然后来看具体的内容</p>
<pre class="highlight"><code class="c">(*(table)-&gt;type-&gt;hash)((key))
</code></pre>
<p>这个语法其实是一个函数调用。(table)-&gt;type-&gt;hash是一个函数指针，指向hash函数，key是其参数。</p>
<p>那么想要找到真正的哈希函数，就必须要找到初始化时这个table-&gt;type-&gt;hash被赋了什么值：</p>
<p>哈希表的初始化有些复杂，但是为了讨论的方便还是介绍一下：</p>
<p>首先，所有的初始化都最终被转发到这个函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-function">st_table*
<span class="hljs-title">st_init_table_with_size</span><span class="hljs-params">(<span class="hljs-keyword">const</span> struct st_hash_type *type, <span class="hljs-keyword">st_index_t</span> <span class="hljs-built_in">size</span>)</span>
</span></code></pre>
<p>然后实际使用时有三种初始化方法：</p>
<pre class="highlight"><code class="c"><span class="hljs-function">st_table*
<span class="hljs-title">st_init_numtable_with_size</span><span class="hljs-params">(<span class="hljs-keyword">st_index_t</span> <span class="hljs-built_in">size</span>)</span>
</span>&#123;
    <span class="hljs-keyword">return</span> st_init_table_with_size(&amp;type_numhash, <span class="hljs-built_in">size</span>);
&#125;
</code></pre>
<pre class="highlight"><code class="c"><span class="hljs-function">st_table*
<span class="hljs-title">st_init_strtable_with_size</span><span class="hljs-params">(<span class="hljs-keyword">st_index_t</span> <span class="hljs-built_in">size</span>)</span>
</span></code></pre>
<pre class="highlight"><code class="c"><span class="hljs-function">st_table*
<span class="hljs-title">st_init_strcasetable_with_size</span><span class="hljs-params">(<span class="hljs-keyword">st_index_t</span> <span class="hljs-built_in">size</span>)</span>
</span></code></pre>
<p>我们这里只研究第一种st_init_numtable_with_size。这一种看名字就知道是整数对整数的映射。<br />
它传入了一个type_numhash，这看起来是一个全局常量：</p>
<pre class="highlight"><code class="c"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> type_numhash st_hashtype_num</span>
<span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_hash_type</span> <span class="hljs-title">st_hashtype_num</span> = &#123;</span>
    st_numcmp,
    st_numhash,
&#125;;
</code></pre>
<p>那么，整数对整数的映射实际上应该调用到st_numhash这个函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 1666 - 1683行 */</span>
<span class="hljs-function"><span class="hljs-keyword">st_index_t</span>
<span class="hljs-title">st_numhash</span><span class="hljs-params">(<span class="hljs-keyword">st_data_t</span> n)</span>
</span>&#123;
    <span class="hljs-comment">/*
     * This hash function is lightly-tuned for Ruby.  Further tuning
     * should be possible.  Notes:
     *
     * - (n &gt;&gt; 3) alone is great for heap objects and OK for fixnum,
     *   however symbols perform poorly.
     * - (n &gt;&gt; (RUBY_SPECIAL_SHIFT+3)) was added to make symbols hash well,
     *   n.b.: +3 to remove ID scope, +1 worked well initially, too
     * - (n &lt;&lt; 3) was finally added to avoid losing bits for fixnums
     * - avoid expensive modulo instructions, it is currently only
     *   shifts and bitmask operations.
     */</span>
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">st_index_t</span>)((n&gt;&gt;(RUBY_SPECIAL_SHIFT+<span class="hljs-number">3</span>)|(n&lt;&lt;<span class="hljs-number">3</span>)) ^ (n&gt;&gt;<span class="hljs-number">3</span>));
&#125;
</code></pre>
<p>这个函数看起来倒是很简单，就是用n做了一些位运算。不过不属于教师讲述的6中方法之一。</p>
<p>这很大程度地激起了我的好奇心：难道Index是32位的整数吗？这个函数没有任何取模操作，如果传入一个很大的n,它该如何处理呢？</p>
<p>不要着急，让我们继续追踪吧：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 584 - 588行 */</span>
    <span class="hljs-keyword">if</span> (ptr == <span class="hljs-number">0</span>) &#123;
key = (*func)(key);
add_direct(table, key, value, hash_val, bin_pos);
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    &#125;
</code></pre>
<p>我们注意到bin_pos这个参数，因为在add_direct函数中，它会调用new_entry函数，最后会执行这个语句：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 445 行 */</span> 
entry-&gt;next = table-&gt;bins[bin_pos];
table-&gt;bins[bin_pos] = entry;
</code></pre>
<p>显然地，bin_pos才是数组查找的真正下标！那么bin_pos是在哪里被设置的呢？一个出乎预料的答案是在FIND_ENTRY宏中：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 582行*/</span>
    FIND_ENTRY(table, ptr, hash_val, bin_pos);
</code></pre>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 344行 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FIND_ENTRY(table, ptr, hash_val, bin_pos) \
    ((ptr) = find_entry((table), key, (hash_val), ((bin_pos) = hash_pos(hash_val, (table)-&gt;num_bins))))</span>
</code></pre>
<p>经历了千辛万苦，我们终于来到了真正获取下标的hash_pos宏：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 89行 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> hash_pos(h,n) ((h) &amp; (n - 1))</span>
</code></pre>
<p>这里可以看到，实际的下标是和哈希表的长度与之后的结果。</p>
<p>有人可能会问，为什么要有两套键（一个hash_val，一个bin_pos）呢？我们下面会谈到，这里埋个伏笔。不过在谈到这个问题之前，我们先要看看它的碰撞处理。</p>
<h4 id="st_table的碰撞处理"><a class="markdownIt-Anchor" href="#st_table的碰撞处理"></a> st_table的碰撞处理</h4>
<p>如果FIND_ENTRY宏找到了该key，st_table会如何处理呢？其实，这个问题在add_direct调用的new_enrty函数那里就可以看出来：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 445 - 446行 */</span>
    entry-&gt;next = table-&gt;bins[bin_pos];
    table-&gt;bins[bin_pos] = entry;
</code></pre>
<p>这写法显然是链表的头插法，所以是链地址法。</p>
<h4 id="st_table的扩容"><a class="markdownIt-Anchor" href="#st_table的扩容"></a> st_table的扩容</h4>
<p>在我们实现的哈希表中，真正的哈希算法为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>h</mi><mi>a</mi><mi>s</mi><mi>h</mi><mo>=</mo><mi>M</mi><mi>D</mi><mn>5</mn><mo stretchy="false">(</mo><mi>k</mi><mi>e</mi><mi>y</mi><mo stretchy="false">)</mo><mi mathvariant="normal">%</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">hash = MD5(key) \% n
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mord mathdefault">a</span><span class="mord mathdefault">s</span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord">5</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mord">%</span><span class="mord mathdefault">n</span></span></span></span></span></p>
<p>这样一来带来一个很麻烦的问题 – 扩容时必须重新计算哈希值。</p>
<p>而我们可以猜想到，得益于ruby哈希表中hash_val和bin_pos的分离，扩容时只需要重新计算bin_pos，而不需要重新计算哈希值。</p>
<p>真的是这样吗？让我们再看看源代码：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 459 - 462行 */</span>
    <span class="hljs-keyword">if</span> (table-&gt;num_entries &gt; ST_DEFAULT_MAX_DENSITY * table-&gt;num_bins) &#123;
rehash(table);
    bin_pos = hash_pos(hash_val, table-&gt;num_bins);
    &#125;
</code></pre>
<p>可以清楚地看到，如果现在的哈希表项数大于可以容纳的最大数量 * 一个密度常数，那么就用rehash()函数重新对这个表作哈希，而rehash()函数定义如下：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 609 - 627行 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>
<span class="hljs-title">rehash</span><span class="hljs-params">(<span class="hljs-keyword">register</span> st_table *table)</span>
</span>&#123;
    <span class="hljs-keyword">register</span> st_table_entry *ptr, **new_bins;
    <span class="hljs-keyword">st_index_t</span> new_num_bins, hash_val;

    new_num_bins = new_size(table-&gt;num_bins+<span class="hljs-number">1</span>);
    new_bins = st_realloc_bins(table-&gt;bins, new_num_bins, table-&gt;num_bins);
    table-&gt;num_bins = new_num_bins;
    table-&gt;bins = new_bins;

    <span class="hljs-keyword">if</span> ((ptr = table-&gt;head) != <span class="hljs-number">0</span>) &#123;
	<span class="hljs-keyword">do</span> &#123;
	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);
	    ptr-&gt;next = new_bins[hash_val];
	    new_bins[hash_val] = ptr;
	&#125; <span class="hljs-keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="hljs-number">0</span>);
    &#125;
&#125;
</code></pre>
<p>这段代码有两个地方需要研究</p>
<ol>
<li>new_size是如何实现的，新的大小和现大小是什么关系？</li>
<li>现在的哈希表是如何迁移到新的哈希表的？</li>
</ol>
<p>首先研究第一个问题，我们直接研究new_size函数：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 157 - 172行 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">st_index_t</span>
<span class="hljs-title">new_size</span><span class="hljs-params">(<span class="hljs-keyword">st_index_t</span> <span class="hljs-built_in">size</span>)</span>
</span>&#123;
    <span class="hljs-keyword">st_index_t</span> n;

    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> &amp;&amp; (<span class="hljs-built_in">size</span> &amp; ~(<span class="hljs-built_in">size</span> - <span class="hljs-number">1</span>)) == <span class="hljs-built_in">size</span>) <span class="hljs-comment">/* already a power-of-two? */</span>
	<span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>;

    n = next_pow2(<span class="hljs-built_in">size</span>);
    <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-built_in">size</span>)
	<span class="hljs-keyword">return</span> n;
<span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> NOT_RUBY</span>
    rb_raise(rb_eRuntimeError, <span class="hljs-string">"st_table too big"</span>);
<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;			<span class="hljs-comment">/* should raise exception */</span>
&#125;
</code></pre>
<p>可以看到，下一个大小是next_pow2算出来的。也就是说，新的大小和旧的大小有如下关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msub><mo>=</mo><mn>2</mn><mo>×</mo><mi>s</mi><mi>i</mi><mi>z</mi><msub><mi>e</mi><mrow><mi>f</mi><mi>o</mi><mi>r</mi><mi>m</mi><mi>e</mi><mi>r</mi></mrow></msub></mrow><annotation encoding="application/x-tex">size_{new} = 2 \times size_{former}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80952em;vertical-align:-0.15em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9456279999999999em;vertical-align:-0.286108em;"></span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10764em;">f</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">m</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>然后研究第二个问题，现在的哈希表如何迁移到新的哈希表。</p>
<p>首先，st_realloc_bins只会重新分配内存，而不会迁移，真正的迁移在这个循环中进行：</p>
<pre class="highlight"><code class="c"><span class="hljs-keyword">if</span> ((ptr = table-&gt;head) != <span class="hljs-number">0</span>) &#123;
	<span class="hljs-keyword">do</span> &#123;
	    hash_val = hash_pos(ptr-&gt;hash, new_num_bins);
	    ptr-&gt;next = new_bins[hash_val];
	    new_bins[hash_val] = ptr;
	&#125; <span class="hljs-keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="hljs-number">0</span>);
&#125;
</code></pre>
<p>要说明白这个循环，必须认真研究一下st_table_entry：</p>
<pre class="highlight"><code class="c"><span class="hljs-comment">/* ruby/st.c 18 - 26行 */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_table_entry</span> <span class="hljs-title">st_table_entry</span>;</span>

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">st_table_entry</span> &#123;</span>
    <span class="hljs-keyword">st_index_t</span> hash;
    <span class="hljs-keyword">st_data_t</span> key;
    <span class="hljs-keyword">st_data_t</span> record;
    st_table_entry *next;
    st_table_entry *fore, *back;
&#125;;
</code></pre>
<p>这个next，指向的是本bin_pos的下一个项；而fore和back，实际上是把整个哈希表中所有的项做成了一个双向链表！</p>
<p>回过头来再看add_direct的最后一部分，我们会有种恍然大悟的感觉：</p>
<pre class="highlight"><code class="c">    <span class="hljs-keyword">if</span> (table-&gt;head != <span class="hljs-number">0</span>) &#123;
entry-&gt;fore = <span class="hljs-number">0</span>;
(entry-&gt;back = table-&gt;tail)-&gt;fore = entry;
table-&gt;tail = entry;
    &#125;
    <span class="hljs-keyword">else</span> &#123;
table-&gt;head = table-&gt;tail = entry;
entry-&gt;fore = entry-&gt;back = <span class="hljs-number">0</span>;
    &#125;
</code></pre>
<p>这也正是双向链表的插入操作，其中table-&gt;head是头指针，table-&gt;tail是尾指针。这样一来，所有的项都串成了一个双向链表，通过从头指针开始的遍历就可以将所有的项加入新的哈希表中，而这正是这个循环所做的事情：</p>
<pre class="highlight"><code class="c"><span class="hljs-keyword">do</span> &#123;
	hash_val = hash_pos(ptr-&gt;hash, new_num_bins);
	ptr-&gt;next = new_bins[hash_val];
	new_bins[hash_val] = ptr;
&#125; <span class="hljs-keyword">while</span> ((ptr = ptr-&gt;fore) != <span class="hljs-number">0</span>);
</code></pre>
<p>特别地，我们发现它确实只是将哈希值用hash_pos宏变为了bin_pos，即下标，从而避免了再次哈希键。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<p>总的来说，ruby中的哈希表有这几个特性：</p>
<ol>
<li>哈希函数是将键做不循环的位运算。</li>
<li>哈希值和真正的下标分离，真正的下标由哈希值逻辑与哈希表长度得到，扩容时不需要再次计算哈希值，只需要再次计算真正的下标。</li>
<li>冲突处理采用链地址法。</li>
<li>容量永远是2的n次方，扩容时，新的容量是现容量的两倍</li>
<li>将所有的哈希表项用一个双向链表串起来，用头指针和尾指针实现对整个哈希表的高效遍历。</li>
</ol>

    </div>

</div>
                <div class="footer">
    <span>Copyright © 2022 aya ⊢ blog</span>
    <span>Theme Designed By <a target="_blank" href="https://zheli.design/one-paper">這Li</a></span>
</div>


<link rel="stylesheet" href="/css/a11y-dark.min.css">


<script src="/js/highlight.min.js"></script>


<script src="/js/highlightjs-line-numbers.js"></script>


<script>
    hljs.initHighlightingOnLoad();
    hljs.initLineNumbersOnLoad();
</script>

            </div>
        </div>
    </body>
</html>