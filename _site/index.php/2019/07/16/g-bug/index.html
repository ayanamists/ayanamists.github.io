<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>消失的__free_hook=NULL:一个G++编译优化的BUG | Your awesome title</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="消失的__free_hook=NULL:一个G++编译优化的BUG" />
<meta name="author" content="ayanamists" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：" />
<meta property="og:description" content="我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：" />
<link rel="canonical" href="http://localhost:4000/index.php/2019/07/16/g-bug/" />
<meta property="og:url" content="http://localhost:4000/index.php/2019/07/16/g-bug/" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-07-16T05:48:39-07:00" />
<script type="application/ld+json">
{"description":"我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：","headline":"消失的__free_hook=NULL:一个G++编译优化的BUG","dateModified":"2019-07-16T05:48:39-07:00","@type":"BlogPosting","datePublished":"2019-07-16T05:48:39-07:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/index.php/2019/07/16/g-bug/"},"url":"http://localhost:4000/index.php/2019/07/16/g-bug/","author":{"@type":"Person","name":"ayanamists"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">消失的__free_hook=NULL:一个G++编译优化的BUG</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-07-16T05:48:39-07:00" itemprop="datePublished">Jul 16, 2019
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">ayanamists</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>我的C++大作业是实现一个自己的STL deque，由于构造函数过慢（STL20ns，笔者200ns），笔者自己实现了一个针对于0x1010大小的内存分配器。为了不大量修改代码，我使用了__malloc_hook和\__free_hook这两个全局变量。大致的思路是使用一个全局对象，在其构造函数里先用mmap分配一个区域，然后在这个区域里建好一个0x1010大小的chunk链表：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">chxAlloc::chxAlloc()
{
    //std::cout &lt;&lt; "invoke chxAlloc\n";
    void *begin =
        mmap(NULL, sizeof(allocChunk) * INIT_NUMBER + 0X10,
             PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
    if ((long long)begin == -1)
    {
        std::cout &lt;&lt; "error occur in mmap\n";
        exit(-1);
    }

    for (int i = 0; i &lt; INIT_NUMBER; ++i)
    {
        allocChunk *temp = (allocChunk *)begin;
        temp-&gt;nextPtr = fast_TARGET;
        fast_TARGET = temp;
        temp-&gt;sign = -TARGET;
        begin = ((char *)begin + sizeof(allocChunk));
    }
}</pre>

<p>对GLIBC有了解的读者应该知道，这样其实是手工建立了一个大小为0x1010的fast_chunk链表。由于我不太了解全局对象的构造和其他初始化阶段的顺序，为避免出现问题，我在第一次调用deque的函数时才将malloc和free钩住。</p>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="false" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (__builtin_expect(count == 0, 0))
    {
        __malloc_hook = chx.chenxiAlloc;
        __free_hook = chx.chenxiFree;
        count++;
    }</pre>

<p>在这样钩住之后，调用malloc就会调用到chenxiAlloc，调用free就会调用到chenxiFree. 如果申请或释放的大小不是0x1010（这里我们将自己的chunk_size设为-0x1010，在free的时候就可以检测到），我们就调用GLIBC的malloc和free:</p>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__malloc_hook = NULL;
void *ret = malloc(size);
if (ret == NULL)
{
    std::cout &lt;&lt; "error occur in glibc malloc\n";
    exit(0);
}
__malloc_hook = &chenxiAlloc;
return ret;</pre>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">if (*((long long *)ptr - 1) &lt; 0)
 {
    *((void **)ptr - 2) = fast_TARGET;
    fast_TARGET = (allocChunk&lt;TARGET&gt; *)((void **)ptr - 2);
}
else
{
    __free_hook = NULL;
    free(ptr);
    __free_hook = &chenxiFree;
}</pre>

<p>有趣的是，在使用O2编译优化的情况下，分配一个大小不为0x1010的块会出现意想不到的结果：free和chenxiFree反复相互调用，最终导致栈地址空间被用尽，产生segment fault.</p>

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">Program received signal SIGSEGV, Segmentation fault.
0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710) at malloc.c:3094
3094	malloc.c: No such file or directory.
(gdb) bt
#0  0x00007ffff6f1dc25 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#2  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#3  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#4  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#5  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#6  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#7  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#8  0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#9  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#10 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#11 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#12 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094
#13 0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
#14 0x00007ffff6f1dc27 in __GI___libc_free (mem=0x555555801710)
    at malloc.c:3094</pre>

<p>更有趣的是，如果不开启编译优化，上述行为就不会出现错误。基于此，笔者想到了GCC内嵌汇编中的__volatile__关键字。</p>

<pre class="EnlighterJSRAW" data-enlighter-language="cpp" data-enlighter-theme="atomic" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">__asm__ __volatile__ (...);</pre>

<p>这里的__volatile__表示后面的语句不作优化（可以理解为强制按指令顺序执行），但这个关键字并不是标准的C关键字，而是类似于__builtin__expected()的仅GCC实现的关键字。利用这个关键字是否可以实现不去优化呢？</p>

<p>遗憾的是，无论是查找中文还是英文资料，这个关键字都只用这一种用法。但令笔者眼前一亮的是，C/C++语言中有一个类似的标准关键字：volatile.</p>

<p>volatile是一个加在变量的声明前的关键字，类似于这样使用：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">int volatile a = 0;</pre>

<p>这表示变量a是“易变的”，也就是说，每次访问a时，必须到内存中访问，不可以用寄存器中的值。它多用于多线程环境中。为什么必须访问内存呢？假设a可以被T1和T2两个线程访问，T1首先将a的值写入EAX寄存器，但在T1使用a之前，T2更新了a的值，那么现在T1现在要使用a，应该使用内存中的更新后的值，而非EAX中的值。</p>

<p>笔者立刻修改了__malloc_hook和\__free_hook的声明，都加入了volatile：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">typedef void *(*mallocType)(unsigned);
extern volatile mallocType __malloc_hook;

typedef void (*freeType)(void *);
extern volatile freeType __free_hook;</pre>

<p>问题果然解决了。可是为什么不加volatile会产生那么滑稽的错误呢？笔者进行了反汇编分析：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) f 1
#1  0x000055555555df90 in chxAlloc::chenxiFree(void*) ()
(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
   0x000055555555df80 &lt;+0&gt;:	cmpq   $0x0,-0x8(%rdi)
   0x000055555555df85 &lt;+5&gt;:	js     0x55555555dfa8 &lt;_ZN8chxAlloc10chenxiFreeEPv+40&gt;
   0x000055555555df87 &lt;+7&gt;:	sub    $0x8,%rsp
   0x000055555555df8b &lt;+11&gt;:	callq  0x55555555b450 &lt;free@plt&gt;
=&gt; 0x000055555555df90 &lt;+16&gt;:	lea    -0x17(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv&gt;
   0x000055555555df97 &lt;+23&gt;:	mov    %rax,0x28e5f2(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555df9e &lt;+30&gt;:	add    $0x8,%rsp
   0x000055555555dfa2 &lt;+34&gt;:	retq   
   0x000055555555dfa3 &lt;+35&gt;:	nopl   0x0(%rax,%rax,1)
   0x000055555555dfa8 &lt;+40&gt;:	mov    0x28e871(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfaf &lt;+47&gt;:	sub    $0x10,%rdi
   0x000055555555dfb3 &lt;+51&gt;:	mov    %rax,(%rdi)
   0x000055555555dfb6 &lt;+54&gt;:	mov    %rdi,0x28e863(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfbd &lt;+61&gt;:	retq   
End of assembler dump.
</pre>

<p>注意那句callq的上方，反汇编给出的语句是sub $8, %rsp, 也就是将rsp-8h，这语句的作用肯定不是将__free_hook置空，它其实应该在开头执行，是函数常有的抬高栈顶的操作。只是编译器检测出，另外的一条分支不需要抬高栈顶。所以只需要在这个分支做（这是一种编译优化策略，读者可自行查找相关资料）。那么我的那句\__free_hook = NULL去了哪里呢？正是因为这里没有置空，所以才导致了free调用chenxiFree，chenxiFree调用free的死锁。保险起见，我们再用IDA反编译一下：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="generic" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">else
  {
    free((void *)this);
    result = chxAlloc::chenxiFree;
    _free_hook = (__int64)chxAlloc::chenxiFree;
  }</pre>

<p>果然如此，将__free_hook置NULL的操作竟然被编译器无视了。为什么会这样？笔者对编译原理了解很肤浅，难以解答这个问题。但是，这个问题确实可以通过加入volatile关键字来解决。很自然地，我们用加入后的反汇编代码做个对比：</p>

<pre class="EnlighterJSRAW" data-enlighter-language="asm" data-enlighter-theme="" data-enlighter-highlight="" data-enlighter-linenumbers="" data-enlighter-lineoffset="" data-enlighter-title="" data-enlighter-group="">(gdb) disass
Dump of assembler code for function _ZN8chxAlloc10chenxiFreeEPv:
=&gt; 0x000055555555df80 &lt;+0&gt;:	hlt    
   0x000055555555df81 &lt;+1&gt;:	cmpq   $0x0,-0x8(%rdi)
   0x000055555555df86 &lt;+6&gt;:	js     0x55555555dfb0 &lt;_ZN8chxAlloc10chenxiFreeEPv+48&gt;
   0x000055555555df88 &lt;+8&gt;:	sub    $0x8,%rsp
   0x000055555555df8c &lt;+12&gt;:	movq   $0x0,0x28e5f9(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555df97 &lt;+23&gt;:	callq  0x55555555b450 &lt;free@plt&gt;
   0x000055555555df9c &lt;+28&gt;:	lea    -0x23(%rip),%rax        # 0x55555555df80 &lt;_ZN8chxAlloc10chenxiFreeEPv&gt;
   0x000055555555dfa3 &lt;+35&gt;:	mov    %rax,0x28e5e6(%rip)        # 0x5555557ec590 &lt;__free_hook@@GLIBC_2.2.5&gt;
   0x000055555555dfaa &lt;+42&gt;:	add    $0x8,%rsp
   0x000055555555dfae &lt;+46&gt;:	retq   
   0x000055555555dfaf &lt;+47&gt;:	nop
   0x000055555555dfb0 &lt;+48&gt;:	mov    0x28e869(%rip),%rax        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfb7 &lt;+55&gt;:	sub    $0x10,%rdi
   0x000055555555dfbb &lt;+59&gt;:	mov    %rax,(%rdi)
   0x000055555555dfbe &lt;+62&gt;:	mov    %rdi,0x28e85b(%rip)        # 0x5555557ec820 &lt;_ZN8chxAlloc11fast_TARGETE&gt;
   0x000055555555dfc5 &lt;+69&gt;:	retq   
End of assembler dump.
</pre>

<p>注意eip+12的位置，这一句话执行了__free_hook = NULL.</p>

<p>最后，用贝木泥舟式的话来说，从这次的事件中我应该得到的教训是：编译优化会产生BUG.</p>

  </div><a class="u-url" href="/index.php/2019/07/16/g-bug/" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Your awesome title</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Your awesome title</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jekyll"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jekyll</span></a></li><li><a href="https://www.twitter.com/jekyllrb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jekyllrb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
